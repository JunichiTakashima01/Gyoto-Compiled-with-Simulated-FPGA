<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="writing_plugins_page" kind="page">
    <compoundname>writing_plugins_page</compoundname>
    <title>Writing plug-ins for Gyoto</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>Al the generic <ref refid="namespace_gyoto" kindref="compound">Gyoto</ref> machinery for computing orbits, reading input files, performing ray-tracing etc. is implemented in libgyoto. On the other hand, all the code specific to a given metric kind or a given astronomical object is available in plug-ins. For instance, the standard plug-in libgyoto-stdplug contains the two flavors of the Kerr metric: Gyoto::KerrBL and Gyoto::KerrKS, as well as basic objects: Gyoto::FixedStar, Gyoto::Star, Gyoto::Torus, Gyoto::ThinInfiniteDiskBL and Gyoto::ThinInfiniteDiskKS. The libgyoto-lorene plug-in contains the code to access numerical metrics (Gyoto::LoreneMetric) as well as an example thereof: Gyoto::RotStar3_1. The two basic spectral shapes <ref refid="class_gyoto_1_1_spectrum_1_1_power_law" kindref="compound">Gyoto::Spectrum::PowerLaw</ref> and <ref refid="class_gyoto_1_1_spectrum_1_1_black_body" kindref="compound">Gyoto::Spectrum::BlackBody</ref> are also to be found in the standard plug-in.</para>
<para><ref refid="namespace_gyoto" kindref="compound">Gyoto</ref> can be used right away to compute stellar orbits in the Kerr metric or to do basic ray-tracing of accretion disks. But <ref refid="namespace_gyoto" kindref="compound">Gyoto</ref> is not limited to the basic metrics and objects we have thought of. It is fairly easy to add custom metrics and objects (and emission/absorption laws) it <ref refid="namespace_gyoto" kindref="compound">Gyoto</ref>, and <ref refid="namespace_gyoto" kindref="compound">Gyoto</ref> itself does not need to be modified or even re-compiled to do so: custom classes can (and should) be implemented as plug-ins. For an example, simply look at the lib/StdPlug.C file in the source distribution, and the source files for the objects and metrics it provides: e.g. lib/FixedStar.C and lib/KerrBL.C.</para>
<para>To implement a new plug-in, you first need to implement a derived class of either the <ref refid="namespace_gyoto_1_1_astrobj" kindref="compound">Gyoto::Astrobj</ref>, <ref refid="namespace_gyoto_1_1_metric" kindref="compound">Gyoto::Metric</ref>, or <ref refid="class_gyoto_1_1_spectrum_1_1_generic" kindref="compound">Gyoto::Spectrum::Generic</ref> class. You don&apos;t necessarily need to implement everything, the <ref refid="namespace_gyoto_1_1_astrobj" kindref="compound">Gyoto::Astrobj</ref> page explains what is required for an astronomical object.</para>
<para>Assuming you want to be able to actually use your custom class, you need a way to instantiate it. This is normally the job of the <ref refid="class_gyoto_1_1_factory" kindref="compound">Gyoto::Factory</ref>. You need to instruct the <ref refid="class_gyoto_1_1_factory" kindref="compound">Gyoto::Factory</ref> how to read parameters for your specific class from an XML file by implementing a subcontractor (for a <ref refid="namespace_gyoto_1_1_astrobj" kindref="compound">Gyoto::Astrobj</ref>, the subcontractor is a static method of the <ref refid="namespace_gyoto_1_1_astrobj_1aa53c7ada58c8c8f3799c3485b7d8f3bb" kindref="member">Gyoto::Astrobj::Subcontractor_t</ref> type). The subcontractor communicates with the <ref refid="class_gyoto_1_1_factory" kindref="compound">Gyoto::Factory</ref> by means of a <ref refid="class_gyoto_1_1_factory_messenger" kindref="compound">Gyoto::FactoryMessenger</ref> and basically loops calling the <ref refid="class_gyoto_1_1_factory_messenger_1a716340221e527c61a05af389590b53f4" kindref="member">Gyoto::FactoryMessenger::getNextParameter()</ref> method (see the <ref refid="_gyoto_register_8h" kindref="compound">GyotoRegister.h</ref> file, unfortunately undocumented at the moment).</para>
<para>You also need to register your subcontractor, so that the <ref refid="class_gyoto_1_1_factory" kindref="compound">Gyoto::Factory</ref> knows it must call it when it encounters a tag of the form &lt;Astrobj kind="YourKind"&gt; in an XML description. This is typically done by providing an static Init method in your class: <programlisting><codeline><highlight class="normal">void<sp/>Gyoto::FixedStar::Init()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Gyoto::Astrobj::Register(&quot;FixedStar&quot;,<sp/>&amp;Gyoto::FixedStar::Subcontractor);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>You need to make sure this <ref refid="namespace_gyoto_1_1_units_1aade66d5933d035fb5f0fbb0501e9e972" kindref="member">Init()</ref> method is called when your plug-in is loaded. Assume you decide to call your plug-in MyPlug, and it contains a single <ref refid="namespace_gyoto_1_1_astrobj" kindref="compound">Gyoto::Astrobj</ref> named Gyoto::MyObj. You will compile it under the file name libgyoto-MyPlug.so (under Linux) or libgyoto-MyPlug.dylib (under MacOS X). Just put this file somewhere where the dynamic linker can find it (any directory listed in $LD_LIBRARY_PATH or $DYLD_LIBRARY_PATH will be fine; /usr/local/lib/ should also be fine). In addition to the implementation of the Gyoto::MyObj class, you will need to provide a function called __GyotoMyPlugInit() which will be exactly this: <programlisting><codeline><highlight class="normal">extern<sp/>&quot;C&quot;<sp/>void<sp/>__GyotostdplugInit()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Gyoto::MyObj::Init();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> This function is typically provided in a separate source file (such as lib/StdPlug.C in the <ref refid="namespace_gyoto" kindref="compound">Gyoto</ref> source) and can initialize several custom classes at once.</para>
<para>Finally, you need to instruct <ref refid="namespace_gyoto" kindref="compound">Gyoto</ref> to load your plug-in at run time. This is done by adding the name of your plug-in to the GYOTO_PLUGINS environment variable. The default value for GYOTO_PLUGINS is &quot;stdplug,nofail:lorene&quot;, meaning <ref refid="namespace_gyoto" kindref="compound">Gyoto</ref> should load the standard plug-in stdplug and attempt to load the lorene plug-in, failing only if stdplug is nowhere to be found. If you want to load your plug-in in addition to those, alter this variable in your shell (if you don&apos;t know what this means or how to do this, ask the local Unix guru or read the fine <ulink url="http://www.gnu.org/s/bash/manual/bash.html">manual</ulink>): <programlisting><codeline><highlight class="normal">export<sp/>GYOTO_PLUGINS=&quot;stdplug,nofail:lorene,MyPlug&quot;</highlight></codeline>
</programlisting> but if your lug-in is self-contained and your don&apos;t need the objects in the standard plug-ins, this will do it for you: <programlisting><codeline><highlight class="normal">export<sp/>GYOTO_PLUGINS=&quot;MyPlug&quot;</highlight></codeline>
</programlisting> This will instruct <ref refid="namespace_gyoto" kindref="compound">Gyoto</ref> to locate and load the file named libgyoto-MyPlug.(so|dylib) and to run the function named __GyotostdplugInit() from this library file. </para>
    </detaileddescription>
    <location file="/home/junichi/Gyoto/include/Gyoto.h"/>
  </compounddef>
</doxygen>
