
// File: index.xml

// File: class_gyoto_1_1_screen_1_1_angles.xml
%feature("docstring") Angles "

1D specifier for an arbitrary angle coordinate set.

C++ includes: GyotoScreen.h ";

%feature("docstring")  Angles::Angles "";

%feature("docstring")  Angles::~Angles "";

%feature("docstring")  Angles::begin "

Reset specifier to point to the first value. ";

%feature("docstring")  Angles::valid "

True if pointing to something, false if end has been reached. ";

%feature("docstring")  Angles::size "

Number of values in this container. ";

%feature("docstring")  Angles::angle "

Get double value currently pointed to. ";

%feature("docstring")  Angles::index "

Get index of value currently pointed to.

Starts at 0 and is implemented each time operator++ is called.
Depending on the implementation, this may be a real index or computed
on demand. ";


// File: class_gyoto_1_1_python_1_1_base.xml
%feature("docstring") Gyoto::Python::Base "

Base class for classes in the Python plug-in.

All derived C++ classes ( Gyoto::Metric::Python,
Gyoto::Spectrum::Python, Gyoto::Astrobj::Python::Standard and
Gyoto::Astrobj::Python::Thindisk have those three Properties: Module
(string): the module in which the Python class is implemented;

Class (string): the name of the Python class, in module Module, to
interface with;

Parameters (vector<double>): optional list of parameters for this
class. These parameters are passed one by one to the Python instance
using setitem with numerical keys.

Those C++ classes wrap around Python classes that implement certain
methods. Those Python classes may accepts parameters through the
Parameters property described above by implementing setitem, or by
providing: member \"properties\", a dict in the form {name: dtype}
where name is the property name and dtype the corresponding datatype.

methods set(self, key, value) and get(self, key).

All the Gyoto instances of the classes descending from
Gyoto::Python::Base expose themselves to the Python instance they wrap
immediately after instantiation by setting the 'this' attribute. If
the 'gyoto' Python extension can be loaded, then 'this' will be an
instance of one of the classes gyoto.Metric, gyoto.Spectrum,
gyoto.StandardAstrobj or gyoto.ThinDisk pointing to the underlying C++
instance. If the 'gyoto' extension is not available, 'this' will be
None.

C++ includes: GyotoPython.h ";

%feature("docstring")  Gyoto::Python::Base::Base "";

%feature("docstring")  Gyoto::Python::Base::Base "";

%feature("docstring")  Gyoto::Python::Base::~Base "";

%feature("docstring")  Gyoto::Python::Base::module "

Return module_. ";

%feature("docstring")  Gyoto::Python::Base::inlineModule "

Return inline_module_. ";

%feature("docstring")  Gyoto::Python::Base::module "

Set module_ and import the Python module.

Side effects: sets inline_module_ to \"\";

calls klass( class_) if class_ is already known, so module_ can be set
(or reset) after class_. ";

%feature("docstring")  Gyoto::Python::Base::inlineModule "

Set inline_module_ and import the Python module.

Side effects: sets module_ to \"\";

calls klass( class_) if class_ is already known, so module_ can be set
(or reset) after class_. ";

%feature("docstring")  Gyoto::Python::Base::klass "

Retrieve class_. ";

%feature("docstring")  Gyoto::Python::Base::klass "

Set class_ and instantiate the Python class.

Sets pInstance_.

This generic implementation takes care of the common ground, but does
not set 'this' or call parameters( parameters_). Therefore, all the
derived classes should reimplement this method and at least call
Python::Base::klass(c) and parameters( parameters_). Between the two
is the right moment to check that the Python class implements the
required API and to cache PyObject* pointers to class methods. ";

%feature("docstring")  Gyoto::Python::Base::parameters "

Retrieve parameters_. ";

%feature("docstring")  Gyoto::Python::Base::parameters "

Set parameters_ and send them to pInstance_.

The parameters are sent to the class instance using the setitem method
with numerical keys. ";

%feature("docstring")  Gyoto::Python::Base::hasPythonProperty "";

%feature("docstring")  Gyoto::Python::Base::setPythonProperty "";

%feature("docstring")  Gyoto::Python::Base::getPythonProperty "";

%feature("docstring")  Gyoto::Python::Base::pythonPropertyType "";


// File: class_gyoto_1_1_spectrum_1_1_black_body.xml
%feature("docstring") Gyoto::Spectrum::BlackBody "

Black Body.

Light emitted by e.g. a Star.

Example XML entity:

C++ includes: GyotoBlackBodySpectrum.h ";

%feature("docstring")  Gyoto::Spectrum::BlackBody::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Spectrum::BlackBody::BlackBody "";

%feature("docstring")  Gyoto::Spectrum::BlackBody::BlackBody "

Constructor setting T_ and cst_. ";

%feature("docstring")  Gyoto::Spectrum::BlackBody::clone "

Cloner. ";

%feature("docstring")  Gyoto::Spectrum::BlackBody::temperature "

Get constant. ";

%feature("docstring")  Gyoto::Spectrum::BlackBody::temperature "

Set constant. ";

%feature("docstring")  Gyoto::Spectrum::BlackBody::scaling "

Get exponent. ";

%feature("docstring")  Gyoto::Spectrum::BlackBody::scaling "

Set exponent. ";

%feature("docstring")  Gyoto::Spectrum::BlackBody::colorCorrection "

Get color correction. ";

%feature("docstring")  Gyoto::Spectrum::BlackBody::colorCorrection "

Set color correction. ";

%feature("docstring")  Gyoto::Spectrum::BlackBody::integrate "

Integrate optically thick I_nu.

See operator()(double nu) const

Parameters:
-----------

nu1:  nu2:  boundaries for the integration

I, the integral of I_nu between nu1 and nu2 ";

%feature("docstring")  Gyoto::Spectrum::BlackBody::integrate "

Integrate optically thin I_nu.

See operator()(double nu, double opacity, double ds) const

Parameters:
-----------

nu1:  nu2:  boundaries for the integration

opacity:  the frequency-dependent opacity law given as a pointer to a
Gyoto::Spectrum::Generic sub-class instance

ds:  the element length for spatial integration

I, the integral of I_nu between nu1 and nu2 ";

%feature("docstring")  Gyoto::Spectrum::BlackBody::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Spectrum::BlackBody::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Spectrum::BlackBody::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Spectrum::BlackBody::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Spectrum::BlackBody::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Spectrum::BlackBody::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Spectrum::BlackBody::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Spectrum::BlackBody::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Spectrum::BlackBody::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Spectrum::BlackBody::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Spectrum::BlackBody::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Spectrum::BlackBody::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Spectrum::BlackBody::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Spectrum::BlackBody::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Spectrum::BlackBody::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Spectrum::BlackBody::setParameters "

Main loop for parsing Properties from XML description.

This function queries the FactoryMessenger for elements to parse, and
tries to matche each element to a Property to set it  accordingly. Any
class that tries to be buildable from XML must supply a subcontractor
(for base classes such as Metric, Astrobj, Spectrum  and Spectrometer,
it is done as a template that must be  specialized for each class).
This subcontractor typically looks somewhat like this: Although this
is discouraged, it is possible to override the following functions to
customize how XML entities are parsed:    - setParameters() if low-
level access to the      FactoryMessenger is required;    -
setParameter(std::string name, std::string content,
std::string unit)      to interpret an entity that does not match a
Property      (e.g. alternative name);    -
setParameter(Gyoto::Property const &p, std::string const &name,
std::string const &content, std::string const &unit)      to change
how a Property is interpreted. ";

%feature("docstring")  Gyoto::Spectrum::BlackBody::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Spectrum::BlackBody::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Spectrum::BlackBody::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Spectrum::BlackBody::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Spectrum::BlackBody::kind "

Get kind_. ";


// File: class_gyoto_1_1_astrobj_1_1_blob.xml
%feature("docstring") Gyoto::Astrobj::Blob "

Blob of plasma following a Star orbit, emitting synchrotron, with
Gaussian time-evolving density and temperature.

C++ includes: GyotoBlob.h ";

%feature("docstring")  Gyoto::Astrobj::Blob::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Astrobj::Blob::Blob "

Default constructor.

Create Blob object with undefined initial conditions. One needs to set
the coordinate system, the metric, and the initial position and
velocity before integrating the orbit. setInititialCondition() can be
used for that. ";

%feature("docstring")  Gyoto::Astrobj::Blob::Blob "

Copy constructor. ";

%feature("docstring")  Gyoto::Astrobj::Blob::clone "

Cloner.

This method must be implemented by the various Astrobj::Generic
subclasses in order to support cloning:

Cloning is necessary for multi-threading, recommended for interaction
with the Yorick plug-in etc.

Implementing it is very straightforward, as long as the copy
constructor Generic(const Generic& ) has been implemented: ";

%feature("docstring")  Gyoto::Astrobj::Blob::~Blob "

Destructor. ";

%feature("docstring")  Gyoto::Astrobj::Blob::electronDistribution "";

%feature("docstring")  Gyoto::Astrobj::Blob::electronDistribution "";

%feature("docstring")  Gyoto::Astrobj::Blob::className "

\"Blob\" ";

%feature("docstring")  Gyoto::Astrobj::Blob::className_l "

\"inflate_star\" ";

%feature("docstring")  Gyoto::Astrobj::Blob::numberDensity "";

%feature("docstring")  Gyoto::Astrobj::Blob::numberDensity "";

%feature("docstring")  Gyoto::Astrobj::Blob::numberDensity "";

%feature("docstring")  Gyoto::Astrobj::Blob::numberDensity "";

%feature("docstring")  Gyoto::Astrobj::Blob::temperature "";

%feature("docstring")  Gyoto::Astrobj::Blob::temperature "";

%feature("docstring")  Gyoto::Astrobj::Blob::timeRef "";

%feature("docstring")  Gyoto::Astrobj::Blob::timeRef "";

%feature("docstring")  Gyoto::Astrobj::Blob::timeRef "";

%feature("docstring")  Gyoto::Astrobj::Blob::timeRef "";

%feature("docstring")  Gyoto::Astrobj::Blob::timeSigma "";

%feature("docstring")  Gyoto::Astrobj::Blob::timeSigma "";

%feature("docstring")  Gyoto::Astrobj::Blob::timeSigma "";

%feature("docstring")  Gyoto::Astrobj::Blob::timeSigma "";

%feature("docstring")  Gyoto::Astrobj::Blob::magnetizationParameter "";

%feature("docstring")  Gyoto::Astrobj::Blob::magnetizationParameter "";

%feature("docstring")  Gyoto::Astrobj::Blob::kappaIndex "";

%feature("docstring")  Gyoto::Astrobj::Blob::kappaIndex "";

%feature("docstring")  Gyoto::Astrobj::Blob::magneticConfiguration "";

%feature("docstring")  Gyoto::Astrobj::Blob::magneticConfiguration "";

%feature("docstring")  Gyoto::Astrobj::Blob::radiativeQ "

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::Blob::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::Blob::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::getMass "

Return 1.

The mass of a Star is always 1. Stars do not perturb the metric. The
only relevant point is that Stars are massive particules, their exact
mass is of no importance. ";

%feature("docstring")  Gyoto::Astrobj::Blob::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Blob::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::Blob::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::Blob::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::Blob::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::Blob::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")  Gyoto::Astrobj::Blob::setInitialCondition "

Same as Worldline::setInitialCondition(gg, coord, sys,1) ";

%feature("docstring")  Gyoto::Astrobj::Blob::setInitialCondition "

Set or re-set the initial condition prior to integration.

Parameters:
-----------

gg:   Gyoto::SmartPointer to the Gyoto::Metric in this universe;

coord:  8 element array containing the initial condition, i.e. the
4-position and the 4-velocity of the Photon at the receiving end;

dir:  direction: 1 for future, -1 for past.

Ephi:  initial value of base vector to parallel-transport. Ignored if
parallel_transport_ is false.

Etheta:  initial value of base vector to parallel-transport. Ignored
if parallel_transport_ is false. ";

%feature("docstring")  Gyoto::Astrobj::Blob::setInitialCondition "

Set or re-set the initial condition prior to integration.

Parameters:
-----------

gg:   Gyoto::SmartPointer to the Gyoto::Metric in this universe;

coord:  8 element array containing the initial condition, i.e. the
4-position and the 4-velocity of the Photon at the receiving end;

dir:  direction: 1 for future, -1 for past. ";

%feature("docstring")  Gyoto::Astrobj::Blob::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Astrobj::Blob::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Astrobj::Blob::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")  Gyoto::Astrobj::Blob::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Astrobj::Blob::getCartesian "

Get the 6 Cartesian coordinates for specific dates.

This method is present in both the API of UniformSphere and Worldline.
It is pure virtual in UniformSphere. The Star reimplementation is a
trivial wrapper around Worldline::getCartesian(). ";

%feature("docstring")  Gyoto::Astrobj::Blob::getVelocity "

Yield velocity of the center of the sphere. ";

%feature("docstring")  Gyoto::Astrobj::Blob::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")  Gyoto::Astrobj::Blob::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::Blob::spectrum "

Set spectrum_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::spectrum "

Get spectrum_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::opacity "

Set opacity_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::opacity "

Get opacity_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::radius "

Get radius_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::Blob::radius "

Set radius_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::Blob::radius "

Get radius_ in specified unit. ";

%feature("docstring")  Gyoto::Astrobj::Blob::radius "

Set radius_ in specified unit. ";

%feature("docstring")  Gyoto::Astrobj::Blob::deltaMaxOverRadius "

Get dltmor_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::deltaMaxOverRadius "

Set dltmor_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::deltaMaxOverDistance "

Get dltmod_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::deltaMaxOverDistance "

Set dltmod_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::isotropic "";

%feature("docstring")  Gyoto::Astrobj::Blob::isotropic "";

%feature("docstring")  Gyoto::Astrobj::Blob::alpha "";

%feature("docstring")  Gyoto::Astrobj::Blob::alpha "";

%feature("docstring")  Gyoto::Astrobj::Blob::deltaMax "

Parameters:

coord:  current photon position

max( dltmor_* radius_, dltmod_*operator()(double coord[]) ) ";

%feature("docstring")  Gyoto::Astrobj::Blob::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")  Gyoto::Astrobj::Blob::deltaMax "

Get delta_max_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::deltaMax "

Get delta max at a given position

Parameters:
-----------

pos:  4-position

delta_max_external:  external constraint on delta_max

the smallest value between delta_max_, delta_max_external, and R*
delta_max_over_r_ where R is pos[1] in spherical coordinates and
max(x1, x2, x3) in Cartesian coordinates. ";

%feature("docstring")  Gyoto::Astrobj::Blob::deltaMax "

Set delta_max_ ";

%feature("docstring")  Gyoto::Astrobj::Blob::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::Blob::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::Blob::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Blob::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")  Gyoto::Astrobj::Blob::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Blob::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")  Gyoto::Astrobj::Blob::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Blob::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Blob::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Blob::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Blob::safetyValue "

Set Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::safetyValue "

Get Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::deltaInObj "

Get Generic::delta_inobj_.

Get the constant integration step inside the astrobj

delta_inobj_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Blob::deltaInObj "

Set Generic::delta_inobj_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::Blob::giveDelta "

Maximum inside object.

Gives the requested integration stept (in coordinate time t) between
two neighbooring points along a portion of geodesic inside an astrobj;
the current implementation only considers a constant delta, equal to
Standard::deltaInobj()

Parameters:
-----------

coord:  input coordinate at whicht is given ";

%feature("docstring")
Gyoto::Astrobj::Blob::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::Blob::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")  Gyoto::Astrobj::Blob::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::Blob::showshadow "";

%feature("docstring")  Gyoto::Astrobj::Blob::showshadow "";

%feature("docstring")  Gyoto::Astrobj::Blob::redshift "";

%feature("docstring")  Gyoto::Astrobj::Blob::redshift "";

%feature("docstring")  Gyoto::Astrobj::Blob::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")  Gyoto::Astrobj::Blob::processHitQuantities "

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")  Gyoto::Astrobj::Blob::processHitQuantities "";

%feature("docstring")  Gyoto::Astrobj::Blob::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Blob::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Blob::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Blob::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Blob::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::Blob::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::Blob::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::Blob::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::Blob::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::Blob::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")  Gyoto::Astrobj::Blob::computeB4vect_ipole "";

%feature("docstring")  Gyoto::Astrobj::Blob::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::Blob::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::Blob::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::Blob::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::Blob::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::Blob::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::Blob::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Blob::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Blob::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Blob::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Blob::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Blob::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Blob::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::Blob::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::Blob::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::Blob::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Astrobj::Blob::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::Blob::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::Blob::kind "

Get kind_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::getImin "

Get imin_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::getImax "

Get imax_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::getI0 "

Get i0_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::initCoord "";

%feature("docstring")  Gyoto::Astrobj::Blob::initCoord "";

%feature("docstring")  Gyoto::Astrobj::Blob::setInitCoord "

Set Initial coordinate.

Set imin_= imax_= i0_, and x  [i0]=coord[ ].

If dir==1, i0_ is set to 0. If dir==-1, i0_ is set to x_size_-1.

If dir==0 and the Worldine has never been computed ( i0_==0, imin_==1
and imax_==0), then dir defaults to 1 for a massive particle and -1
for a massless particle.

If dir==0 and the Worldine has already been computed, i0_ is not
changed.



Parameters:
-----------

coord:  new initial coordinates

dir:  direction of integration. 1 for forward integration, -1 for
backards integration, 0 for unknown or both

Ephi:  initial value of base vector to parallel-transport. Ignored if
parallel_transport_ is false.

Etheta:  initial value of base vector to parallel-transport. Ignored
if parallel_transport_ is false. ";

%feature("docstring")  Gyoto::Astrobj::Blob::setInitCoord "

Set Initial coordinate.

Set imin_= imax_= i0_, and x  [i0]=coord[ ].

If dir==1, i0_ is set to 0. If dir==-1, i0_ is set to x_size_-1.

If dir==0 and the Worldine has never been computed ( i0_==0, imin_==1
and imax_==0), then dir defaults to 1 for a massive particle and -1
for a massless particle.

If dir==0 and the Worldine has already been computed, i0_ is not
changed.



Parameters:
-----------

coord:  new initial coordinates

dir:  direction of integration. 1 for forward integration, -1 for
backards integration, 0 for unknown or both ";

%feature("docstring")  Gyoto::Astrobj::Blob::setInitCoord "

Set initial coordinate.

Parameters:
-----------

pos:  initial 4-position

vel:  initial 3-velocity

dir:  direction of integration ";

%feature("docstring")  Gyoto::Astrobj::Blob::setPosition "

Set initial 4-position. ";

%feature("docstring")  Gyoto::Astrobj::Blob::setVelocity "

Set initial 3-velocity. ";

%feature("docstring")  Gyoto::Astrobj::Blob::reset "

Forget integration, keeping initial contition. ";

%feature("docstring")  Gyoto::Astrobj::Blob::reInit "

Reset and recompute particle properties. ";

%feature("docstring")  Gyoto::Astrobj::Blob::integrator "

Set the integrator.

Initialize state_ to use the required integrator.

Parameters:
-----------

type:  Either \"Legacy\" or (if GYOTO_HAVE_BOOST_INTEGRATORS) one of
\"runge_kutta_cash_karp54\", \"runge_kutta_fehlberg78\",
\"runge_kutta_dopri5\", \"runge_kutta_cash_karp54_classic\" ";

%feature("docstring")  Gyoto::Astrobj::Blob::integrator "

Describe the integrator used by state_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::integ31 "

Set the integrator kind to 3+1 or 4D.

Initialize state_ to use the required geodesic equation. ";

%feature("docstring")  Gyoto::Astrobj::Blob::integ31 "

Get the kind of geodesic equation integrated by state_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::deltaMin "

Get delta_min_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::deltaMin "

Set delta_min_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::absTol "

Set abstol_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::absTol "

Get abstol_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::relTol "

Set reltol_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::relTol "

Get reltol_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::maxCrossEqplane "

Set #maxCrosEqplane_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::maxCrossEqplane "

Get maxCrossEqplane_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::deltaMaxOverR "

Get delta_max_over_r_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::deltaMaxOverR "

Set delta_max_over_r_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::delta "

Expand memory slots for polarization vectors.

Assignment to another Worldline Set delta_ ";

%feature("docstring")  Gyoto::Astrobj::Blob::delta "

Set delta_ in specified units. ";

%feature("docstring")  Gyoto::Astrobj::Blob::delta "

Get delta_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::delta "

Get delta_ in specified units. ";

%feature("docstring")  Gyoto::Astrobj::Blob::tMin "

Get tmin_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::tMin "

Get tmin_ in specified unit. ";

%feature("docstring")  Gyoto::Astrobj::Blob::tMin "

Set tmin_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::tMin "

Set tmin_ in specified unit. ";

%feature("docstring")  Gyoto::Astrobj::Blob::adaptive "

Set adaptive_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::adaptive "

Get adaptive_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::secondary "

Set secondary_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::secondary "

Get secondary_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::parallelTransport "

Set parallel_transport_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::parallelTransport "

Get parallel_transport_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::maxiter "

Set maxiter_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::maxiter "

Get maxiter_. ";

%feature("docstring")  Gyoto::Astrobj::Blob::getCst "

Returns the worldline's cst of motion (if any)

Return pointer to array holding the previously set Metric-specific
constants of motion.

This function returns a pointer to the actual storage location and
should be handled with care. std::vector<double> Worldline:
constantsOfMotion() constprovides a convenient way to retrieve a copy
of the content. ";

%feature("docstring")  Gyoto::Astrobj::Blob::setCst "

Set Metric-specific constants of motion.

The will (re)allocate Worldline::cst_, copy cst into it, and set
Worldline::cst_n_.

This is the same as void Worldline:
constantsOfMotion(std::vector<double> const cstv) using a C-style
array instead of a vector. ";

%feature("docstring")  Gyoto::Astrobj::Blob::constantsOfMotion "

Set Metric-specific constants of motion.

The will (re)allocate Worldline::cst_, copy cst into it, and set
Worldline::cst_n_.

This is the same as getCst using a vector instead of a C-style array.
";

%feature("docstring")  Gyoto::Astrobj::Blob::constantsOfMotion "

Return a copy of the Metric-specific constants of motion.

This funtion return a copy of the constants of motion. getCst() can be
used to retrieve a pointer to the actual array used internally which
is slightly more efficient for read-only access. ";

%feature("docstring")  Gyoto::Astrobj::Blob::getInitialCoord "

Get initial coordinates + base vectors.

Depending on the size of dest and on the value of parallel_transport_,
get position (xi_), velocity (xidot_) and possibly other triad vectors
(epi_ and eti_). ";

%feature("docstring")  Gyoto::Astrobj::Blob::getCoord "

Get coordinates+base vectors corresponding to index.

Depending on the value of parallel_transport_, get position (xi_),
velocity (xidot_) and possibly other triad vectors (epi_ and eti_).
coord is resized to the right number of elements. ";

%feature("docstring")  Gyoto::Astrobj::Blob::getCoord "

Get coordinates+base vectors corresponding to index.

We need this non-const implementation to allow the const, size_t and
the non-const, double implementations to coexist. ";

%feature("docstring")  Gyoto::Astrobj::Blob::getCoord "

Get coordinates+base vectors corresponding to date dest[0].

Depending on the value of parallel_transport_, get position (xi_),
velocity (xidot_) and possibly other triad vectors (epi_ and eti_).
coord is resized to the right number of elements. ";

%feature("docstring")  Gyoto::Astrobj::Blob::getCoord "

Get 8-coordinates for specific dates.

The coordinates will be computed using the integrator, so they will be
as accurate as possible. Some heuristics are used to speed up the
process and it is presumably faster to call this routine with a sorted
list of dates. The line will be integrated further as required. An
error will be thrown if it is not possible to reach a certain date.

Parameters:
-----------

dates:  the list of dates for which the coordinates are to be computed
in proper time or affine parameter if #proper is true or in coordinate
time if #proper is false (default);

n_dates:  the number of dates to compute ;

x1dest:  x2dest:  x3dest:  x0dot:  x1dot:  x2dot:  x3dot:  arrays in
which to store the result. These pointer may be set to NULL to
retrieve only part of the information. They must be pre-allocated.

ephi0:  ephi1:  ephi2:  ephi3:  etheta0:  etheta1:  etheta2:  etheta3:
arrays in which to store the ephi and etheta (parallel transport
case). These pointer may be set to NULL to retrieve only part of the
information. They must be pre-allocated.

otime:  array in which to store the other time: coordinate time if
#proper, else proper time or affine parameter.

proper:  bool: whether #dates is proper time (or affine parameter) or
coordinate time. ";

%feature("docstring")  Gyoto::Astrobj::Blob::getCoord "

Get all computed positions.

Get all the pre-computed 8 coordinates (e.g. thanks to a prior call to
xFill()) of this worldline. ";

%feature("docstring")  Gyoto::Astrobj::Blob::getCartesianPos "

Get Cartesian expression of 4-position at index. ";

%feature("docstring")  Gyoto::Astrobj::Blob::xStore "

Store coord at index ind. ";

%feature("docstring")  Gyoto::Astrobj::Blob::xStore "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Blob::xStore "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Blob::xFill "

Fill x0, x1... by integrating the Worldline from previously set
inittial condition to time tlim. ";

%feature("docstring")  Gyoto::Astrobj::Blob::get_nelements "

Get number of computed dates. ";

%feature("docstring")  Gyoto::Astrobj::Blob::get_t "

Get computed dates. ";

%feature("docstring")  Gyoto::Astrobj::Blob::get_tau "

Get computed proper times or values of the affine parameter. ";

%feature("docstring")  Gyoto::Astrobj::Blob::get_xyz "

Get 3-position in cartesian coordinates for computed dates. ";

%feature("docstring")  Gyoto::Astrobj::Blob::checkPhiTheta "

Bring in [0,] and in [0,2].

checkPhiTheta() Modifies coord if the corrdinates are spherical-like
so that coord[2]=theta is in [0,pi] and coord[3]=phi is in [0,2pi].
Important to use in all astrobj in spherical coordinates to prevent
\"z-axis problems\". ";

%feature("docstring")  Gyoto::Astrobj::Blob::getSkyPos "

Get computed positions in sky coordinates. ";

%feature("docstring")  Gyoto::Astrobj::Blob::get_dot "

Get computed 4-velocities. ";

%feature("docstring")  Gyoto::Astrobj::Blob::get_prime "

Get computed 3-velocities. ";

%feature("docstring")  Gyoto::Astrobj::Blob::save_txyz "

Save in a file. ";

%feature("docstring")  Gyoto::Astrobj::Blob::save_txyz "

Save, converted. ";


// File: class_gyoto_1_1_screen_1_1_bucket.xml
%feature("docstring") Bucket "

Class containing arbitrary 2D-points.

ispec_ and jspec_ must be the same size.

C++ includes: GyotoScreen.h ";

%feature("docstring")  Bucket::Bucket "";

%feature("docstring")  Bucket::angles "

Get angle coordinates. ";

%feature("docstring")  Bucket::begin "

Reset pointer. ";

%feature("docstring")  Bucket::valid "

Whether the end has not been passed. ";

%feature("docstring")  Bucket::size "

Number of positions contained. ";


// File: class_gyoto_1_1_metric_1_1_chern_simons.xml
%feature("docstring") Gyoto::Metric::ChernSimons "";

%feature("docstring")  Gyoto::Metric::ChernSimons::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::ChernSimons "";

%feature("docstring")  Gyoto::Metric::ChernSimons::ChernSimons "";

%feature("docstring")  Gyoto::Metric::ChernSimons::~ChernSimons "";

%feature("docstring")  Gyoto::Metric::ChernSimons::clone "

Virtual copy constructor. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::dzetaCS "";

%feature("docstring")  Gyoto::Metric::ChernSimons::dzetaCS "";

%feature("docstring")  Gyoto::Metric::ChernSimons::gmunu "

Metric coefficients.

The default implementation calls double gmunu(const double * x, int
mu, int nu) const.

Parameters:
-----------

ARGOUT_ARRAY2:  (g) 4x4 array to store the coeefficients

IN_ARRAY1:  (x) 4-position at which to compute the coefficients;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::ChernSimons::gmunu "

Metric coefficients.

The default implementation calls Metric:: gmunu(double g[4][4], const
double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::ChernSimons::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3). ";

%feature("docstring")  Gyoto::Metric::ChernSimons::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3).

1 on error, 0 otherwise ";

%feature("docstring")  Gyoto::Metric::ChernSimons::gmunu_up "

Metric contravariant coefficients.

The default implementation inverts the covariant coefficients matrix.
";

%feature("docstring")  Gyoto::Metric::ChernSimons::gmunu_up "

Metric contravariant coefficients.

The default implementation calls Metric:: gmunu_up(double g[4][4],
const double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::ChernSimons::diff "

Used in RK4 proxies. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::circularVelocity "

Yield circular velocity at a given position.

Give the velocity of a massive particle in circular orbit at the given
position projected onto the equatorial plane. Such a velocity may not
exist everywhere (or anywhere) for a given metric. This method is
intended to be used by Astrobj classes such as Torus or ThinDisk.

If keplerian_ is set to true, this method should return the Keplerian
velcity instead (derived classes should ensure this, see
KerrBL::circularVelocity() for instance).

The default implementation throws an error if keplerian_ is set to
false.

Parameters:
-----------

pos:  input: position,

vel:  output: velocity,

dir:  1 for corotating, -1 for counterrotating. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::spin "

Set spin. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::spin "

Returns spin. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::difftol "

Get difftol_. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::difftol "

Set difftol_. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::horizonSecurity "";

%feature("docstring")  Gyoto::Metric::ChernSimons::horizonSecurity "";

%feature("docstring")  Gyoto::Metric::ChernSimons::genericIntegrator "";

%feature("docstring")  Gyoto::Metric::ChernSimons::genericIntegrator "";

%feature("docstring")  Gyoto::Metric::ChernSimons::getRms "

Returns the marginally stable (ISCO) radius Should be implemented in
derived classes if useful If called on the base class, returns an
error ";

%feature("docstring")  Gyoto::Metric::ChernSimons::getRmb "

Returns the marginally bound radius Should be implemented in derived
classes if useful If called on the base class, returns an error ";

%feature("docstring")
Gyoto::Metric::ChernSimons::getSpecificAngularMomentum "

Returns the specific angular momentum l=-u_phi/u_t Should be
implemented in derived classes if useful If called on the base class,
returns an error ";

%feature("docstring")  Gyoto::Metric::ChernSimons::getPotential "

Returns potential W=-ln(|u_t|) for a cst specific angular momentum
l_cst Should be implemented in derived classes if useful If called on
the base class, returns an error ";

%feature("docstring")  Gyoto::Metric::ChernSimons::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3). ";

%feature("docstring")  Gyoto::Metric::ChernSimons::ScalarProd "

Scalar product.

Compute the scalarproduct of the two quadrivectors u1 and u2 in this
Metric, at point pos expressed in coordinate system sys.

Parameters:
-----------

pos:  4-position;

u1:  1st quadrivector;

u2:  2nd quadrivector;

u1*u2 ";

%feature("docstring")  Gyoto::Metric::ChernSimons::nullifyCoord "

Set tdot (coord[4]) such that coord is light-like and return other
possible tdot.

Set coord[4] so that the 4-velocity coord[4:7] is lightlike, i.e. of
norm 0. There may be up to two solutions. coord[4] is set to the
hightest. The lowest can be retrieved in tdot2. Everything is
expressed in geometrical units.

Parameters:
-----------

coord:  8-position, coord[4] will be set according to the other
elements;

tdot2:  will be set to the smallest solution ";

%feature("docstring")  Gyoto::Metric::ChernSimons::nullifyCoord "

Set tdot (coord[4]) such that coord is light-like. Everything is in
geometrical units.

Set coord[4] so that the 4-velocity coord[4:7] is lightlike, i.e. of
norm 0. There may be up to two solutions. coord[4] is set to the
hightest. The lowest can be retrieved using nullifyCoord(double
coord[8], double& tdot2) const. Everything is expressed in geometrical
units.

Parameters:
-----------

coord:  8-position, coord[4] will be set according to the other
elements; ";

%feature("docstring")  Gyoto::Metric::ChernSimons::zamoVelocity "

Yield ZAMO velocity at a given position.

Give the velocity of a zero angular momentul observer (whatever is
closest to \"at rest\"). The default implementation simply projects
(1, 0, 0, 0) othogonally along ephi and normalizes it, thus ensuring
that vel is orthogonal to ephi.

Parameters:
-----------

pos:  input: position,

vel:  output: velocity, ";

%feature("docstring")  Gyoto::Metric::ChernSimons::MakeCoord "

Inverse function of MakeMomentumAndCst.

Computes pr, ptheta, E and L from rdot, thetadot, phidot, tdot ";

%feature("docstring")  Gyoto::Metric::ChernSimons::MakeMomentum "

Transforms from Boyer-Lindquist coordinates
[t,r,th,phi,tdot,rdot,thdot,phidot] to [t,r,th,phi,pt,pr,pth,pphi]
where pt,pr... are generalized momenta. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::myrk4 "

Internal-use RK4 proxy. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::myrk4 "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::myrk4_adaptive "

Internal-use adaptive RK4 proxy. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::myrk4_adaptive "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::diff "

F function such as dx/dt=F(x,cst) ";

%feature("docstring")  Gyoto::Metric::ChernSimons::diff "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::diff "";

%feature("docstring")
Gyoto::Metric::ChernSimons::setParticleProperties "";

%feature("docstring")
Gyoto::Metric::ChernSimons::setParticleProperties "

Set Metric-specific constants of motion. Used e.g. in KerrBL. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::isStopCondition "

Check whether integration should stop.

The integrating loop will ask this the Metric through this method
whether or not it is happy to continue the integration. Typically, the
Metric should answer 0 when everything is fine, 1 when too close to
the event horizon, inside the BH...

Parameters:
-----------

coord:  8-coordinate vector to check. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::observerTetrad "

Computes the orthonormal local tetrad of the observer.

Parameters:
-----------

pos:  position,

fourvel:  observer 4-velocity (norm -1)

screen1:  first vector in the screen plane

screen2:  second vector in the screen plane

screen3:  vector normal to the screen ";

%feature("docstring")  Gyoto::Metric::ChernSimons::observerTetrad "

Computes the orthonormal local tetrad of the observer.

Parameters:
-----------

obskind:  input: kind of observer (eg:
\"ZAMO\",\"KeplerianObserver\"...)

pos:  input: position,

fourvel:  output: observer 4-velocity (norm -1)

screen1:  output: first vector in the screen plane

screen2:  output: second vector in the screen plane

screen3:  output: vector normal to the screen ";

%feature("docstring")  Gyoto::Metric::ChernSimons::coordKind "

Get coordinate kind. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::getRefCount "";

%feature("docstring")  Gyoto::Metric::ChernSimons::mass "

Set mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::ChernSimons::mass "

Set mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::ChernSimons::mass "

Get mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::ChernSimons::mass "

Get mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::ChernSimons::unitLength "

M * G / c^2, M is in kg, unitLength in meters.

Metrics implementations are free to express lengths and distances in
whatever unit they see fit (presumably most often geometrical units).
This function returns this unit in SI (meters). ";

%feature("docstring")  Gyoto::Metric::ChernSimons::unitLength "

unitLength expressed in specified unit ";

%feature("docstring")  Gyoto::Metric::ChernSimons::deltaMin "

Get delta_min_ ";

%feature("docstring")  Gyoto::Metric::ChernSimons::deltaMin "

Set delta_min_ ";

%feature("docstring")  Gyoto::Metric::ChernSimons::deltaMax "

Get delta_max_ ";

%feature("docstring")  Gyoto::Metric::ChernSimons::deltaMax "

Get delta max at a given position

Parameters:
-----------

pos:  4-position

[optional]:  delta_max_external external constraint on delta_max

the smallest value between delta_max_, delta_max_external, and
R*delta_max_over_r_ where R is pos[1] in spherical coordinates and
max(x1, x2, x3) in Cartesian coordinates. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::deltaMax "

Set delta_max_ ";

%feature("docstring")  Gyoto::Metric::ChernSimons::deltaMaxOverR "

Get delta_max_over_r_. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::deltaMaxOverR "

Set delta_max_over_r_. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::keplerian "

Get keplerian_. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::keplerian "

Set keplerian_. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::cartesianVelocity "

Compute xprime, yprime and zprime from 8-coordinates. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::SysPrimeToTdot "

Compute tdot as a function of dr/dt, dtheta/dt and dphi/dt. Everything
is in geometrical units.

Parameters:
-----------

coord:  4-position (geometrical units);

v:  3-velocity dx1/dx0, dx2/dx0, dx3/dx0;

tdot = dx0/dtau. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::normalizeFourVel "

Normalize fourvelvel to -1.

First computes threevel as xiprime=xidot/x0dot for i in {1, 2, 3},
then computes x0dot using SyPrimeToTdot, then computes again xidot as
xidot=xiprime*x0dot.

Parameters:
-----------

coord:  8-position, coord[4-7] will be set according to the other
elements; ";

%feature("docstring")  Gyoto::Metric::ChernSimons::normalizeFourVel "

Normalize fourvelvel to -1.

First computes threevel as xiprime=xidot/x0dot for i in {1, 2, 3},
then computes x0dot using SyPrimeToTdot, then computes again xidot as
xidot=xiprime*x0dot.

Parameters:
-----------

pos:  4-position;

fourvel:  4-velocity, will be renormalized. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::norm "

Scalar product.

Compute the norm of the quadrivector u1 in this Metric, at point pos
expressed in coordinate system sys.

Parameters:
-----------

pos:  4-position;

u1:  quadrivector;

||u1|| ";

%feature("docstring")  Gyoto::Metric::ChernSimons::multiplyFourVect "

multiply vector by scalar ";

%feature("docstring")  Gyoto::Metric::ChernSimons::addFourVect "

add second vector to first one ";

%feature("docstring")  Gyoto::Metric::ChernSimons::projectFourVect "

project u1 orthogonally to u2 at pos ";

%feature("docstring")  Gyoto::Metric::ChernSimons::dualOneForm "

Computes dual 1-form Compute the dual 1-form of 4-vector.

Parameters:
-----------

IN_ARRAY1_1:  4-position;

IN_ARRAY1_2:  quadrivector;

ARGOUT_ARRAY1:  output 1-form ";

%feature("docstring")  Gyoto::Metric::ChernSimons::GramSchmidt "

Apply Gram-Schmidt orthonormalization to a basis.

On input, u0 to u3 must be four non-zero norm, independent 4-vectors.
On output, they will form an orthonormal basis.

Parameters:
-----------

pos:  position,

u0:  basis vector

u1:  basis vector

u2:  basis vector

u3:  basis vector ";

%feature("docstring")  Gyoto::Metric::ChernSimons::jacobian "

Derivatives of the metric covariant coefficients.

The default implementation evaluates them numerically. The gmunu
matrix is assumed to be symmetrical but no other assumptions are made
at the moment. ";

%feature("docstring")
Gyoto::Metric::ChernSimons::gmunu_up_and_jacobian "

gmunu_up() and jacobian() in one go ";

%feature("docstring")  Gyoto::Metric::ChernSimons::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Metric::ChernSimons::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Metric::ChernSimons::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::setParameters "

Main loop for parsing Properties from XML description.

This function queries the FactoryMessenger for elements to parse, and
tries to matche each element to a Property to set it  accordingly. Any
class that tries to be buildable from XML must supply a subcontractor
(for base classes such as Metric, Astrobj, Spectrum  and Spectrometer,
it is done as a template that must be  specialized for each class).
This subcontractor typically looks somewhat like this: Although this
is discouraged, it is possible to override the following functions to
customize how XML entities are parsed:    - setParameters() if low-
level access to the      FactoryMessenger is required;    -
setParameter(std::string name, std::string content,
std::string unit)      to interpret an entity that does not match a
Property      (e.g. alternative name);    -
setParameter(Gyoto::Property const &p, std::string const &name,
std::string const &content, std::string const &unit)      to change
how a Property is interpreted. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Metric::ChernSimons::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::kind "

Get kind_. ";

%feature("docstring")  Gyoto::Metric::ChernSimons::hook "

Start listening.

Use from a Hook::Listener object method: where \"this\" is a Listener
and \"teller\" is a Teller.

Use unhook() later to stop listening to a given Teller.

Parameters:
-----------

listener:  pointer to the new listener ";

%feature("docstring")  Gyoto::Metric::ChernSimons::unhook "

Stop listening.

Use from a Hook::Listener object method:

where \"this\" is a Listener, \"teller\" is a Teller, and \"this\" has
called teller->hook(this) previously.

Parameters:
-----------

listener:  pointer to the listener ";


// File: class_gyoto_1_1_astrobj_1_1_complex.xml
%feature("docstring") Gyoto::Astrobj::Complex "

Complex astronomical object.

A Gyoto::Astrobj::Generic whic contain several Gyoto::Astrobj::Generic
instances. It is essentially a SmartPointer<Astrobj::Generic> array,
which some methods around. Indeed, the operator[](size_t i) method is
implemented to retrieve the i-th element.

In an XML description, the < Astrobj> section must be unique, its kind
is \"Complex\". Each sub-astrobj then appears as a <SubAstrobj>
subsection:

C++ includes: GyotoComplexAstrobj.h ";

%feature("docstring")  Gyoto::Astrobj::Complex::Complex "

Default constructor. ";

%feature("docstring")  Gyoto::Astrobj::Complex::Complex "

Copy constructor. ";

%feature("docstring")  Gyoto::Astrobj::Complex::clone "

\"Virtual\" copy constructor ";

%feature("docstring")  Gyoto::Astrobj::Complex::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")  Gyoto::Astrobj::Complex::rMax "

rMax loops over the elementary astrobjs rmax_ and returns the biggest
";

%feature("docstring")  Gyoto::Astrobj::Complex::~Complex "

Destructor.

Frees every SmartPointer<Astrobj::Generic> before freed the array
itself. ";

%feature("docstring")  Gyoto::Astrobj::Complex::append "

Add element at the end of the array.

If the Astrobj::Complex itself does not have a metric already
assigned, it takes it from the new element. Else, it sets the metric
in the new element to its own. This ensures that all elements use the
same metric (this heuristic is not entirely fool-proof, it's safer to
set the metric directly in the Astrobj::Complex). ";

%feature("docstring")  Gyoto::Astrobj::Complex::remove "

Remove i-th element from the array. ";

%feature("docstring")  Gyoto::Astrobj::Complex::getCardinal "

Get the number of elements in the array. ";

%feature("docstring")  Gyoto::Astrobj::Complex::metric "

Set metric in each element. ";

%feature("docstring")  Gyoto::Astrobj::Complex::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Astrobj::Complex::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")  Gyoto::Astrobj::Complex::Impact "

Call Impact() for each of the elements.

Astrobj::Complex::Impact( Gyoto::Photon* ph, size_t index,
Astrobj::Properties *data) calls the specific implementation of
Astrobj::Generic::Impact() for each of its elements twice: the first
time, data is set to NULL so that Astrobj::Complex::Impact() only
knows whether each object is hit by the Photon. If no object is hit,
return. If a single object is hit, call Impact() again only for this
object, passing data this time. If several objects are hit, the
Photon's trajectory is refined so that the step is at most step_max_
and the Impact() methods for each of the hit objects are called again
for each step, passing data. It is therefore important that the
transmission of the Photon is not touched by Impact() when data==NULL.
";

%feature("docstring")  Gyoto::Astrobj::Complex::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::Complex::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::Complex::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Astrobj::Complex::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::Complex::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::Complex::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::Complex::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::Complex::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::Complex::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")
Gyoto::Astrobj::Complex::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::Complex::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")  Gyoto::Astrobj::Complex::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::Complex::showshadow "";

%feature("docstring")  Gyoto::Astrobj::Complex::showshadow "";

%feature("docstring")  Gyoto::Astrobj::Complex::redshift "";

%feature("docstring")  Gyoto::Astrobj::Complex::redshift "";

%feature("docstring")  Gyoto::Astrobj::Complex::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")  Gyoto::Astrobj::Complex::processHitQuantities "

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")  Gyoto::Astrobj::Complex::processHitQuantities "";

%feature("docstring")  Gyoto::Astrobj::Complex::emission "

Specific intensity I

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem, in the emitter's frame. It should take self-absorption
along dsem into account.

Reminder : intensity = I [J m^-2 s^-1 ster^-1 Hz^-1];

invariant intensity = I/3, which has the same value in any frame;

emission coefficient = j [J m^-3 s^-1 ster^-1 Hz^-1] , defined by dI =
j*ds, where ds is the distance travelled by the photon inside the
object;

invariant emission coef = j/2, which has the same value in any frame.

The equation used for radiative transfer (without absorption) is:

d(I/3)/d = (j/2) [*]

where is the integration parameter along the null geodesic.

NB: Let us consider a particular observer, with being the frequency
measured by this observer, and ds being the proper distance (as
measured by the observer) that the photon travels as it moves from
to+d along its geodesic. Then it can be shown that:

d = ds/

This shows that Eq. [*] is homogeneous.

The default implementation returns 1. if optically thick and dsem if
optically thin. It allows for a quick implementation of your object
for visualization purposes.

Parameters:
-----------

nu_em:  Frequency at emission [Hz]

dsem:  length over which to integrate inside the object [geometrical
units]

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position ";

%feature("docstring")  Gyoto::Astrobj::Complex::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::Complex::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::Complex::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Complex::radiativeQ "

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::Complex::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::Complex::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")  Gyoto::Astrobj::Complex::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")  Gyoto::Astrobj::Complex::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Complex::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")  Gyoto::Astrobj::Complex::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Complex::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Complex::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Complex::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Complex::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Complex::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Complex::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Complex::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Complex::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::Complex::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::Complex::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::Complex::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::Complex::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::Complex::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")  Gyoto::Astrobj::Complex::computeB4vect_ipole "";

%feature("docstring")  Gyoto::Astrobj::Complex::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::Complex::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::Complex::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::Complex::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::Complex::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::Complex::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::Complex::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Complex::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Complex::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Complex::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Complex::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Complex::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Complex::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::Complex::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::Complex::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::Complex::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Astrobj::Complex::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Astrobj::Complex::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Astrobj::Complex::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::Complex::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::Complex::kind "

Get kind_. ";


// File: class_gyoto_1_1_metric_1_1_complex.xml
%feature("docstring") Gyoto::Metric::Complex "

Combine several metrics.

Adds linearly the contribution of several metrics. All suv-metrics
must use a common coordinate system.

C++ includes: GyotoComplexMetric.h ";

%feature("docstring")  Gyoto::Metric::Complex::Complex "

Default constructor. ";

%feature("docstring")  Gyoto::Metric::Complex::Complex "

Copy constructor. ";

%feature("docstring")  Gyoto::Metric::Complex::clone "

\"Virtual\" copy constructor ";

%feature("docstring")  Gyoto::Metric::Complex::~Complex "

Destructor.

Frees every SmartPointer<Metric::Generic> before freed the array
itself. ";

%feature("docstring")  Gyoto::Metric::Complex::append "

Add element at the end of the array. ";

%feature("docstring")  Gyoto::Metric::Complex::remove "

Remove i-th element from the array. ";

%feature("docstring")  Gyoto::Metric::Complex::getCardinal "

Get the number of elements in the array. ";

%feature("docstring")  Gyoto::Metric::Complex::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Metric::Complex::setParameters "

Main loop for parsing Properties from XML description.

This function queries the FactoryMessenger for elements to parse, and
tries to matche each element to a Property to set it  accordingly. Any
class that tries to be buildable from XML must supply a subcontractor
(for base classes such as Metric, Astrobj, Spectrum  and Spectrometer,
it is done as a template that must be  specialized for each class).
This subcontractor typically looks somewhat like this: Although this
is discouraged, it is possible to override the following functions to
customize how XML entities are parsed:    - setParameters() if low-
level access to the      FactoryMessenger is required;    -
setParameter(std::string name, std::string content,
std::string unit)      to interpret an entity that does not match a
Property      (e.g. alternative name);    -
setParameter(Gyoto::Property const &p, std::string const &name,
std::string const &content, std::string const &unit)      to change
how a Property is interpreted. ";

%feature("docstring")  Gyoto::Metric::Complex::gmunu "

Metric coefficients.

The default implementation calls double gmunu(const double * x, int
mu, int nu) const.

Parameters:
-----------

ARGOUT_ARRAY2:  (g) 4x4 array to store the coeefficients

IN_ARRAY1:  (x) 4-position at which to compute the coefficients;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::Complex::jacobian "

Derivatives of the metric covariant coefficients.

The default implementation evaluates them numerically. The gmunu
matrix is assumed to be symmetrical but no other assumptions are made
at the moment. ";

%feature("docstring")  Gyoto::Metric::Complex::isStopCondition "

Check whether integration should stop.

The integrating loop will ask this the Metric through this method
whether or not it is happy to continue the integration. Typically, the
Metric should answer 0 when everything is fine, 1 when too close to
the event horizon, inside the BH...

Parameters:
-----------

coord:  8-coordinate vector to check. ";

%feature("docstring")  Gyoto::Metric::Complex::gmunu "

Metric coefficients.

The default implementation calls Metric:: gmunu(double g[4][4], const
double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::Complex::gmunu "

Metric coefficients.

The default implementation calls double gmunu(const double * x, int
mu, int nu) const.

Parameters:
-----------

ARGOUT_ARRAY2:  (g) 4x4 array to store the coeefficients

IN_ARRAY1:  (x) 4-position at which to compute the coefficients;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::Complex::coordKind "

Get coordinate kind. ";

%feature("docstring")  Gyoto::Metric::Complex::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Metric::Complex::getRefCount "";

%feature("docstring")  Gyoto::Metric::Complex::mass "

Set mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::Complex::mass "

Set mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::Complex::mass "

Get mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::Complex::mass "

Get mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::Complex::unitLength "

M * G / c^2, M is in kg, unitLength in meters.

Metrics implementations are free to express lengths and distances in
whatever unit they see fit (presumably most often geometrical units).
This function returns this unit in SI (meters). ";

%feature("docstring")  Gyoto::Metric::Complex::unitLength "

unitLength expressed in specified unit ";

%feature("docstring")  Gyoto::Metric::Complex::getRmb "

Returns the marginally bound radius Should be implemented in derived
classes if useful If called on the base class, returns an error ";

%feature("docstring")  Gyoto::Metric::Complex::getRms "

Returns the marginally stable (ISCO) radius Should be implemented in
derived classes if useful If called on the base class, returns an
error ";

%feature("docstring")
Gyoto::Metric::Complex::getSpecificAngularMomentum "

Returns the specific angular momentum l=-u_phi/u_t Should be
implemented in derived classes if useful If called on the base class,
returns an error ";

%feature("docstring")  Gyoto::Metric::Complex::getPotential "

Returns potential W=-ln(|u_t|) for a cst specific angular momentum
l_cst Should be implemented in derived classes if useful If called on
the base class, returns an error ";

%feature("docstring")  Gyoto::Metric::Complex::deltaMin "

Get delta_min_ ";

%feature("docstring")  Gyoto::Metric::Complex::deltaMin "

Set delta_min_ ";

%feature("docstring")  Gyoto::Metric::Complex::deltaMax "

Get delta_max_ ";

%feature("docstring")  Gyoto::Metric::Complex::deltaMax "

Get delta max at a given position

Parameters:
-----------

pos:  4-position

[optional]:  delta_max_external external constraint on delta_max

the smallest value between delta_max_, delta_max_external, and
R*delta_max_over_r_ where R is pos[1] in spherical coordinates and
max(x1, x2, x3) in Cartesian coordinates. ";

%feature("docstring")  Gyoto::Metric::Complex::deltaMax "

Set delta_max_ ";

%feature("docstring")  Gyoto::Metric::Complex::deltaMaxOverR "

Get delta_max_over_r_. ";

%feature("docstring")  Gyoto::Metric::Complex::deltaMaxOverR "

Set delta_max_over_r_. ";

%feature("docstring")  Gyoto::Metric::Complex::keplerian "

Get keplerian_. ";

%feature("docstring")  Gyoto::Metric::Complex::keplerian "

Set keplerian_. ";

%feature("docstring")  Gyoto::Metric::Complex::cartesianVelocity "

Compute xprime, yprime and zprime from 8-coordinates. ";

%feature("docstring")  Gyoto::Metric::Complex::SysPrimeToTdot "

Compute tdot as a function of dr/dt, dtheta/dt and dphi/dt. Everything
is in geometrical units.

Parameters:
-----------

coord:  4-position (geometrical units);

v:  3-velocity dx1/dx0, dx2/dx0, dx3/dx0;

tdot = dx0/dtau. ";

%feature("docstring")  Gyoto::Metric::Complex::circularVelocity "

Yield circular velocity at a given position.

Give the velocity of a massive particle in circular orbit at the given
position projected onto the equatorial plane. Such a velocity may not
exist everywhere (or anywhere) for a given metric. This method is
intended to be used by Astrobj classes such as Torus or ThinDisk.

If keplerian_ is set to true, this method should return the Keplerian
velcity instead (derived classes should ensure this, see
KerrBL::circularVelocity() for instance).

The default implementation throws an error if keplerian_ is set to
false.

Parameters:
-----------

pos:  input: position,

vel:  output: velocity,

dir:  1 for corotating, -1 for counterrotating. ";

%feature("docstring")  Gyoto::Metric::Complex::zamoVelocity "

Yield ZAMO velocity at a given position.

Give the velocity of a zero angular momentul observer (whatever is
closest to \"at rest\"). The default implementation simply projects
(1, 0, 0, 0) othogonally along ephi and normalizes it, thus ensuring
that vel is orthogonal to ephi.

Parameters:
-----------

pos:  input: position,

vel:  output: velocity, ";

%feature("docstring")  Gyoto::Metric::Complex::nullifyCoord "

Set tdot (coord[4]) such that coord is light-like. Everything is in
geometrical units.

Set coord[4] so that the 4-velocity coord[4:7] is lightlike, i.e. of
norm 0. There may be up to two solutions. coord[4] is set to the
hightest. The lowest can be retrieved using nullifyCoord(double
coord[8], double& tdot2) const. Everything is expressed in geometrical
units.

Parameters:
-----------

coord:  8-position, coord[4] will be set according to the other
elements; ";

%feature("docstring")  Gyoto::Metric::Complex::nullifyCoord "

Set tdot (coord[4]) such that coord is light-like and return other
possible tdot.

Set coord[4] so that the 4-velocity coord[4:7] is lightlike, i.e. of
norm 0. There may be up to two solutions. coord[4] is set to the
hightest. The lowest can be retrieved in tdot2. Everything is
expressed in geometrical units.

Parameters:
-----------

coord:  8-position, coord[4] will be set according to the other
elements;

tdot2:  will be set to the smallest solution ";

%feature("docstring")  Gyoto::Metric::Complex::normalizeFourVel "

Normalize fourvelvel to -1.

First computes threevel as xiprime=xidot/x0dot for i in {1, 2, 3},
then computes x0dot using SyPrimeToTdot, then computes again xidot as
xidot=xiprime*x0dot.

Parameters:
-----------

coord:  8-position, coord[4-7] will be set according to the other
elements; ";

%feature("docstring")  Gyoto::Metric::Complex::normalizeFourVel "

Normalize fourvelvel to -1.

First computes threevel as xiprime=xidot/x0dot for i in {1, 2, 3},
then computes x0dot using SyPrimeToTdot, then computes again xidot as
xidot=xiprime*x0dot.

Parameters:
-----------

pos:  4-position;

fourvel:  4-velocity, will be renormalized. ";

%feature("docstring")  Gyoto::Metric::Complex::ScalarProd "

Scalar product.

Compute the scalarproduct of the two quadrivectors u1 and u2 in this
Metric, at point pos expressed in coordinate system sys.

Parameters:
-----------

pos:  4-position;

u1:  1st quadrivector;

u2:  2nd quadrivector;

u1*u2 ";

%feature("docstring")  Gyoto::Metric::Complex::norm "

Scalar product.

Compute the norm of the quadrivector u1 in this Metric, at point pos
expressed in coordinate system sys.

Parameters:
-----------

pos:  4-position;

u1:  quadrivector;

||u1|| ";

%feature("docstring")  Gyoto::Metric::Complex::multiplyFourVect "

multiply vector by scalar ";

%feature("docstring")  Gyoto::Metric::Complex::addFourVect "

add second vector to first one ";

%feature("docstring")  Gyoto::Metric::Complex::projectFourVect "

project u1 orthogonally to u2 at pos ";

%feature("docstring")  Gyoto::Metric::Complex::dualOneForm "

Computes dual 1-form Compute the dual 1-form of 4-vector.

Parameters:
-----------

IN_ARRAY1_1:  4-position;

IN_ARRAY1_2:  quadrivector;

ARGOUT_ARRAY1:  output 1-form ";

%feature("docstring")  Gyoto::Metric::Complex::observerTetrad "

Computes the orthonormal local tetrad of the observer.

Parameters:
-----------

obskind:  input: kind of observer (eg:
\"ZAMO\",\"KeplerianObserver\"...)

pos:  input: position,

fourvel:  output: observer 4-velocity (norm -1)

screen1:  output: first vector in the screen plane

screen2:  output: second vector in the screen plane

screen3:  output: vector normal to the screen ";

%feature("docstring")  Gyoto::Metric::Complex::observerTetrad "

Computes the orthonormal local tetrad of the observer.

Parameters:
-----------

pos:  position,

fourvel:  observer 4-velocity (norm -1)

screen1:  first vector in the screen plane

screen2:  second vector in the screen plane

screen3:  vector normal to the screen ";

%feature("docstring")  Gyoto::Metric::Complex::GramSchmidt "

Apply Gram-Schmidt orthonormalization to a basis.

On input, u0 to u3 must be four non-zero norm, independent 4-vectors.
On output, they will form an orthonormal basis.

Parameters:
-----------

pos:  position,

u0:  basis vector

u1:  basis vector

u2:  basis vector

u3:  basis vector ";

%feature("docstring")  Gyoto::Metric::Complex::gmunu "

Metric coefficients.

The default implementation calls Metric:: gmunu(double g[4][4], const
double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::Complex::gmunu_up "

Metric contravariant coefficients.

The default implementation calls Metric:: gmunu_up(double g[4][4],
const double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::Complex::gmunu_up "

Metric contravariant coefficients.

The default implementation inverts the covariant coefficients matrix.
";

%feature("docstring")  Gyoto::Metric::Complex::gmunu_up_and_jacobian "

gmunu_up() and jacobian() in one go ";

%feature("docstring")  Gyoto::Metric::Complex::computeNBeta "

Computes lapse scalar and shift vector at coord. ";

%feature("docstring")  Gyoto::Metric::Complex::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3). ";

%feature("docstring")  Gyoto::Metric::Complex::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3).

1 on error, 0 otherwise ";

%feature("docstring")  Gyoto::Metric::Complex::myrk4 "

RK4 integrator. ";

%feature("docstring")  Gyoto::Metric::Complex::myrk4 "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::Complex::myrk4_adaptive "

RK4 integrator with adaptive step. ";

%feature("docstring")  Gyoto::Metric::Complex::myrk4_adaptive "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::Complex::diff "

F function such as dx/dt=F(x,cst) ";

%feature("docstring")  Gyoto::Metric::Complex::diff "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::Complex::diff "";

%feature("docstring")  Gyoto::Metric::Complex::diff31 "

F function such as dx/dt=F(x,cst) for 3+1 case. ";

%feature("docstring")  Gyoto::Metric::Complex::setParticleProperties "

Set Metric-specific constants of motion. Used e.g. in KerrBL. ";

%feature("docstring")  Gyoto::Metric::Complex::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Metric::Complex::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Metric::Complex::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Metric::Complex::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Metric::Complex::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Metric::Complex::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Metric::Complex::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Metric::Complex::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Metric::Complex::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Metric::Complex::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Metric::Complex::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Metric::Complex::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Metric::Complex::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Metric::Complex::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Metric::Complex::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Metric::Complex::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Metric::Complex::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Metric::Complex::kind "

Get kind_. ";

%feature("docstring")  Gyoto::Metric::Complex::hook "

Start listening.

Use from a Hook::Listener object method: where \"this\" is a Listener
and \"teller\" is a Teller.

Use unhook() later to stop listening to a given Teller.

Parameters:
-----------

listener:  pointer to the new listener ";

%feature("docstring")  Gyoto::Metric::Complex::unhook "

Stop listening.

Use from a Hook::Listener object method:

where \"this\" is a Listener, \"teller\" is a Teller, and \"this\" has
called teller->hook(this) previously.

Parameters:
-----------

listener:  pointer to the listener ";


// File: class_gyoto_1_1_spectrometer_1_1_complex.xml
%feature("docstring") Gyoto::Spectrometer::Complex "

Complex spectrometer object.

A Gyoto::Spectrometer::Generic whic contain several
Gyoto::Spectrometer::Generic instances. It is essentially a
SmartPointer<Spectrometer::Generic> array, which some methods arround.
Indeed, the operator[](size_t i) method is implemented to retrieve the
i-th element.

In an XML description, the < Spectrometer> section is unique, its kind
is \"Complex\". Each sub-spectrometer then appears as a
<SubSpectrometer> subsection. For instance, to compute 10 channels ovr
the K infrared band plus 10 channels in the high energy domain:

C++ includes: GyotoComplexSpectrometer.h ";

%feature("docstring")  Gyoto::Spectrometer::Complex::Complex "

Default constructor. ";

%feature("docstring")  Gyoto::Spectrometer::Complex::Complex "

Copy constructor. ";

%feature("docstring")  Gyoto::Spectrometer::Complex::clone "

Clone an instance.

Use this to get a deep copy of an instance;

Most implementations will use the copy constructor: ";

%feature("docstring")  Gyoto::Spectrometer::Complex::~Complex "

Destructor.

Frees every SmartPointer<Spectrometer::Generic> before freed the array
itself. ";

%feature("docstring")  Gyoto::Spectrometer::Complex::append "

Add element at the end of the array.

If the Spectrometer::Complex itself does not have a metric already
assigned, it takes it from the new element. Else, it sets the metric
in the new element to its own. This ensures that all elements use the
same metric (this heuristic is not entirely fool-proof, it's safer to
set the metric directly in the Spectrometer::Complex). ";

%feature("docstring")  Gyoto::Spectrometer::Complex::remove "

Remove i-th element from the array. ";

%feature("docstring")  Gyoto::Spectrometer::Complex::getCardinal "

Get the number of elements in the array. ";

%feature("docstring")  Gyoto::Spectrometer::Complex::tell "

This is how a Teller tells.

A teller will basically call listener->tell(this).

Parameters:
-----------

msg:  Teller* the Teller who is telling... Useful if the Listener
listens to several Tellers. ";

%feature("docstring")  Gyoto::Spectrometer::Complex::fillElement "

Fill in the XML entity.

Loops on elements_[i]-> fillElement(); ";

%feature("docstring")  Gyoto::Spectrometer::Complex::setParameters "

Main loop in the (templated) subcontractor.

In the case of Spectrometer::Complex, the setParameter() API is not
sufficient: setParameters() needs access to the FactoryMessenger to
instantiate children for the SubSpectrometers. ";

%feature("docstring")  Gyoto::Spectrometer::Complex::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Spectrometer::Complex::kindid "

Get kindid_.

You can check whether the Spectrometer sp is of a given kind MyKind
with something like:

See Uniform::WaveKind, Uniform::WaveLogKind, Uniform::FreqKind,
Uniform::FreqLogKind and Complex::Kind. ";

%feature("docstring")  Gyoto::Spectrometer::Complex::kindid "

Set Generic::kindid_.

This should rarely be used as the Generic::kindid_ attribute usually
is set in the constructor and doesn't change after that.

Always set to the address of a static variable, not to a temporary.
Usually your class should have a static member for that purpose: ";

%feature("docstring")  Gyoto::Spectrometer::Complex::nSamples "

Get Generic::nsamples_. ";

%feature("docstring")  Gyoto::Spectrometer::Complex::getNBoundaries "

Get Generic::nboundaries_. ";

%feature("docstring")  Gyoto::Spectrometer::Complex::getMidpoints "

Get Generic::midpoints_. ";

%feature("docstring")  Gyoto::Spectrometer::Complex::getMidpoints "

Copy Generic::midpoints_, converting to unit.

Parameters:
-----------

data:  an array of Generic::nsamples_ doubles to fill with result

unit:  a string ";

%feature("docstring")
Gyoto::Spectrometer::Complex::getChannelBoundaries "

Copy Generic::boundaries_, converting to unit.

Parameters:
-----------

data:  an array of Generic::nboundaries_ doubles to fill with result

unit:  a string ";

%feature("docstring")
Gyoto::Spectrometer::Complex::getChannelBoundaries "

Get Generic::boundaries_. ";

%feature("docstring")  Gyoto::Spectrometer::Complex::getChannelIndices
"

Get Generic::chanind_. ";

%feature("docstring")  Gyoto::Spectrometer::Complex::getWidths "

Get Generic::widths_. ";

%feature("docstring")  Gyoto::Spectrometer::Complex::getWidths "

Copy Generic::widths_, converting to unit.

Think carefully before using: widths are often used to convert
spectral flux density to flux. If flux density is per Herz, you don't
need to convert widths.

Parameters:
-----------

data:  an array of Generic::nboundaries_ doubles to fill with result

unit:  a string ";

%feature("docstring")  Gyoto::Spectrometer::Complex::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Spectrometer::Complex::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Spectrometer::Complex::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Spectrometer::Complex::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Spectrometer::Complex::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Spectrometer::Complex::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Spectrometer::Complex::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Spectrometer::Complex::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Spectrometer::Complex::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Spectrometer::Complex::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Spectrometer::Complex::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Spectrometer::Complex::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Spectrometer::Complex::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Spectrometer::Complex::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Spectrometer::Complex::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Spectrometer::Complex::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Spectrometer::Complex::describeProperty
"

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Spectrometer::Complex::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Spectrometer::Complex::kind "

Get kind_. ";

%feature("docstring")  Gyoto::Spectrometer::Complex::hook "

Start listening.

Use from a Hook::Listener object method: where \"this\" is a Listener
and \"teller\" is a Teller.

Use unhook() later to stop listening to a given Teller.

Parameters:
-----------

listener:  pointer to the new listener ";

%feature("docstring")  Gyoto::Spectrometer::Complex::unhook "

Stop listening.

Use from a Hook::Listener object method:

where \"this\" is a Listener, \"teller\" is a Teller, and \"this\" has
called teller->hook(this) previously.

Parameters:
-----------

listener:  pointer to the listener ";


// File: class_gyoto_1_1_screen_1_1_coord1d_set.xml
%feature("docstring") Coord1dSet "

Set of 1-d coordinates: indices or angles.

Acts like a container (array-like) of either size_t (pixel coordinate)
or double (angle) values. This container can be iterated-through using
the operator++(), derefenced using the operator*() (if containing
pixel coordinates) or angle() (in containing angles).

C++ includes: GyotoScreen.h ";

%feature("docstring")  Coord1dSet::Coord1dSet "

Set kind during initialization. ";

%feature("docstring")  Coord1dSet::~Coord1dSet "

Virtual destructor. ";

%feature("docstring")  Coord1dSet::begin "

Reset specifier to point to the first value. ";

%feature("docstring")  Coord1dSet::valid "

True if pointing to something, false if end has been reached. ";

%feature("docstring")  Coord1dSet::size "

Number of values in this container. ";

%feature("docstring")  Coord1dSet::angle "

Get double value currently pointed to. ";

%feature("docstring")  Coord1dSet::index "

Get index of value currently pointed to.

Starts at 0 and is implemented each time operator++ is called.
Depending on the implementation, this may be a real index or computed
on demand. ";


// File: class_gyoto_1_1_screen_1_1_coord2d_set.xml
%feature("docstring") Coord2dSet "

Class to specify a set of points on the Screen.

Container (array-like) holding several 2D points. Can be a 2D grid of
pixel coordinates or a vector of floating-point (alpha, delta) pairs,
for instance.

C++ includes: GyotoScreen.h ";

%feature("docstring")  Coord2dSet::Coord2dSet "

Set kind at initialisation. ";

%feature("docstring")  Coord2dSet::~Coord2dSet "

Virtual destructor. ";

%feature("docstring")  Coord2dSet::angles "

Get angle coordinates. ";

%feature("docstring")  Coord2dSet::begin "

Reset pointer. ";

%feature("docstring")  Coord2dSet::valid "

Whether the end has not been passed. ";

%feature("docstring")  Coord2dSet::size "

Number of positions contained. ";


// File: class_gyoto_1_1_astrobj_1_1_deformed_torus.xml
%feature("docstring") Gyoto::Astrobj::DeformedTorus "";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::DeformedTorus "";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::DeformedTorus "";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::~DeformedTorus "";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::clone "

Cloner.

This method must be implemented by the various Astrobj::Generic
subclasses in order to support cloning:

Cloning is necessary for multi-threading, recommended for interaction
with the Yorick plug-in etc.

Implementing it is very straightforward, as long as the copy
constructor Generic(const Generic& ) has been implemented: ";

%feature("docstring")
Gyoto::Astrobj::DeformedTorus::GYOTO_OBJECT_ACCESSORS "";

%feature("docstring")
Gyoto::Astrobj::DeformedTorus::GYOTO_OBJECT_ACCESSORS "";

%feature("docstring")
Gyoto::Astrobj::DeformedTorus::GYOTO_OBJECT_ACCESSORS "";

%feature("docstring")
Gyoto::Astrobj::DeformedTorus::GYOTO_OBJECT_ACCESSORS "";

%feature("docstring")
Gyoto::Astrobj::DeformedTorus::GYOTO_OBJECT_ACCESSORS "";

%feature("docstring")
Gyoto::Astrobj::DeformedTorus::GYOTO_OBJECT_ACCESSORS "";

%feature("docstring")
Gyoto::Astrobj::DeformedTorus::GYOTO_OBJECT_ACCESSORS_STRING "";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::metric "

Set the Metric #gg_. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::getVelocity "

Fluid velocity field.

Fill vel with the 4-vector velocity of the fluid at 4-position pos.

Parameters:
-----------

pos:  4-position at which to compute velocity;

vel:  4-velocity at pos. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::emission "";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::metric "

Get the Metric #gg_. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::metric "

Set the Metric #gg_. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::safetyValue "

Set Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::safetyValue "

Get Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::deltaInObj "

Get Generic::delta_inobj_.

Get the constant integration step inside the astrobj

delta_inobj_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::deltaInObj "

Set Generic::delta_inobj_. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::giveDelta "

Maximum inside object.

Gives the requested integration stept (in coordinate time t) between
two neighbooring points along a portion of geodesic inside an astrobj;
the current implementation only considers a constant delta, equal to
Standard::deltaInobj()

Parameters:
-----------

coord:  input coordinate at whicht is given ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")
Gyoto::Astrobj::DeformedTorus::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::showshadow "";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::showshadow "";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::redshift "";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::redshift "";

%feature("docstring")
Gyoto::Astrobj::DeformedTorus::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")
Gyoto::Astrobj::DeformedTorus::processHitQuantities "

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")
Gyoto::Astrobj::DeformedTorus::processHitQuantities "";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::emission "

Specific intensity I

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem, in the emitter's frame. It should take self-absorption
along dsem into account.

Reminder : intensity = I [J m^-2 s^-1 ster^-1 Hz^-1];

invariant intensity = I/3, which has the same value in any frame;

emission coefficient = j [J m^-3 s^-1 ster^-1 Hz^-1] , defined by dI =
j*ds, where ds is the distance travelled by the photon inside the
object;

invariant emission coef = j/2, which has the same value in any frame.

The equation used for radiative transfer (without absorption) is:

d(I/3)/d = (j/2) [*]

where is the integration parameter along the null geodesic.

NB: Let us consider a particular observer, with being the frequency
measured by this observer, and ds being the proper distance (as
measured by the observer) that the photon travels as it moves from
to+d along its geodesic. Then it can be shown that:

d = ds/

This shows that Eq. [*] is homogeneous.

The default implementation returns 1. if optically thick and dsem if
optically thin. It allows for a quick implementation of your object
for visualization purposes.

Parameters:
-----------

nu_em:  Frequency at emission [Hz]

dsem:  length over which to integrate inside the object [geometrical
units]

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::radiativeQ "

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")
Gyoto::Astrobj::DeformedTorus::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")
Gyoto::Astrobj::DeformedTorus::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::DeformedTorus::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")
Gyoto::Astrobj::DeformedTorus::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")
Gyoto::Astrobj::DeformedTorus::computeB4vect_ipole "";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::describeProperty
"

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::DeformedTorus::kind "

Get kind_. ";


// File: class_gyoto_1_1_astrobj_1_1_directional_disk.xml
%feature("docstring") Gyoto::Astrobj::DirectionalDisk "

Geometrically thin disk read from FITS file.

This class describes a disk contained in the z=0 (equatorial) plane.
The flux emitted at radius r, making an angle i with respect to the
local normal, at frequency nu is given in a FITS file.

C++ includes: GyotoDirectionalDisk.h ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::getProperties
"

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::metric "

Set the Metric gg_. ";

%feature("docstring")
Gyoto::Astrobj::DirectionalDisk::DirectionalDisk "

Standard constructor. ";

%feature("docstring")
Gyoto::Astrobj::DirectionalDisk::DirectionalDisk "

Copy constructor. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::clone "

Cloner. ";

%feature("docstring")
Gyoto::Astrobj::DirectionalDisk::~DirectionalDisk "

Destructor. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::file "";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::file "";

%feature("docstring")
Gyoto::Astrobj::DirectionalDisk::averageOverAngle "";

%feature("docstring")
Gyoto::Astrobj::DirectionalDisk::averageOverAngle "";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::lampaltitude "";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::lampaltitude "";

%feature("docstring")
Gyoto::Astrobj::DirectionalDisk::lampcutoffsinev "";

%feature("docstring")
Gyoto::Astrobj::DirectionalDisk::lampcutoffsinev "";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::setEmission "

Set DirectionalDisk::emission_.

The pointer is copied directly, not the array content.

This is a low-level function. Beware that: previously allocated array
will not be freed automatically;

array attached when the destructor is called will be freed. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::radius "";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::copyIntensity
"

DirectionalDisk::emission_ is freed if not NULL, reallocated, and
pattern is copied into emission_.

Finally, DirectionalDisk::nnu_, DirectionalDisk::ni_, and
DirectionalDisk::nr_ are set according to naxes.

Parameters:
-----------

pattern:  Array to copy as emission_. May be NULL in which case
emission_ is simply deallocated and set to NULL.

naxes:  { nnu_, ni_, nr_ }. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::getIntensity "

Get DirectionalDisk::emission_. ";

%feature("docstring")
Gyoto::Astrobj::DirectionalDisk::getIntensityNaxes "

Get DirectionalDisk::nnu_, DirectionalDisk::ni_, and
DirectionalDisk::nr_. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::copyGridRadius
"";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::getGridRadius
"

Get DirectionalDisk::radius_. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::copyGridCosi "";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::getGridCosi "

Get DirectionalDisk::cosi_. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::copyGridFreq "";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::getGridFreq "

Get DirectionalDisk::freq_. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::emission "

Specific intensity I

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem, in the emitter's frame. It should take self-absorption
along dsem into account.

Reminder : intensity = I [J m^-2 s^-1 ster^-1 Hz^-1];

invariant intensity = I/3, which has the same value in any frame;

emission coefficient = j [J m^-3 s^-1 ster^-1 Hz^-1] , defined by dI =
j*ds, where ds is the distance travelled by the photon inside the
object;

invariant emission coef = j/2, which has the same value in any frame.

The equation used for radiative transfer (without absorption) is:

d(I/3)/d = (j/2) [*]

where is the integration parameter along the null geodesic.

NB: Let us consider a particular observer, with being the frequency
measured by this observer, and ds being the proper distance (as
measured by the observer) that the photon travels as it moves from
to+d along its geodesic. Then it can be shown that:

d = ds/

This shows that Eq. [*] is homogeneous.

The default implementation returns 1. if optically thick and dsem if
optically thin. It allows for a quick implementation of your object
for visualization purposes.

Parameters:
-----------

nu_em:  Frequency at emission [Hz]

dsem:  length over which to integrate inside the object [geometrical
units]

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::innerRadius "

Get rin_. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::innerRadius "

Get rin_. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::innerRadius "

Set rin_. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::innerRadius "

Set rin_. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::outerRadius "

Get rout_. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::outerRadius "

Get rout_. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::outerRadius "

Set rout_. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::outerRadius "

Set rout_. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::thickness "

Get thickness_. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::thickness "

Get thickness_. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::thickness "

Set thickness_. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::thickness "

Set thickness_. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::dir "

Get dir_. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::dir "

Set dir_. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::corotating "";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::corotating "

Get dir_==1. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::velocityKind "

Set dir_=t?1:-1.

Get VelocityKind ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::velocityKind "

Set VelocityKind. ";

%feature("docstring")
Gyoto::Astrobj::DirectionalDisk::projectedRadius "

Projected radius of position coord on the equatorial plane. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::sphericalPhi "

Longitude. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::getVelocity "

Get fluid 4-velocity at point.

Fill vel with the 4-vector velocity of the fluid at 4-position pos.
getVelocity() should work at some distance from the equatorial plane.
The default implementation calls Metric::Generic::circularVelocity().

Parameters:
-----------

pos:  4-position at which to compute velocity;

vel:  4-velocity at pos. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")
Gyoto::Astrobj::DirectionalDisk::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::opticallyThin
"

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::opticallyThin
"

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::showshadow "";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::showshadow "";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::redshift "";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::redshift "";

%feature("docstring")
Gyoto::Astrobj::DirectionalDisk::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::setParameters
"

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")
Gyoto::Astrobj::DirectionalDisk::processHitQuantities "

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")
Gyoto::Astrobj::DirectionalDisk::processHitQuantities "";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::radiativeQ "

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")
Gyoto::Astrobj::DirectionalDisk::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")
Gyoto::Astrobj::DirectionalDisk::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::DirectionalDisk::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")
Gyoto::Astrobj::DirectionalDisk::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::getSinCos2Chi
"

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::computeB4vect
"

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")
Gyoto::Astrobj::DirectionalDisk::computeB4vect_ipole "";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")
Gyoto::Astrobj::DirectionalDisk::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::DirectionalDisk::kind "

Get kind_. ";


// File: class_gyoto_1_1_astrobj_1_1_disk3_d.xml
%feature("docstring") Gyoto::Astrobj::Disk3D "

Geometrically thick disk read from FITS file.

This class is the base class for thick disks. The emitter's velocity
is given in a FITS file, together with emission related quantity
(typically temperature). This class mainly implements the Impact()
function. Emission() function is here left to its default, and should
be implemented according to specific needs in heir classes. Here the
disk is supposed not to evolve in time. The dynamical treatment is
provided in heir classes.

The 3D disk is assumed to be described by a regular (non adaptive)
grid of cylindrical geometry. The disk is a slab from rin_ to rout_
and zmin_ (typically = -zmax_) to zmax_.

C++ includes: GyotoDisk3D.h ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::Disk3D "

Standard constructor. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::Disk3D "

Copy constructor. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::clone "

Cloner. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::~Disk3D "

Destructor. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::file "";

%feature("docstring")  Gyoto::Astrobj::Disk3D::file "";

%feature("docstring")  Gyoto::Astrobj::Disk3D::zsym "";

%feature("docstring")  Gyoto::Astrobj::Disk3D::zsym "";

%feature("docstring")  Gyoto::Astrobj::Disk3D::tPattern "";

%feature("docstring")  Gyoto::Astrobj::Disk3D::tPattern "";

%feature("docstring")  Gyoto::Astrobj::Disk3D::omegaPattern "";

%feature("docstring")  Gyoto::Astrobj::Disk3D::omegaPattern "";

%feature("docstring")  Gyoto::Astrobj::Disk3D::setEmissquant "

Set Disk3D::emissquant_.

The pointer is copied directly, not the array content.

This is a low-level function. Beware that: previously allocated array
will not be freed automatically;

array attached when the destructor is called will be freed. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::opacity "";

%feature("docstring")  Gyoto::Astrobj::Disk3D::setVelocity "

Set Disk3D::velocity__.

The pointer is copied directly, not the array content.

This is a low-level function. Beware that: previously allocated array
will not be freed automatically;

array attached when the destructor is called will be freed. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::copyEmissquant "

Set Disk3D::emissquant_.

Disk3D::emissquant_ is freed if not NULL, reallocated, and pattern is
copied into emission_.

If Disk3D::velocity_ or has been set previously with mismatching
sizes, it is deallocated too.

Finally, Disk3D::nnu_, Disk3D::nphi_, Disk3D::nz_ and Disk3D::nr_ are
set according to naxes.

Parameters:
-----------

pattern:  Array to copy as emission_. May be NULL in which case
emission_ is simply deallocated and set to NULL.

naxes:  { nnu_, nphi_, nz_, nr_ }. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::getEmissquant "

Get Disk3D::emissquant_. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::getEmissquantNaxes "

Get { Disk3D::nnu_, Disk3D::nphi_, Disk3D::nz_, Disk3D::nr_ }. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::copyOpacity "";

%feature("docstring")  Gyoto::Astrobj::Disk3D::opacity "

Get Disk3D::opacity_. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::copyVelocity "

Set Disk3D::velocity_.

Disk3D::velocity_ is first freed if not NULL and set to NULL.

If pattern is not NULL, Disk3D::emissquant_ must have been set
previously with matching dimensions. Disk3D::velocity_ is then
reallocated, and pattern is copied into velocity_.

Parameters:
-----------

pattern:  Array to copy as velocity_. May be NULL in which case
velocity_ is simply deallocated and set to NULL.

naxes:  { nphi_, nz_, nr_ }. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::getVelocity "

Get Disk3D::velocity_. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::repeatPhi "

Set Disk3D::repeat_phi_. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::repeatPhi "

Get Disk3D::repeat_phi_. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::nu0 "

Set Disk3D::nu0_. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::nu0 "

Get Disk3D::nu0_. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::dnu "

Set Disk3D::dnu_. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::dnu "

Get Disk3D::dnu_. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::rin "

Set Disk3D::rin_. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::rin "

Get Disk3D::rin_. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::rout "

Set Disk3D::rout_. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::rout "

Get Disk3D::rout_. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::zmin "

Set Disk3D::zmin_. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::zmin "

Get Disk3D::zmin_. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::zmax "

Set Disk3D::zmax_. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::zmax "

Get Disk3D::zmax_. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::phimin "

Set Disk3D::phimin_. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::phimin "

Get Disk3D::phimin_. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::phimax "

Set Disk3D::phimax_. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::phimax "

Get Disk3D::phimax_. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::getVelocity "

Get fluid 4-velocity at point.

Fill vel with the 4-vector velocity of the fluid at 4-position pos.

Parameters:
-----------

pos:  4-position at which to compute velocity;

vel:  4-velocity at pos. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")
Gyoto::Astrobj::Disk3D::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::Disk3D::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::showshadow "";

%feature("docstring")  Gyoto::Astrobj::Disk3D::showshadow "";

%feature("docstring")  Gyoto::Astrobj::Disk3D::redshift "";

%feature("docstring")  Gyoto::Astrobj::Disk3D::redshift "";

%feature("docstring")  Gyoto::Astrobj::Disk3D::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::processHitQuantities "

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::processHitQuantities "";

%feature("docstring")  Gyoto::Astrobj::Disk3D::emission "

Specific intensity I

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem, in the emitter's frame. It should take self-absorption
along dsem into account.

Reminder : intensity = I [J m^-2 s^-1 ster^-1 Hz^-1];

invariant intensity = I/3, which has the same value in any frame;

emission coefficient = j [J m^-3 s^-1 ster^-1 Hz^-1] , defined by dI =
j*ds, where ds is the distance travelled by the photon inside the
object;

invariant emission coef = j/2, which has the same value in any frame.

The equation used for radiative transfer (without absorption) is:

d(I/3)/d = (j/2) [*]

where is the integration parameter along the null geodesic.

NB: Let us consider a particular observer, with being the frequency
measured by this observer, and ds being the proper distance (as
measured by the observer) that the photon travels as it moves from
to+d along its geodesic. Then it can be shown that:

d = ds/

This shows that Eq. [*] is homogeneous.

The default implementation returns 1. if optically thick and dsem if
optically thin. It allows for a quick implementation of your object
for visualization purposes.

Parameters:
-----------

nu_em:  Frequency at emission [Hz]

dsem:  length over which to integrate inside the object [geometrical
units]

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::radiativeQ "

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::Disk3D::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")  Gyoto::Astrobj::Disk3D::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Disk3D::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Disk3D::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Disk3D::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::Disk3D::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::Disk3D::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::computeB4vect_ipole "";

%feature("docstring")  Gyoto::Astrobj::Disk3D::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::Disk3D::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::Disk3D::kind "

Get kind_. ";


// File: class_gyoto_1_1_functor_1_1_double__const_double_array.xml
%feature("docstring") Gyoto::Functor::Double_constDoubleArray "

A functor like double (func) (double const data[])

C++ includes: GyotoFunctors.h ";

%feature("docstring")
Gyoto::Functor::Double_constDoubleArray::~Double_constDoubleArray "";


// File: class_gyoto_1_1_functor_1_1_double___double__const.xml
%feature("docstring") Gyoto::Functor::Double_Double_const "

A functor like double (func) (double) const.

C++ includes: GyotoFunctors.h ";

%feature("docstring")
Gyoto::Functor::Double_Double_const::~Double_Double_const "";

%feature("docstring")  Gyoto::Functor::Double_Double_const::ridders "

Ridder's root-finding method applied on operator()()

Parameters:
-----------

from:  to:  boundaries for root-searching

the root ";

%feature("docstring")  Gyoto::Functor::Double_Double_const::secant "

Secant root-finding method applied on operator()()

Sets status to -0 in case of convergence -1 if two distinct inputs
evaluated to the same output -2 if maximum number of iterations (20)
reached

Parameters:
-----------

from:  to:  boundaries for root-finding

the root ";


// File: class_gyoto_1_1_astrobj_1_1_dynamical_disk.xml
%feature("docstring") Gyoto::Astrobj::DynamicalDisk "

Geometrically thin disk read from a set of FITS files.

This class describes a PatternDiskBB that evolves dynamically. It is
described by a set of FITS files.

C++ includes: GyotoDynamicalDisk.h ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::DynamicalDisk "

Standard constructor. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::DynamicalDisk "

Copy constructor. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::clone "

Cloner. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::~DynamicalDisk "

Destructor. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::file "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::file "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::tinit "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::tinit "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::dt "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::dt "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::emission "

Specific intensity I

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem, in the emitter's frame. It should take self-absorption
along dsem into account.

Reminder : intensity = I [J m^-2 s^-1 ster^-1 Hz^-1];

invariant intensity = I/3, which has the same value in any frame;

emission coefficient = j [J m^-3 s^-1 ster^-1 Hz^-1] , defined by dI =
j*ds, where ds is the distance travelled by the photon inside the
object;

invariant emission coef = j/2, which has the same value in any frame.

The equation used for radiative transfer (without absorption) is:

d(I/3)/d = (j/2) [*]

where is the integration parameter along the null geodesic.

NB: Let us consider a particular observer, with being the frequency
measured by this observer, and ds being the proper distance (as
measured by the observer) that the photon travels as it moves from
to+d along its geodesic. Then it can be shown that:

d = ds/

This shows that Eq. [*] is homogeneous.

The default implementation returns 1. if optically thick and dsem if
optically thin. It allows for a quick implementation of your object
for visualization purposes.

Parameters:
-----------

nu_em:  Frequency at emission [Hz]

dsem:  length over which to integrate inside the object [geometrical
units]

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::getVelocity "

Get fluid 4-velocity at point.

Fill vel with the 4-vector velocity of the fluid at 4-position pos.
getVelocity() should work at some distance from the equatorial plane.
The default implementation calls Metric::Generic::circularVelocity().

Parameters:
-----------

pos:  4-position at which to compute velocity;

vel:  4-velocity at pos. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::getVelocity "

Get PatternDisk::velocity_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::emission "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::spectralEmission
"";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::spectralEmission
"";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::innerRadius "

Set rin_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::innerRadius "

Get rin_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::innerRadius "

Get rin_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::innerRadius "

Set rin_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::innerRadius "

Set rin_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::innerRadius "

Get rin_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::innerRadius "

Get rin_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::innerRadius "

Set rin_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::outerRadius "

Set rout_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::outerRadius "

Get rout_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::outerRadius "

Get rout_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::outerRadius "

Set rout_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::outerRadius "

Set rout_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::outerRadius "

Get rout_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::outerRadius "

Get rout_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::outerRadius "

Set rout_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::patternVelocity
"

Set PatternDisk::Omega_.

Unit: radians per geometrical unit time. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::patternVelocity
"

Get PatternDisk::Omega_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::setEmission "

Set PatternDisk::emission_.

The pointer is copied directly, not the array content.

This is a low-level function. Beware that: previously allocated array
will not be freed automatically;

array attached when the destructor is called will be freed. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::setVelocity "

Set PatternDisk::velocity__.

The pointer is copied directly, not the array content.

This is a low-level function. Beware that: previously allocated array
will not be freed automatically;

array attached when the destructor is called will be freed. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::radius "

Set PatternDisk::radius_.

The pointer is copied directly, not the array content.

This is a low-level function. Beware that: previously allocated array
will not be freed automatically;

array attached when the destructor is called will be freed. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::copyIntensity "

Set PatternDisk::emission_.

PatternDisk::emission_ is freed if not NULL, reallocated, and pattern
is copied into emission_.

If PatternDisk::opacity_, PatternDisk::velocity_ or
PatternDisk::radius_ have been set previously with mismatching sizes,
they are deallocated too.

Finally, PatternDisk::nnu_, PatternDisk::nphi_, and PatternDisk::nr_
are set according to naxes.

Parameters:
-----------

pattern:  Array to copy as emission_. May be NULL in which case
emission_ is simply deallocated and set to NULL.

naxes:  { nnu_, nphi_, nr_ }. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::getIntensity "

Get PatternDisk::emission_. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDisk::getIntensityNaxes "

Get PatternDisk::nnu_, PatternDisk::nphi_, and PatternDisk::nr_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::copyOpacity "

Set PatternDisk::opacity_.

PatternDisk::opacity_ is first freed if not NULL and set to NULL.

If pattern is not NULL, PatternDisk::emission_ must have been set
previously with matching dimensions. PatternDisk::opacity_ is then
reallocated, and pattern is copied into opacity_.

Parameters:
-----------

pattern:  Array to copy as opacity_. May be NULL in which case
opacity_ is simply deallocated and set to NULL.

naxes:  { nnu_, nphi_, nr_ }. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::opacity "

Get PatternDisk::opacity_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::copyVelocity "

Set PatternDisk::velocity_.

PatternDisk::velocity_ is first freed if not NULL and set to NULL.

If pattern is not NULL, PatternDisk::emission_ must have been set
previously with matching dimensions. PatternDisk::velocity_ is then
reallocated, and pattern is copied into velocity_.

Parameters:
-----------

pattern:  Array to copy as velocity_. May be NULL in which case
velocity_ is simply deallocated and set to NULL.

naxes:  { nphi_, nr_ }. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::copyGridRadius "

Set PatternDisk::radius_.

PatternDisk::radius_ is first freed if not NULL and set to NULL.

If pattern is not NULL, PatternDisk::emission_ must have been set
previously with matching dimensions. PatternDisk::radius_ is then
reallocated, and pattern is copied into radius_.

Parameters:
-----------

pattern:  Array to copy as radius_. May be NULL in which case radius_
is simply deallocated and set to NULL.

nr:  size of radius array. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::getGridRadius "

Get PatternDisk::radius_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::repeatPhi "

Set PatternDisk::repeat_phi_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::repeatPhi "

Get PatternDisk::repeat_phi_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::nu0 "

Set PatternDisk::nu0_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::nu0 "

Get PatternDisk::nu0_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::dnu "

Set PatternDisk::dnu_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::dnu "

Get PatternDisk::dnu_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::phimin "

Set PatternDisk::phimin_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::phimin "

Get PatternDisk::phimin_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::phimax "

Set PatternDisk::phimax_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::phimax "

Get PatternDisk::phimax_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::thickness "

Get thickness_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::thickness "

Get thickness_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::thickness "

Set thickness_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::thickness "

Set thickness_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::dir "

Get dir_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::dir "

Set dir_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::corotating "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::corotating "

Get dir_==1. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::velocityKind "

Set dir_=t?1:-1.

Get VelocityKind ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::velocityKind "

Set VelocityKind. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::projectedRadius
"

Projected radius of position coord on the equatorial plane. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::sphericalPhi "

Longitude. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDisk::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::showshadow "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::showshadow "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::redshift "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::redshift "";

%feature("docstring")
Gyoto::Astrobj::DynamicalDisk::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDisk::processHitQuantities "

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDisk::processHitQuantities "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::radiativeQ "

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDisk::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDisk::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDisk::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")
Gyoto::Astrobj::DynamicalDisk::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDisk::computeB4vect_ipole "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::describeProperty
"

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk::kind "

Get kind_. ";


// File: class_gyoto_1_1_astrobj_1_1_dynamical_disk3_d.xml
%feature("docstring") Gyoto::Astrobj::DynamicalDisk3D "

Geometrically thick optically thin disk read from a set of FITS files.

This class describes a PatternDiskBB that evolves dynamically. It is
described by a set of FITS files for different times. Its emission is
blackbody.

The disk is assumed to be described by a regular, constant in time,
grid.

The metric must be Kerr in BL coordinates.

C++ includes: GyotoDynamicalDisk3D.h ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::getProperties
"

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDisk3D::DynamicalDisk3D "

Standard constructor. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDisk3D::DynamicalDisk3D "

Copy constructor. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::clone "

Cloner. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDisk3D::~DynamicalDisk3D "

Destructor. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::file "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::file "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::tinit "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::tinit "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::dt "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::dt "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::PLindex "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::PLindex "";

%feature("docstring")
Gyoto::Astrobj::DynamicalDisk3D::floorTemperature "";

%feature("docstring")
Gyoto::Astrobj::DynamicalDisk3D::floorTemperature "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::temperature "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::temperature "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::withVelocity "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::withVelocity "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::emission1date
"

Compute emission at one grid date. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::emission "

Interpolate emission between grid dates. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDisk3D::transmission1date "

Compute transmission at one grid date. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::transmission "

Interpolate transmission between grid dates. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::getVelocity "

Get fluid 4-velocity at point.

Fill vel with the 4-vector velocity of the fluid at 4-position pos.

Parameters:
-----------

pos:  4-position at which to compute velocity;

vel:  4-velocity at pos. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::getVelocity "

Get Disk3D::velocity_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::zsym "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::zsym "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::tPattern "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::tPattern "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::omegaPattern "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::omegaPattern "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::setEmissquant
"

Set Disk3D::emissquant_.

The pointer is copied directly, not the array content.

This is a low-level function. Beware that: previously allocated array
will not be freed automatically;

array attached when the destructor is called will be freed. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::opacity "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::opacity "

Get Disk3D::opacity_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::setVelocity "

Set Disk3D::velocity__.

The pointer is copied directly, not the array content.

This is a low-level function. Beware that: previously allocated array
will not be freed automatically;

array attached when the destructor is called will be freed. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::copyEmissquant
"

Set Disk3D::emissquant_.

Disk3D::emissquant_ is freed if not NULL, reallocated, and pattern is
copied into emission_.

If Disk3D::velocity_ or has been set previously with mismatching
sizes, it is deallocated too.

Finally, Disk3D::nnu_, Disk3D::nphi_, Disk3D::nz_ and Disk3D::nr_ are
set according to naxes.

Parameters:
-----------

pattern:  Array to copy as emission_. May be NULL in which case
emission_ is simply deallocated and set to NULL.

naxes:  { nnu_, nphi_, nz_, nr_ }. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::getEmissquant
"

Get Disk3D::emissquant_. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDisk3D::getEmissquantNaxes "

Get { Disk3D::nnu_, Disk3D::nphi_, Disk3D::nz_, Disk3D::nr_ }. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::copyOpacity "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::copyVelocity "

Set Disk3D::velocity_.

Disk3D::velocity_ is first freed if not NULL and set to NULL.

If pattern is not NULL, Disk3D::emissquant_ must have been set
previously with matching dimensions. Disk3D::velocity_ is then
reallocated, and pattern is copied into velocity_.

Parameters:
-----------

pattern:  Array to copy as velocity_. May be NULL in which case
velocity_ is simply deallocated and set to NULL.

naxes:  { nphi_, nz_, nr_ }. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::repeatPhi "

Set Disk3D::repeat_phi_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::repeatPhi "

Get Disk3D::repeat_phi_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::nu0 "

Set Disk3D::nu0_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::nu0 "

Get Disk3D::nu0_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::dnu "

Set Disk3D::dnu_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::dnu "

Get Disk3D::dnu_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::rin "

Set Disk3D::rin_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::rin "

Get Disk3D::rin_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::rout "

Set Disk3D::rout_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::rout "

Get Disk3D::rout_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::zmin "

Set Disk3D::zmin_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::zmin "

Get Disk3D::zmin_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::zmax "

Set Disk3D::zmax_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::zmax "

Get Disk3D::zmax_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::phimin "

Set Disk3D::phimin_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::phimin "

Get Disk3D::phimin_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::phimax "

Set Disk3D::phimax_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::phimax "

Get Disk3D::phimax_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDisk3D::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::opticallyThin
"

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::opticallyThin
"

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::showshadow "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::showshadow "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::redshift "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::redshift "";

%feature("docstring")
Gyoto::Astrobj::DynamicalDisk3D::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::setParameters
"

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDisk3D::processHitQuantities "

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDisk3D::processHitQuantities "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::radiativeQ "

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDisk3D::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDisk3D::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDisk3D::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")
Gyoto::Astrobj::DynamicalDisk3D::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::getSinCos2Chi
"

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::computeB4vect
"

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDisk3D::computeB4vect_ipole "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDisk3D::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDisk3D::kind "

Get kind_. ";


// File: class_gyoto_1_1_astrobj_1_1_dynamical_disk_bolometric.xml
%feature("docstring") Gyoto::Astrobj::DynamicalDiskBolometric "

Geometrically thin disk read from a set of FITS files.

This class describes a PatternDiskBB that evolves dynamically. It is
described by a set of FITS files.

C++ includes: GyotoDynamicalDiskBolometric.h ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::DynamicalDiskBolometric "

Standard constructor. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::DynamicalDiskBolometric "

Copy constructor. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::clone
"

Cloner. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::~DynamicalDiskBolometric "

Destructor. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::emission "

Specific intensity I

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem, in the emitter's frame. It should take self-absorption
along dsem into account.

Reminder : intensity = I [J m^-2 s^-1 ster^-1 Hz^-1];

invariant intensity = I/3, which has the same value in any frame;

emission coefficient = j [J m^-3 s^-1 ster^-1 Hz^-1] , defined by dI =
j*ds, where ds is the distance travelled by the photon inside the
object;

invariant emission coef = j/2, which has the same value in any frame.

The equation used for radiative transfer (without absorption) is:

d(I/3)/d = (j/2) [*]

where is the integration parameter along the null geodesic.

NB: Let us consider a particular observer, with being the frequency
measured by this observer, and ds being the proper distance (as
measured by the observer) that the photon travels as it moves from
to+d along its geodesic. Then it can be shown that:

d = ds/

This shows that Eq. [*] is homogeneous.

The default implementation returns 1. if optically thick and dsem if
optically thin. It allows for a quick implementation of your object
for visualization purposes.

Parameters:
-----------

nu_em:  Frequency at emission [Hz]

dsem:  length over which to integrate inside the object [geometrical
units]

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::bolometricEmission "";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::processHitQuantities "

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::file "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::file "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::tinit
"";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::tinit
"";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::dt "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::dt "";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::emission "";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::emission "

Obsolete, update your code;. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::emission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::getVelocity "

Get fluid 4-velocity at point.

Fill vel with the 4-vector velocity of the fluid at 4-position pos.
getVelocity() should work at some distance from the equatorial plane.
The default implementation calls Metric::Generic::circularVelocity().

Parameters:
-----------

pos:  4-position at which to compute velocity;

vel:  4-velocity at pos. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::getVelocity "

Get PatternDisk::velocity_. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::spectralEmission "";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::spectralEmission "";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::innerRadius "

Set rin_. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::innerRadius "

Get rin_. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::innerRadius "

Get rin_. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::innerRadius "

Set rin_. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::innerRadius "

Set rin_. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::innerRadius "

Get rin_. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::innerRadius "

Get rin_. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::innerRadius "

Set rin_. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::outerRadius "

Set rout_. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::outerRadius "

Get rout_. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::outerRadius "

Get rout_. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::outerRadius "

Set rout_. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::outerRadius "

Set rout_. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::outerRadius "

Get rout_. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::outerRadius "

Get rout_. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::outerRadius "

Set rout_. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::patternVelocity "

Set PatternDisk::Omega_.

Unit: radians per geometrical unit time. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::patternVelocity "

Get PatternDisk::Omega_. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::setEmission "

Set PatternDisk::emission_.

The pointer is copied directly, not the array content.

This is a low-level function. Beware that: previously allocated array
will not be freed automatically;

array attached when the destructor is called will be freed. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::setVelocity "

Set PatternDisk::velocity__.

The pointer is copied directly, not the array content.

This is a low-level function. Beware that: previously allocated array
will not be freed automatically;

array attached when the destructor is called will be freed. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::radius
"

Set PatternDisk::radius_.

The pointer is copied directly, not the array content.

This is a low-level function. Beware that: previously allocated array
will not be freed automatically;

array attached when the destructor is called will be freed. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::copyIntensity "

Set PatternDisk::emission_.

PatternDisk::emission_ is freed if not NULL, reallocated, and pattern
is copied into emission_.

If PatternDisk::opacity_, PatternDisk::velocity_ or
PatternDisk::radius_ have been set previously with mismatching sizes,
they are deallocated too.

Finally, PatternDisk::nnu_, PatternDisk::nphi_, and PatternDisk::nr_
are set according to naxes.

Parameters:
-----------

pattern:  Array to copy as emission_. May be NULL in which case
emission_ is simply deallocated and set to NULL.

naxes:  { nnu_, nphi_, nr_ }. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::getIntensity "

Get PatternDisk::emission_. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::getIntensityNaxes "

Get PatternDisk::nnu_, PatternDisk::nphi_, and PatternDisk::nr_. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::copyOpacity "

Set PatternDisk::opacity_.

PatternDisk::opacity_ is first freed if not NULL and set to NULL.

If pattern is not NULL, PatternDisk::emission_ must have been set
previously with matching dimensions. PatternDisk::opacity_ is then
reallocated, and pattern is copied into opacity_.

Parameters:
-----------

pattern:  Array to copy as opacity_. May be NULL in which case
opacity_ is simply deallocated and set to NULL.

naxes:  { nnu_, nphi_, nr_ }. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::opacity "

Get PatternDisk::opacity_. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::copyVelocity "

Set PatternDisk::velocity_.

PatternDisk::velocity_ is first freed if not NULL and set to NULL.

If pattern is not NULL, PatternDisk::emission_ must have been set
previously with matching dimensions. PatternDisk::velocity_ is then
reallocated, and pattern is copied into velocity_.

Parameters:
-----------

pattern:  Array to copy as velocity_. May be NULL in which case
velocity_ is simply deallocated and set to NULL.

naxes:  { nphi_, nr_ }. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::copyGridRadius "

Set PatternDisk::radius_.

PatternDisk::radius_ is first freed if not NULL and set to NULL.

If pattern is not NULL, PatternDisk::emission_ must have been set
previously with matching dimensions. PatternDisk::radius_ is then
reallocated, and pattern is copied into radius_.

Parameters:
-----------

pattern:  Array to copy as radius_. May be NULL in which case radius_
is simply deallocated and set to NULL.

nr:  size of radius array. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::getGridRadius "

Get PatternDisk::radius_. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::repeatPhi "

Set PatternDisk::repeat_phi_. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::repeatPhi "

Get PatternDisk::repeat_phi_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::nu0 "

Set PatternDisk::nu0_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::nu0 "

Get PatternDisk::nu0_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::dnu "

Set PatternDisk::dnu_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::dnu "

Get PatternDisk::dnu_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::phimin
"

Set PatternDisk::phimin_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::phimin
"

Get PatternDisk::phimin_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::phimax
"

Set PatternDisk::phimax_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::phimax
"

Get PatternDisk::phimax_. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::transmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::transmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::thickness "

Get thickness_. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::thickness "

Get thickness_. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::thickness "

Set thickness_. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::thickness "

Set thickness_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::dir "

Get dir_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::dir "

Set dir_. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::corotating "";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::corotating "

Get dir_==1. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::velocityKind "

Set dir_=t?1:-1.

Get VelocityKind ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::velocityKind "

Set VelocityKind. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::projectedRadius "

Projected radius of position coord on the equatorial plane. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::sphericalPhi "

Longitude. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::Impact
"

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::metric
"

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::metric
"

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::showshadow "";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::showshadow "";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::redshift "";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::redshift "";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::processHitQuantities "";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::radiativeQ "

emission and transmission together ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::radiativeQ "";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::Omatrix "";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::Omatrix "";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::Omatrix "";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::Pmatrix "";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::getChi
"

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::computeB4vect_ipole "";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::getRefCount "

Get the current number of references. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")
Gyoto::Astrobj::DynamicalDiskBolometric::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::DynamicalDiskBolometric::kind "

Get kind_. ";


// File: class_gyoto_1_1_screen_1_1_empty.xml
%feature("docstring") Empty "

A dummy, empty 2D set.

C++ includes: GyotoScreen.h ";

%feature("docstring")  Empty::Empty "";

%feature("docstring")  Empty::begin "

Reset pointer. ";

%feature("docstring")  Empty::valid "

Whether the end has not been passed. ";

%feature("docstring")  Empty::size "

Number of positions contained. ";

%feature("docstring")  Empty::angles "

Get angle coordinates. ";


// File: class_gyoto_1_1_register_1_1_entry.xml
%feature("docstring") Gyoto::Register::Entry "

Entry in a register (or a full register)

A register is actually a chained list of Register::Entry instances.

C++ includes: GyotoRegister.h ";

%feature("docstring")  Gyoto::Register::Entry::Entry "

Constructor. ";

%feature("docstring")  Gyoto::Register::Entry::~Entry "

Destructor. ";

%feature("docstring")  Gyoto::Register::Entry::getSubcontractor "

Get subcontractor for a given name.

Search through the register for an Entry matching name and return the
corresponding subcontractor. If plugin is specified, only a
subcontractor matching both name and plugin will be returned. Note
that Gyoto::Entry::getSubcontractor() will not load the plug-in for
you, contrary to e.g. Gyoto::Metric::getSubcontractor(). If plugin is
the empty string, then the first subcontractor matching name will be
returned, and the name of the plug-in it belongs to will be returned
in plugin upon output.

Parameters:
-----------

name:  Name of the kind to look for.

plugin:  e.g. \"stdplug\".

errmode:  1 if getSubContractor() should return NULL upon failure.
Else a Gyoto::Error is thrown.

Pointer to subcontractor function. ";


// File: class_gyoto_1_1_astrobj_1_1_equatorial_hot_spot.xml
%feature("docstring") Gyoto::Astrobj::EquatorialHotSpot "";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::EquatorialHotSpot "";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::EquatorialHotSpot "";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::~EquatorialHotSpot "";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::clone "

Cloner.

This method must be implemented by the various Astrobj::Generic
subclasses in order to support cloning:

Cloning is necessary for multi-threading, recommended for interaction
with the Yorick plug-in etc.

Implementing it is very straightforward, as long as the copy
constructor Generic(const Generic& ) has been implemented: ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::spotRadSize
"";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::spotRadSize
"";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::beaming "";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::beaming "";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::beamAngle "";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::beamAngle "";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::magneticConfiguration "";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::magneticConfiguration "";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::getMass "

Get mass of particule. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::metric "

Set the Metric gg_. ";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::setInitialCondition "";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::getVelocity
"

Get fluid 4-velocity at point.

Fill vel with the 4-vector velocity of the fluid at 4-position pos.
getVelocity() should work at some distance from the equatorial plane.
The default implementation calls Metric::Generic::circularVelocity().

Parameters:
-----------

pos:  4-position at which to compute velocity;

vel:  4-velocity at pos. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::emission "

Specific intensity I

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem, in the emitter's frame. It should take self-absorption
along dsem into account.

Reminder : intensity = I [J m^-2 s^-1 ster^-1 Hz^-1];

invariant intensity = I/3, which has the same value in any frame;

emission coefficient = j [J m^-3 s^-1 ster^-1 Hz^-1] , defined by dI =
j*ds, where ds is the distance travelled by the photon inside the
object;

invariant emission coef = j/2, which has the same value in any frame.

The equation used for radiative transfer (without absorption) is:

d(I/3)/d = (j/2) [*]

where is the integration parameter along the null geodesic.

NB: Let us consider a particular observer, with being the frequency
measured by this observer, and ds being the proper distance (as
measured by the observer) that the photon travels as it moves from
to+d along its geodesic. Then it can be shown that:

d = ds/

This shows that Eq. [*] is homogeneous.

The default implementation returns 1. if optically thick and dsem if
optically thin. It allows for a quick implementation of your object
for visualization purposes.

Parameters:
-----------

nu_em:  Frequency at emission [Hz]

dsem:  length over which to integrate inside the object [geometrical
units]

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::radiativeQ "

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::setParameter
"

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::fillProperty
"

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::innerRadius
"

Get rin_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::innerRadius
"

Get rin_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::innerRadius
"

Set rin_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::innerRadius
"

Set rin_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::outerRadius
"

Get rout_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::outerRadius
"

Get rout_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::outerRadius
"

Set rout_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::outerRadius
"

Set rout_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::thickness "

Get thickness_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::thickness "

Get thickness_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::thickness "

Set thickness_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::thickness "

Set thickness_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::dir "

Get dir_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::dir "

Set dir_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::corotating "";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::corotating "

Get dir_==1. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::velocityKind
"

Set dir_=t?1:-1.

Get VelocityKind ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::velocityKind
"

Set VelocityKind. ";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::projectedRadius "

Projected radius of position coord on the equatorial plane. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::sphericalPhi
"

Longitude. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::showshadow "";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::showshadow "";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::redshift "";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::redshift "";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::processHitQuantities "

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::processHitQuantities "";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::radiativeQ "";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::transmission
"

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::transmission
"

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::transmission
"

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::computeB4vect_ipole "";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::interpolate
"

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::interpolate
"

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::incRefCount
"

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::decRefCount
"

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::getRefCount
"

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::isThreadSafe
"

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::fillElement
"

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::setParameter
"

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::kind "

Get kind_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::getImin "

Get imin_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::getImax "

Get imax_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::getI0 "

Get i0_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::metric "

Get metric. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::initCoord "";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::initCoord "";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::setInitCoord
"

Set Initial coordinate.

Set imin_= imax_= i0_, and x  [i0]=coord[ ].

If dir==1, i0_ is set to 0. If dir==-1, i0_ is set to x_size_-1.

If dir==0 and the Worldine has never been computed ( i0_==0, imin_==1
and imax_==0), then dir defaults to 1 for a massive particle and -1
for a massless particle.

If dir==0 and the Worldine has already been computed, i0_ is not
changed.



Parameters:
-----------

coord:  new initial coordinates

dir:  direction of integration. 1 for forward integration, -1 for
backards integration, 0 for unknown or both

Ephi:  initial value of base vector to parallel-transport. Ignored if
parallel_transport_ is false.

Etheta:  initial value of base vector to parallel-transport. Ignored
if parallel_transport_ is false. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::setInitCoord
"

Set Initial coordinate.

Set imin_= imax_= i0_, and x  [i0]=coord[ ].

If dir==1, i0_ is set to 0. If dir==-1, i0_ is set to x_size_-1.

If dir==0 and the Worldine has never been computed ( i0_==0, imin_==1
and imax_==0), then dir defaults to 1 for a massive particle and -1
for a massless particle.

If dir==0 and the Worldine has already been computed, i0_ is not
changed.



Parameters:
-----------

coord:  new initial coordinates

dir:  direction of integration. 1 for forward integration, -1 for
backards integration, 0 for unknown or both ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::setInitCoord
"

Set initial coordinate.

Parameters:
-----------

pos:  initial 4-position

vel:  initial 3-velocity

dir:  direction of integration ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::setPosition
"

Set initial 4-position. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::setVelocity
"

Set initial 3-velocity. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::reset "

Forget integration, keeping initial contition. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::reInit "

Reset and recompute particle properties. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::className "

\"Worldline\" ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::className_l
"

\"worldline\" ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::integrator "

Set the integrator.

Initialize state_ to use the required integrator.

Parameters:
-----------

type:  Either \"Legacy\" or (if GYOTO_HAVE_BOOST_INTEGRATORS) one of
\"runge_kutta_cash_karp54\", \"runge_kutta_fehlberg78\",
\"runge_kutta_dopri5\", \"runge_kutta_cash_karp54_classic\" ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::integrator "

Describe the integrator used by state_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::integ31 "

Set the integrator kind to 3+1 or 4D.

Initialize state_ to use the required geodesic equation. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::integ31 "

Get the kind of geodesic equation integrated by state_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::deltaMin "

Get delta_min_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::deltaMin "

Set delta_min_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::deltaMax "

Get delta_max_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::deltaMax "

Get delta max at a given position

Parameters:
-----------

pos:  4-position

delta_max_external:  external constraint on delta_max

the smallest value between delta_max_, delta_max_external, and R*
delta_max_over_r_ where R is pos[1] in spherical coordinates and
max(x1, x2, x3) in Cartesian coordinates. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::deltaMax "

Set delta_max_ ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::absTol "

Set abstol_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::absTol "

Get abstol_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::relTol "

Set reltol_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::relTol "

Get reltol_. ";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::maxCrossEqplane "

Set #maxCrosEqplane_. ";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::maxCrossEqplane "

Get maxCrossEqplane_. ";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::deltaMaxOverR "

Get delta_max_over_r_. ";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::deltaMaxOverR "

Set delta_max_over_r_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::delta "

Expand memory slots for polarization vectors.

Assignment to another Worldline Set delta_ ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::delta "

Set delta_ in specified units. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::delta "

Get delta_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::delta "

Get delta_ in specified units. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::tMin "

Get tmin_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::tMin "

Get tmin_ in specified unit. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::tMin "

Set tmin_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::tMin "

Set tmin_ in specified unit. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::adaptive "

Set adaptive_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::adaptive "

Get adaptive_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::secondary "

Set secondary_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::secondary "

Get secondary_. ";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::parallelTransport "

Set parallel_transport_. ";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::parallelTransport "

Get parallel_transport_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::maxiter "

Set maxiter_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::maxiter "

Get maxiter_. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::getCst "

Returns the worldline's cst of motion (if any)

Return pointer to array holding the previously set Metric-specific
constants of motion.

This function returns a pointer to the actual storage location and
should be handled with care. std::vector<double> Worldline:
constantsOfMotion() constprovides a convenient way to retrieve a copy
of the content. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::setCst "

Set Metric-specific constants of motion.

The will (re)allocate Worldline::cst_, copy cst into it, and set
Worldline::cst_n_.

This is the same as void Worldline:
constantsOfMotion(std::vector<double> const cstv) using a C-style
array instead of a vector. ";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::constantsOfMotion "

Set Metric-specific constants of motion.

The will (re)allocate Worldline::cst_, copy cst into it, and set
Worldline::cst_n_.

This is the same as getCst using a vector instead of a C-style array.
";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::constantsOfMotion "

Return a copy of the Metric-specific constants of motion.

This funtion return a copy of the constants of motion. getCst() can be
used to retrieve a pointer to the actual array used internally which
is slightly more efficient for read-only access. ";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::setInitialCondition "

Set or re-set the initial condition prior to integration.

Parameters:
-----------

gg:   Gyoto::SmartPointer to the Gyoto::Metric in this universe;

coord:  8 element array containing the initial condition, i.e. the
4-position and the 4-velocity of the Photon at the receiving end;

dir:  direction: 1 for future, -1 for past.

Ephi:  initial value of base vector to parallel-transport. Ignored if
parallel_transport_ is false.

Etheta:  initial value of base vector to parallel-transport. Ignored
if parallel_transport_ is false. ";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::setInitialCondition "

Set or re-set the initial condition prior to integration.

Parameters:
-----------

gg:   Gyoto::SmartPointer to the Gyoto::Metric in this universe;

coord:  8 element array containing the initial condition, i.e. the
4-position and the 4-velocity of the Photon at the receiving end;

dir:  direction: 1 for future, -1 for past. ";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::getInitialCoord "

Get initial coordinates + base vectors.

Depending on the size of dest and on the value of parallel_transport_,
get position (xi_), velocity (xidot_) and possibly other triad vectors
(epi_ and eti_). ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::getCoord "

Get coordinates+base vectors corresponding to index.

Depending on the value of parallel_transport_, get position (xi_),
velocity (xidot_) and possibly other triad vectors (epi_ and eti_).
coord is resized to the right number of elements. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::getCoord "

Get coordinates+base vectors corresponding to index.

We need this non-const implementation to allow the const, size_t and
the non-const, double implementations to coexist. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::getCoord "

Get coordinates+base vectors corresponding to date dest[0].

Depending on the value of parallel_transport_, get position (xi_),
velocity (xidot_) and possibly other triad vectors (epi_ and eti_).
coord is resized to the right number of elements. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::getCoord "

Get 8-coordinates for specific dates.

The coordinates will be computed using the integrator, so they will be
as accurate as possible. Some heuristics are used to speed up the
process and it is presumably faster to call this routine with a sorted
list of dates. The line will be integrated further as required. An
error will be thrown if it is not possible to reach a certain date.

Parameters:
-----------

dates:  the list of dates for which the coordinates are to be computed
in proper time or affine parameter if #proper is true or in coordinate
time if #proper is false (default);

n_dates:  the number of dates to compute ;

x1dest:  x2dest:  x3dest:  x0dot:  x1dot:  x2dot:  x3dot:  arrays in
which to store the result. These pointer may be set to NULL to
retrieve only part of the information. They must be pre-allocated.

ephi0:  ephi1:  ephi2:  ephi3:  etheta0:  etheta1:  etheta2:  etheta3:
arrays in which to store the ephi and etheta (parallel transport
case). These pointer may be set to NULL to retrieve only part of the
information. They must be pre-allocated.

otime:  array in which to store the other time: coordinate time if
#proper, else proper time or affine parameter.

proper:  bool: whether #dates is proper time (or affine parameter) or
coordinate time. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::getCoord "

Get all computed positions.

Get all the pre-computed 8 coordinates (e.g. thanks to a prior call to
xFill()) of this worldline. ";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::getCartesianPos "

Get Cartesian expression of 4-position at index. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::xStore "

Store coord at index ind. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::xStore "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::xStore "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::xFill "

Fill x0, x1... by integrating the Worldline from previously set
inittial condition to time tlim. ";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::get_nelements "

Get number of computed dates. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::get_t "

Get computed dates. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::get_tau "

Get computed proper times or values of the affine parameter. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::getCartesian
"

Get the 6 Cartesian coordinates for specific dates.

The 6 coordinates (x, y, z, dx/dt, dy/dt, dz/dt) will be computed
using the integrator and interpolated if necessary, so they will be as
accurate as possible. Transforming to Cartesian coordinates is not
necessarily meaningful.

Parameters:
-----------

dates:  List of dates for which the coordinates are to be computed;

n_dates:  Number of dates to compute ;

x:  y:  z:  xprime:  yprime:  zprime:  Arrays in which to store the
result. These pointer may be set to NULL to retrieve only part of the
information. Else, they must be pre- allocated. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::get_xyz "

Get 3-position in cartesian coordinates for computed dates. ";

%feature("docstring")
Gyoto::Astrobj::EquatorialHotSpot::checkPhiTheta "

Bring in [0,] and in [0,2].

checkPhiTheta() Modifies coord if the corrdinates are spherical-like
so that coord[2]=theta is in [0,pi] and coord[3]=phi is in [0,2pi].
Important to use in all astrobj in spherical coordinates to prevent
\"z-axis problems\". ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::getSkyPos "

Get computed positions in sky coordinates. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::get_dot "

Get computed 4-velocities. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::get_prime "

Get computed 3-velocities. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::save_txyz "

Save in a file. ";

%feature("docstring")  Gyoto::Astrobj::EquatorialHotSpot::save_txyz "

Save, converted. ";


// File: class_gyoto_1_1_error.xml
%feature("docstring") Gyoto::Error "

Class for thowing exceptions.

Gyoto dlopens its plug-ins. The throw/catch C++ mechanism cannot pass
the dlopen boundary. The Gyoto::Error mechanism alleviates this C++
language limitation.

Every Gyoto method (either in the main Gyoto library or in a Gyoto
plug-in) should check for possible error conditions and throw adequate
Gyoto::Error exceptions through the GYOTO_ERROR macro (which calls the
Gyoto::throwError() function). For instance:

If the main code has set Gyoto::Error::handler_t error handler using
Gyoto::Error::setHandler(), these errors will then be passed to it.
Else, the Error is C++-thrown at the main Gyoto library level, above
the dlopen boundary.

The main code can then catch these exceptions and act appropriately,
for instance:

C++ includes: GyotoError.h ";

%feature("docstring")  Gyoto::Error::Error "

Constructor with an error message. ";

%feature("docstring")  Gyoto::Error::Error "";

%feature("docstring")  Gyoto::Error::Report "

Print-out error message on standard error. ";

%feature("docstring")  Gyoto::Error::getErrcode "

Retrieve error code.

See also operator const char * () const and get_message().  Error code
";

%feature("docstring")  Gyoto::Error::get_message "

Retrieve error message for custom handling of the exception.

See also operator const char * () const and getErrCode(). char*
message : pointer to the error message ";


// File: class_gyoto_1_1_factory.xml
%feature("docstring") Gyoto::Factory "

XML input/output.

The Factory is responsible from building objects from their XML
description, and from saving an XML description of existing objects.
Since the Factory doesn't know how to build the variety of objects
available in Gyoto and in external plug-ins, the Factory orders
Metric, Astrobj and Spectrum objects from registered subcontractors
(see SmartPointee::Subcontractor_t). The factory an the various
subcontractors communicate through a FactoryMessenger.

To read an XML file, you simply create an instance of the Factory with
a filename, and get whichever object type you are interested in: or,
for a single object and without checking the kind ( kind()) first:

Writing an object to a file is even easier. Assuming \"object\" below
is a Gyoto::SmartPointer<class> where \"class\" is one of Scenery,
Metric::Generic, Astrobj::Generic, Spectrum::Generic, Screen, Photon
or Spectrometer:

or, for short:

You can also directly display the object to stdout:

C++ includes: GyotoFactory.h ";

%feature("docstring")  Gyoto::Factory::Factory "

Constructor for reading a file.

If filename starts with \"<?xml\", it is interpreted as XML data and
parsed directly (with no file access). It is possible to parse a file
that actually starts with those unlikely characters by escaping the
first with '\\\\'. If filename starts with '\\\\', this single
character is always stripped. ";

%feature("docstring")  Gyoto::Factory::Factory "

Constructor for saving (or printing) a Scenery. ";

%feature("docstring")  Gyoto::Factory::Factory "

Constructor for saving (or printing) a Metric. ";

%feature("docstring")  Gyoto::Factory::Factory "

Constructor for saving (or printing) an Astrobj. ";

%feature("docstring")  Gyoto::Factory::Factory "

Constructor for saving (or printing) a Spectrum. ";

%feature("docstring")  Gyoto::Factory::Factory "

Constructor for saving (or printing) a Screen. ";

%feature("docstring")  Gyoto::Factory::Factory "

Constructor for saving (or printing) a Photon. ";

%feature("docstring")  Gyoto::Factory::Factory "

Constructor for saving (or printing) a Spectrometer. ";

%feature("docstring")  Gyoto::Factory::~Factory "

Destructor. ";

%feature("docstring")  Gyoto::Factory::kind "

Get Factory::kind_. ";

%feature("docstring")  Gyoto::Factory::scenery "

Find Scenery element, instantiate it and get it.

Scenery must be the root element. scenery() will call metric(),
astrobj() and screen(). ";

%feature("docstring")  Gyoto::Factory::metric "

Find Metric element, instantiate it and get it.

Metric may be either the root element or directly within the root
element. ";

%feature("docstring")  Gyoto::Factory::screen "

Find Screen element, instantiate it and get it.

Screen may be either the root element or directly within the root
element. ";

%feature("docstring")  Gyoto::Factory::astrobj "

Find Astrobj element, instantiate it and get it.

Astrobj may be either the root element or directly within the root
element. ";

%feature("docstring")  Gyoto::Factory::photon "

Find Photon element, instantiate it and get it.

Photon may be either the root element or directly within the root
element. ";

%feature("docstring")  Gyoto::Factory::spectrum "

Find Photon element, instantiate it and get it.

Photon may be either the root element or directly within the root
element. ";

%feature("docstring")  Gyoto::Factory::spectrometer "

Find Spectrometer element, instantiate it and get it.

Spectrometer may be either the root element or directly within the
root element. ";

%feature("docstring")  Gyoto::Factory::write "

Write constructed XML representation to file. ";

%feature("docstring")  Gyoto::Factory::format "

Get constructed XML representation as std::string. ";

%feature("docstring")  Gyoto::Factory::metric "

Set Metric for this document.

If called several times for the same document, the metric
SmartPointers must point to the same instance or an error will be
thrown using Gyoto::throwError(). ";

%feature("docstring")  Gyoto::Factory::astrobj "

Set Astrobj for this document.

If called several times for the same document, the astrobj
SmartPointers must point to the same instance or an error will be
thrown using Gyoto::throwError(). ";

%feature("docstring")  Gyoto::Factory::screen "

Set Screen for this document.

If called several times for the same document, the screen
SmartPointers must point to the same instance or an error will be
thrown using Gyoto::throwError(). ";

%feature("docstring")  Gyoto::Factory::setContent "

Set text content of XML element. ";

%feature("docstring")  Gyoto::Factory::setParameter "

Create new XML element without content.

E.g.

Parameters:
-----------

name:  XML entity name.

pel:  Parent XML element. ";

%feature("docstring")  Gyoto::Factory::setParameter "

Create new XML element with double value.

E.g.

Parameters:
-----------

name:  XML entity name.

value:  Entity content.

pel:  Parent XML element. ";

%feature("docstring")  Gyoto::Factory::setParameter "

Create new XML element with integer value.

E.g.

Parameters:
-----------

name:  XML entity name.

value:  Entity content.

pel:  Parent XML element. ";

%feature("docstring")  Gyoto::Factory::setParameter "

Create new XML element with integer value.

E.g.

Parameters:
-----------

name:  XML entity name.

value:  Entity content.

pel:  Parent XML element. ";

%feature("docstring")  Gyoto::Factory::setParameter "

Create new XML element with integer value.

E.g.

Parameters:
-----------

name:  XML entity name.

value:  Entity content.

pel:  Parent XML element. ";

%feature("docstring")  Gyoto::Factory::setParameter "

Create new XML element with integer value.

E.g.

Parameters:
-----------

name:  XML entity name.

value:  Entity content.

pel:  Parent XML element. ";

%feature("docstring")  Gyoto::Factory::setParameter "

Create new XML element with string content.

E.g.

Any parameter can acually be set this way if total control over Text
formatting is wished for.

Parameters:
-----------

name:  XML entity name.

value:  Entity content.

pel:  Parent XML element. ";

%feature("docstring")  Gyoto::Factory::setParameter "

Create new XML element with array content.

E.g.

Parameters:
-----------

name:  XML entity name.

val:  Entity content.

nelem:  Number of elements in val to output.

pel:  Parent XML element.

child:  If not NULL, set to a new Gyoto::FactoryMessenger pointing to
the new element. It must be deleted later. ";

%feature("docstring")  Gyoto::Factory::setParameter "";

%feature("docstring")  Gyoto::Factory::setParameter "";

%feature("docstring")  Gyoto::Factory::fullPath "

Transform relative path into absolute path.

relpath is interpreted as follows:

If it starts with \"/\", it is interpreted as an absolute path and is
returned as is.

If it is prefixed with \"`pwd`/\", the rest of relpath is interpreted
as relative to the current working directory, i.e. fullPath() tries to
mimic how the shell would expand relpath into an absolute path.

In any other circumstance, relpath is interpreted to relative to the
directory where the XML file resides.

Parameters:
-----------

relpath:  Path specification.

Absolute path to same file. ";


// File: class_gyoto_1_1_factory_messenger.xml
%feature("docstring") Gyoto::FactoryMessenger "

Factory / SmartPointee::Subcontractor_t interface.

A FactoryMessenger instance is like an employee passing messages
between its employer (the Factory) and a subcontractor (a function of
the SmartPointee::Subcontractor_t type).

The FactoryMessenger also communicate with the fillElement method of
some classes ( Astrobj::Generic::fillElement(),
Metric::Generic::fillElement(), Spectrum::Generic::fillElement()).

A subcontractor function typically loops calling getNextParameter() to
read all the parameters provided for it in an XML file. If BASE is one
of Astrobj, Metric or Spectrum, and MyClass is an implementation of
BASE::Generic, the subcontractor static member function often looks
like this:

Other get* methods are provided to cope with more complex syntax (e.g.
when XML attributes are used, as in <ParameterName
attribute=\"attrvalue\">ParameterValue</ParameterName>

Conversely, the Factory asks certain Gyoto classes through their
fillElement() method how they should be printed or saved to an XML
file. Those fillElement() methods use the FactoryMessenger::set*()
methods (in particular setParameter()) as well as, occasionally,
makeChild() to describe themselves to the Factory.

C++ includes: GyotoFactoryMessenger.h ";

%feature("docstring")  Gyoto::FactoryMessenger::FactoryMessenger "

Constructor called before subcontracting. ";

%feature("docstring")  Gyoto::FactoryMessenger::FactoryMessenger "

Constructor called before fillElement. ";

%feature("docstring")  Gyoto::FactoryMessenger::reset "

Get back to first parameter. ";

%feature("docstring")  Gyoto::FactoryMessenger::metric "

Build and get the Metric described in this XML file.

An Gyoto XML file may contain at most a single Metric section and it
may be present about anywhere in the XML tree. Individual
subcontractors should not try to interpret this section directly, but
should call metric() to find and interpret the Metric section. ";

%feature("docstring")  Gyoto::FactoryMessenger::screen "

Build and get the Screen described in this XML file.

An Gyoto XML file may contain at most a single Screen section and it
may be present about anywhere in the XML tree. Individual
subcontractors should not try to interpret this section directly, but
should call screen() to find and interpret the Screen section. ";

%feature("docstring")  Gyoto::FactoryMessenger::photon "

Build and get the Photon described in this XML file.

An Gyoto XML file may contain at most a single Photon section and it
may be present about anywhere in the XML tree. Individual
subcontractors should not try to interpret this section directly, but
should call photon() to find and interpret the Photon section. ";

%feature("docstring")  Gyoto::FactoryMessenger::astrobj "

Build and get the Astrobj described in this XML file.

An Gyoto XML file may contain at most a single Astrobj section and it
may be present about anywhere in the XML tree. Individual
subcontractors should not try to interpret this section directly, but
should call astrobj() to find and interpret the Astrobj section. ";

%feature("docstring")  Gyoto::FactoryMessenger::getNextParameter "

Get name and value of next parameter.

On each call, return a pair name-content of one of the children_.
Usually, \"name\" is the name of a parameter and \"content\" is the
string representation of the corresponding value. For instance:

Parameters:
-----------

name:  upon output, name of the child

content:  of the child

unit=:  propertty of the child

1 if there remains parameters to retrieve, 0 otherwise. ";

%feature("docstring")  Gyoto::FactoryMessenger::getSelfAttribute "

Get attribute of FactoryMessenger::element_.

For instance a Spectrometer description looks like this and the
Spectrometer builder uses getSelfAttribute() to retrieve the
attributes \"kind\" and \"nsamples\".

Parameters:
-----------

attrname:  name of the attribute

attrvalue ";

%feature("docstring")  Gyoto::FactoryMessenger::getAttribute "

Get attribute of a last retrieved parameter.

For instance

Parameters:
-----------

attrname:  name of the attribute

attrvalue ";

%feature("docstring")  Gyoto::FactoryMessenger::getFullContent "

Get full content of element_.

In exceptional circumstances, it may be necessary to get the entire
text content of the topmost element FactoryMessenger::element_ instead
or getting only the individual FactoryMessenger::children_ .

For instance a Spectrometer description looks like this: and the
Spectrometer builder uses getFullContent() to retrieve the spectral
boundaries (2.0e-6 and 2.4e-6 here). ";

%feature("docstring")  Gyoto::FactoryMessenger::getChild "

Get another FactoryMessenger instance initialized to current child.

If one of the FactoryMessenger::children_ is complex (for instance the
complete description of a Gyoto::Spectrum), it is possible to
initialize a new FactoryMessenger and call the correct subcontractor:
The child is allocated with new and must be deleted after use. ";

%feature("docstring")  Gyoto::FactoryMessenger::fullPath "

Transform path into full path specification.

This function takes a relative path (e.g. ../foo/bar.data) and
transforms it into a full path (starting with \"/\"). It is not
guaranteed to be portable (we assume that the path separator is \"/\"
and that absolute paths start with \"/\").

Parameters:
-----------

relpath:  path relative to the directory where the XML file on which
the Factory works is located.

fullpath at full path specification to the same point pon the file-
system. ";

%feature("docstring")  Gyoto::FactoryMessenger::metric "

Set the Metric.

At most one Metric section may be present in a give Gyoto XML file.

When an object's fillElement() method is called, if this object is
connected to a Metric, it should call metric() with this Metric. Very
often, the Metric will already have been set previously. The Factory
will check that all the objects in the hierarchy are attached to the
same Metric instance, and save this instance only once. Trying to set
the Metric to something else than the already set Metric instance is
an error condition.

To make things clearer: Assume \"scenery\" is a fully filled Scenery.
scenery->fillElement(messenger) will call:

The Factory will then call screen_->fillElement(child_messenger) and
obj_->fillElement(child_messenger), each of which will also call
metric(). If the same Metric is connected to the Astrobj, to the
Screen and to the Scenery, all is well. Else, you have a bug to fix.
";

%feature("docstring")  Gyoto::FactoryMessenger::astrobj "

Set the Astrobj.

Same as metric(), but for the Astrobj. ";

%feature("docstring")  Gyoto::FactoryMessenger::screen "

Set the Screen.

Same as metric(), but for the Screen. ";

%feature("docstring")  Gyoto::FactoryMessenger::setParameter "

Output parameter.

Create child XML element of the form for instance when \"name\" is
boolean (present or absent), or only takes attributes (see
FactoryMessenger::setAttribute()). As an example,
Astrobj::Generic::fillElement() uses setParameter() to set either
Opticallythin or OpticallyThick. ";

%feature("docstring")  Gyoto::FactoryMessenger::setParameter "

Output parameter.

Convert value to striing \"svalue\" and create an XML child element of
the form ";

%feature("docstring")  Gyoto::FactoryMessenger::setParameter "

Output parameter.

Convert value to striing \"svalue\" and create an XML child element of
the form ";

%feature("docstring")  Gyoto::FactoryMessenger::setParameter "

Output parameter.

Convert value to striing \"svalue\" and create an XML child element of
the form ";

%feature("docstring")  Gyoto::FactoryMessenger::setParameter "

Output parameter.

Convert value to striing \"svalue\" and create an XML child element of
the form ";

%feature("docstring")  Gyoto::FactoryMessenger::setParameter "

Output parameter.

Convert value to string \"svalue\" and create an XML child element of
the form ";

%feature("docstring")  Gyoto::FactoryMessenger::setParameter "

Output parameter.

Create an XML child element of the form ";

%feature("docstring")  Gyoto::FactoryMessenger::setParameter "

Output an array of parameters.

For instance: will result in something like this:

The exact format is unspecified, determined at compile time, and by
default, unlike in the example above, outputs a large number of digits
for each double (about 20).

Parameters:
-----------

name:  the name of the parameter

val[]:  an array of doubles

n:  number of cells in val[]

child:  (optional) if not NULL, a new FactoryMessenger is created to
access the new parameter element e.g. to set attributes in it (using
setSelfAttribute()). You then need to delete the child. ";

%feature("docstring")  Gyoto::FactoryMessenger::setParameter "";

%feature("docstring")  Gyoto::FactoryMessenger::setParameter "

Output a vector of parameters. ";

%feature("docstring")  Gyoto::FactoryMessenger::setSelfAttribute "

Set attribute in FactoryMessenger::element_.

For instance Spectrometer::fillElement() sets its \"kind\" attribute
somewhat like this: to produce something like this: ";

%feature("docstring")  Gyoto::FactoryMessenger::setSelfAttribute "

Set attribute in FactoryMessenger::element_.

See setSelfAttribute(std::string attrname, std::string value) ";

%feature("docstring")  Gyoto::FactoryMessenger::setSelfAttribute "

Set attribute in FactoryMessenger::element_.

See setSelfAttribute(std::string attrname, std::string value) ";

%feature("docstring")  Gyoto::FactoryMessenger::setSelfAttribute "

Set attribute in FactoryMessenger::element_.

See setSelfAttribute(std::string attrname, std::string value) ";

%feature("docstring")  Gyoto::FactoryMessenger::setFullContent "

Low level, prefer setParameter()

Exceptionnaly, a class instance may be best described by setting the
entire content of the corresponding element than by setting a bunch of
\"parameters\". This is the case of the spectrometer, which sets a
couple of attributes and reserves the full content for the spectral
boundaries (see Spectrometer::fillElement()). ";

%feature("docstring")  Gyoto::FactoryMessenger::makeChild "

Create child FactoryMessenger.

To be used from fillElement() methods. For instance, the
Star::fillElement() method calls makeChild() to save the Star's
Spectrum and Opacity members somewhat like this:

The child messenger is allocated with new, you need to delete it after
use. ";


// File: class_gyoto_1_1_fits_r_w.xml
%feature("docstring") Gyoto::FitsRW "";

%feature("docstring")  Gyoto::FitsRW::FitsRW "

Constructor. ";

%feature("docstring")  Gyoto::FitsRW::FitsRW "

Copy constructor. ";

%feature("docstring")  Gyoto::FitsRW::clone "";

%feature("docstring")  Gyoto::FitsRW::~FitsRW "

Destructor. ";

%feature("docstring")  Gyoto::FitsRW::numin "";

%feature("docstring")  Gyoto::FitsRW::numin "";

%feature("docstring")  Gyoto::FitsRW::numax "";

%feature("docstring")  Gyoto::FitsRW::numax "";

%feature("docstring")  Gyoto::FitsRW::nnu "";

%feature("docstring")  Gyoto::FitsRW::nnu "";

%feature("docstring")  Gyoto::FitsRW::tmin "";

%feature("docstring")  Gyoto::FitsRW::tmin "";

%feature("docstring")  Gyoto::FitsRW::tmax "";

%feature("docstring")  Gyoto::FitsRW::tmax "";

%feature("docstring")  Gyoto::FitsRW::nt "";

%feature("docstring")  Gyoto::FitsRW::nt "";

%feature("docstring")  Gyoto::FitsRW::dt "";

%feature("docstring")  Gyoto::FitsRW::dt "";

%feature("docstring")  Gyoto::FitsRW::getIndices "";

%feature("docstring")  Gyoto::FitsRW::interpolate "";


// File: class_gyoto_1_1_astrobj_1_1_fixed_star.xml
%feature("docstring") Gyoto::Astrobj::FixedStar "

Fixed (i.e. non-moving) star (or spherical blob)

The target of ray-traced Gyoto::Photon

C++ includes: GyotoFixedStar.h ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::FixedStar "

Default constructor.

Everything is undefined, call setCoordSys(), setPos() and radius(). ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::FixedStar "

Copy constructor. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::clone "

Cloner.

This method must be implemented by the various Astrobj::Generic
subclasses in order to support cloning:

Cloning is necessary for multi-threading, recommended for interaction
with the Yorick plug-in etc.

Implementing it is very straightforward, as long as the copy
constructor Generic(const Generic& ) has been implemented: ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::FixedStar "

Standard constructor. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::~FixedStar "

Destructor. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::getPos "

Get const pointer to pos_. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::getPos "

Get a copy of the pos_ array. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::position "

Get vector copy of pos_. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::position "

Set pos_ from vector. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::rotating "";

%feature("docstring")  Gyoto::Astrobj::FixedStar::rotating "";

%feature("docstring")  Gyoto::Astrobj::FixedStar::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::radius "

Set radius. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::setPos "

Set pos_ array. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::radius "

Get radius_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::radius "

Set radius_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::radius "

Get radius_ in specified unit. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::radius "

Set radius_ in specified unit. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::className "

\"UniformSphere\" ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::className_l "

\"uniformsphere\" ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::spectrum "

Set spectrum_. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::spectrum "

Get spectrum_. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::opacity "

Set opacity_. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::opacity "

Get opacity_. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::radius "

Get radius_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::radius "

Get radius_ in specified unit. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::radius "

Set radius_ in specified unit. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::deltaMaxOverRadius "

Get dltmor_. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::deltaMaxOverRadius "

Set dltmor_. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::deltaMaxOverDistance
"

Get dltmod_. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::deltaMaxOverDistance
"

Set dltmod_. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::isotropic "";

%feature("docstring")  Gyoto::Astrobj::FixedStar::isotropic "";

%feature("docstring")  Gyoto::Astrobj::FixedStar::alpha "";

%feature("docstring")  Gyoto::Astrobj::FixedStar::alpha "";

%feature("docstring")  Gyoto::Astrobj::FixedStar::deltaMax "

Parameters:

coord:  current photon position

max( dltmor_* radius_, dltmod_*operator()(double coord[]) ) ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")  Gyoto::Astrobj::FixedStar::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::safetyValue "

Set Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::safetyValue "

Get Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::deltaInObj "

Get Generic::delta_inobj_.

Get the constant integration step inside the astrobj

delta_inobj_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::deltaInObj "

Set Generic::delta_inobj_. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::giveDelta "

Maximum inside object.

Gives the requested integration stept (in coordinate time t) between
two neighbooring points along a portion of geodesic inside an astrobj;
the current implementation only considers a constant delta, equal to
Standard::deltaInobj()

Parameters:
-----------

coord:  input coordinate at whicht is given ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")
Gyoto::Astrobj::FixedStar::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::FixedStar::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::showshadow "";

%feature("docstring")  Gyoto::Astrobj::FixedStar::showshadow "";

%feature("docstring")  Gyoto::Astrobj::FixedStar::redshift "";

%feature("docstring")  Gyoto::Astrobj::FixedStar::redshift "";

%feature("docstring")  Gyoto::Astrobj::FixedStar::getDefaultQuantities
"

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::processHitQuantities
"

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::processHitQuantities
"";

%feature("docstring")  Gyoto::Astrobj::FixedStar::radiativeQ "

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::FixedStar::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::FixedStar::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::FixedStar::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::FixedStar::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::FixedStar::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::FixedStar::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::computeB4vect_ipole
"";

%feature("docstring")  Gyoto::Astrobj::FixedStar::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::FixedStar::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::FixedStar::kind "

Get kind_. ";


// File: class_gyoto_1_1_astrobj_1_1_flared_disk_synchrotron.xml
%feature("docstring") Gyoto::Astrobj::FlaredDiskSynchrotron "";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::FlaredDiskSynchrotron "

Standard constructor. ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::FlaredDiskSynchrotron "

Copy constructor. ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::clone "

Cloner. ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::~FlaredDiskSynchrotron "

Destructor. ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::file "";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::file "";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::hoverR "";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::hoverR "";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::timeTranslation_inMunit "";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::timeTranslation_inMunit "";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::magnetizationParameter "";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::magnetizationParameter "";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::kappaIndex "";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::kappaIndex "";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::numberDensityMax "";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::numberDensityMax "";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::numberDensityMax "";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::numberDensityMax "";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::temperatureMax "";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::temperatureMax "";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::polytropicIndex "";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::polytropicIndex "";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::betaAtMax "";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::betaAtMax "";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::copyDensity "";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::getDensity "";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::copyVelocity "";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::getVelocity "";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::copyBvector "";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::getBvector "";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::copyTimeArray "";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::getTimeArray "";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::fitsRead
"";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::radiativeQ "

emission and transmission together ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::getVelocity "

Fluid velocity field.

Fill vel with the 4-vector velocity of the fluid at 4-position pos.

Parameters:
-----------

pos:  4-position at which to compute velocity;

vel:  4-velocity at pos. ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::metric "

Set the Metric gg_. ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::safetyValue "

Set Standard::safety_value_. ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::safetyValue "

Get Standard::safety_value_. ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::deltaInObj "

Get Generic::delta_inobj_.

Get the constant integration step inside the astrobj

delta_inobj_ in geometrical units ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::deltaInObj "

Set Generic::delta_inobj_. ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::giveDelta "

Maximum inside object.

Gives the requested integration stept (in coordinate time t) between
two neighbooring points along a portion of geodesic inside an astrobj;
the current implementation only considers a constant delta, equal to
Standard::deltaInobj()

Parameters:
-----------

coord:  input coordinate at whicht is given ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::deltaMax
"

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::showshadow "";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::showshadow "";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::redshift
"";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::redshift
"";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::processHitQuantities "

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::processHitQuantities "";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::emission
"

Specific intensity I

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem, in the emitter's frame. It should take self-absorption
along dsem into account.

Reminder : intensity = I [J m^-2 s^-1 ster^-1 Hz^-1];

invariant intensity = I/3, which has the same value in any frame;

emission coefficient = j [J m^-3 s^-1 ster^-1 Hz^-1] , defined by dI =
j*ds, where ds is the distance travelled by the photon inside the
object;

invariant emission coef = j/2, which has the same value in any frame.

The equation used for radiative transfer (without absorption) is:

d(I/3)/d = (j/2) [*]

where is the integration parameter along the null geodesic.

NB: Let us consider a particular observer, with being the frequency
measured by this observer, and ds being the proper distance (as
measured by the observer) that the photon travels as it moves from
to+d along its geodesic. Then it can be shown that:

d = ds/

This shows that Eq. [*] is homogeneous.

The default implementation returns 1. if optically thick and dsem if
optically thin. It allows for a quick implementation of your object
for visualization purposes.

Parameters:
-----------

nu_em:  Frequency at emission [Hz]

dsem:  length over which to integrate inside the object [geometrical
units]

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::emission
"

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::emission
"

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::emission
"

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::radiativeQ "";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::transmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::Omatrix
"

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::Omatrix
"";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::Omatrix
"";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::Omatrix
"";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::Pmatrix
"";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::rotateJs
"

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::rotateJs
"";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::computeB4vect_ipole "";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::getRefCount "

Get the current number of references. ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::property
"

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::kind "

Get kind_. ";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::rmin "";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::rmin "";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::rmax "";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::rmax "";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::nr "";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::nr "";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::dr "";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::dr "";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::phimin "";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::phimin "";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::phimax "";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::phimax "";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::dphi "";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::dphi "";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::tmin "";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::tmin "";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::tmax "";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::tmax "";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::nt "";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::nt "";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::nphi "";

%feature("docstring")  Gyoto::Astrobj::FlaredDiskSynchrotron::nphi "";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::getIndices "";

%feature("docstring")
Gyoto::Astrobj::FlaredDiskSynchrotron::interpolate "";


// File: class_gyoto_1_1_astrobj_1_1_free_star.xml
%feature("docstring") Gyoto::Astrobj::FreeStar "

UniformShere following a trajectory specified in getVelocity (non-
geodesic) with a constant velocity.

C++ includes: GyotoFreeStar.h ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::FreeStar "

Default constructor.

Create FreeStar object with undefined initial conditions. One needs to
set the coordinate system, the metric, and the initial position and
velocity before integrating the orbit. initCoord() can be used for
that. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::FreeStar "

Copy constructor. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::clone "

Cloner.

This method must be implemented by the various Astrobj::Generic
subclasses in order to support cloning:

Cloning is necessary for multi-threading, recommended for interaction
with the Yorick plug-in etc.

Implementing it is very straightforward, as long as the copy
constructor Generic(const Generic& ) has been implemented: ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::~FreeStar "

Destructor. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::className "

\"FreeStar\" ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::className_l "

\"free_star\" ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::initPosition "";

%feature("docstring")  Gyoto::Astrobj::FreeStar::initPosition "";

%feature("docstring")  Gyoto::Astrobj::FreeStar::initVelocity "";

%feature("docstring")  Gyoto::Astrobj::FreeStar::initVelocity "";

%feature("docstring")  Gyoto::Astrobj::FreeStar::initCoord "";

%feature("docstring")  Gyoto::Astrobj::FreeStar::initCoord "";

%feature("docstring")  Gyoto::Astrobj::FreeStar::getCartesian "

Yield the Cartesian coordinates of the center of the sphere.

If the coordinate system of the Metric object is spherical, use a
trivial conversion. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::getVelocity "

Yield velocity of the center of the sphere. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::spectrum "

Set spectrum_. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::spectrum "

Get spectrum_. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::opacity "

Set opacity_. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::opacity "

Get opacity_. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::radius "

Get radius_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::radius "

Set radius_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::radius "

Get radius_ in specified unit. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::radius "

Set radius_ in specified unit. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::deltaMaxOverRadius "

Get dltmor_. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::deltaMaxOverRadius "

Set dltmor_. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::deltaMaxOverDistance
"

Get dltmod_. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::deltaMaxOverDistance
"

Set dltmod_. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::isotropic "";

%feature("docstring")  Gyoto::Astrobj::FreeStar::isotropic "";

%feature("docstring")  Gyoto::Astrobj::FreeStar::alpha "";

%feature("docstring")  Gyoto::Astrobj::FreeStar::alpha "";

%feature("docstring")  Gyoto::Astrobj::FreeStar::deltaMax "

Parameters:

coord:  current photon position

max( dltmor_* radius_, dltmod_*operator()(double coord[]) ) ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")  Gyoto::Astrobj::FreeStar::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::safetyValue "

Set Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::safetyValue "

Get Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::deltaInObj "

Get Generic::delta_inobj_.

Get the constant integration step inside the astrobj

delta_inobj_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::deltaInObj "

Set Generic::delta_inobj_. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::giveDelta "

Maximum inside object.

Gives the requested integration stept (in coordinate time t) between
two neighbooring points along a portion of geodesic inside an astrobj;
the current implementation only considers a constant delta, equal to
Standard::deltaInobj()

Parameters:
-----------

coord:  input coordinate at whicht is given ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")
Gyoto::Astrobj::FreeStar::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::FreeStar::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::showshadow "";

%feature("docstring")  Gyoto::Astrobj::FreeStar::showshadow "";

%feature("docstring")  Gyoto::Astrobj::FreeStar::redshift "";

%feature("docstring")  Gyoto::Astrobj::FreeStar::redshift "";

%feature("docstring")  Gyoto::Astrobj::FreeStar::getDefaultQuantities
"

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::processHitQuantities
"

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::processHitQuantities
"";

%feature("docstring")  Gyoto::Astrobj::FreeStar::radiativeQ "

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::FreeStar::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::FreeStar::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::FreeStar::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::FreeStar::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::FreeStar::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::FreeStar::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::computeB4vect_ipole "";

%feature("docstring")  Gyoto::Astrobj::FreeStar::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::FreeStar::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::FreeStar::kind "

Get kind_. ";


// File: class_gyoto_1_1_astrobj_1_1_generic.xml
%feature("docstring") Gyoto::Astrobj::Generic "

Base class for astronomical object.

See introduction in the Gyoto::Astrobj namespace.

C++ includes: GyotoAstrobj.h ";

%feature("docstring")  Gyoto::Astrobj::Generic::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Astrobj::Generic::Generic "

Default constructor.

kind_ = \"Default\", rmax_ = DBL_MAX ";

%feature("docstring")  Gyoto::Astrobj::Generic::Generic "

Set rmax in constructor.

kind_ = \"Default\", rmax_ = radmax ";

%feature("docstring")  Gyoto::Astrobj::Generic::Generic "

Set kind in constructor.

kind_ = kind, rmax_ = DBL_MAX ";

%feature("docstring")  Gyoto::Astrobj::Generic::Generic "

Copy constructor.

Make a deep copy of an Astrobj::Generic instance ";

%feature("docstring")  Gyoto::Astrobj::Generic::clone "

Cloner.

This method must be implemented by the various Astrobj::Generic
subclasses in order to support cloning:

Cloning is necessary for multi-threading, recommended for interaction
with the Yorick plug-in etc.

Implementing it is very straightforward, as long as the copy
constructor Generic(const Generic& ) has been implemented: ";

%feature("docstring")  Gyoto::Astrobj::Generic::~Generic "

Destructor: does nothing. ";

%feature("docstring")  Gyoto::Astrobj::Generic::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::Generic::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::Generic::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Generic::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::Generic::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::Generic::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::Generic::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")  Gyoto::Astrobj::Generic::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::Generic::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")
Gyoto::Astrobj::Generic::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::Generic::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")  Gyoto::Astrobj::Generic::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::Generic::showshadow "";

%feature("docstring")  Gyoto::Astrobj::Generic::showshadow "";

%feature("docstring")  Gyoto::Astrobj::Generic::redshift "";

%feature("docstring")  Gyoto::Astrobj::Generic::redshift "";

%feature("docstring")  Gyoto::Astrobj::Generic::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")  Gyoto::Astrobj::Generic::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")  Gyoto::Astrobj::Generic::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::Generic::processHitQuantities "

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")  Gyoto::Astrobj::Generic::processHitQuantities "";

%feature("docstring")  Gyoto::Astrobj::Generic::emission "

Specific intensity I

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem, in the emitter's frame. It should take self-absorption
along dsem into account.

Reminder : intensity = I [J m^-2 s^-1 ster^-1 Hz^-1];

invariant intensity = I/3, which has the same value in any frame;

emission coefficient = j [J m^-3 s^-1 ster^-1 Hz^-1] , defined by dI =
j*ds, where ds is the distance travelled by the photon inside the
object;

invariant emission coef = j/2, which has the same value in any frame.

The equation used for radiative transfer (without absorption) is:

d(I/3)/d = (j/2) [*]

where is the integration parameter along the null geodesic.

NB: Let us consider a particular observer, with being the frequency
measured by this observer, and ds being the proper distance (as
measured by the observer) that the photon travels as it moves from
to+d along its geodesic. Then it can be shown that:

d = ds/

This shows that Eq. [*] is homogeneous.

The default implementation returns 1. if optically thick and dsem if
optically thin. It allows for a quick implementation of your object
for visualization purposes.

Parameters:
-----------

nu_em:  Frequency at emission [Hz]

dsem:  length over which to integrate inside the object [geometrical
units]

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position ";

%feature("docstring")  Gyoto::Astrobj::Generic::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::Generic::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::Generic::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Generic::radiativeQ "

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::Generic::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::Generic::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")  Gyoto::Astrobj::Generic::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")  Gyoto::Astrobj::Generic::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Generic::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")  Gyoto::Astrobj::Generic::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Generic::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Generic::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Generic::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Generic::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Generic::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Generic::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Generic::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Generic::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::Generic::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::Generic::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::Generic::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::Generic::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::Generic::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")  Gyoto::Astrobj::Generic::computeB4vect_ipole "";

%feature("docstring")  Gyoto::Astrobj::Generic::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::Generic::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::Generic::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::Generic::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::Generic::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::Generic::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::Generic::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Generic::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Generic::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Generic::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Generic::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Generic::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Generic::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::Generic::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::Generic::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::Generic::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Astrobj::Generic::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Astrobj::Generic::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Astrobj::Generic::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Astrobj::Generic::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::Generic::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::Generic::kind "

Get kind_. ";


// File: class_gyoto_1_1_metric_1_1_generic.xml
%feature("docstring") Gyoto::Metric::Generic "

Base class for metrics.

Example: class Gyoto::Metric::KerrBL

See Gyoto::Metric for an introduction.

C++ includes: GyotoMetric.h ";

%feature("docstring")  Gyoto::Metric::Generic::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Metric::Generic::getRefCount "";

%feature("docstring")  Gyoto::Metric::Generic::Generic "";

%feature("docstring")  Gyoto::Metric::Generic::Generic "

Constructor setting Generic::coordkind_ and kind_. ";

%feature("docstring")  Gyoto::Metric::Generic::Generic "

Copy constructor. ";

%feature("docstring")  Gyoto::Metric::Generic::~Generic "

Destructor. ";

%feature("docstring")  Gyoto::Metric::Generic::clone "

Virtual copy constructor. ";

%feature("docstring")  Gyoto::Metric::Generic::mass "

Set mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::Generic::mass "

Set mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::Generic::coordKind "

Get coordinate kind. ";

%feature("docstring")  Gyoto::Metric::Generic::mass "

Get mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::Generic::mass "

Get mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::Generic::unitLength "

M * G / c^2, M is in kg, unitLength in meters.

Metrics implementations are free to express lengths and distances in
whatever unit they see fit (presumably most often geometrical units).
This function returns this unit in SI (meters). ";

%feature("docstring")  Gyoto::Metric::Generic::unitLength "

unitLength expressed in specified unit ";

%feature("docstring")  Gyoto::Metric::Generic::getRmb "

Returns the marginally bound radius Should be implemented in derived
classes if useful If called on the base class, returns an error ";

%feature("docstring")  Gyoto::Metric::Generic::getRms "

Returns the marginally stable (ISCO) radius Should be implemented in
derived classes if useful If called on the base class, returns an
error ";

%feature("docstring")
Gyoto::Metric::Generic::getSpecificAngularMomentum "

Returns the specific angular momentum l=-u_phi/u_t Should be
implemented in derived classes if useful If called on the base class,
returns an error ";

%feature("docstring")  Gyoto::Metric::Generic::getPotential "

Returns potential W=-ln(|u_t|) for a cst specific angular momentum
l_cst Should be implemented in derived classes if useful If called on
the base class, returns an error ";

%feature("docstring")  Gyoto::Metric::Generic::deltaMin "

Get delta_min_ ";

%feature("docstring")  Gyoto::Metric::Generic::deltaMin "

Set delta_min_ ";

%feature("docstring")  Gyoto::Metric::Generic::deltaMax "

Get delta_max_ ";

%feature("docstring")  Gyoto::Metric::Generic::deltaMax "

Get delta max at a given position

Parameters:
-----------

pos:  4-position

[optional]:  delta_max_external external constraint on delta_max

the smallest value between delta_max_, delta_max_external, and
R*delta_max_over_r_ where R is pos[1] in spherical coordinates and
max(x1, x2, x3) in Cartesian coordinates. ";

%feature("docstring")  Gyoto::Metric::Generic::deltaMax "

Set delta_max_ ";

%feature("docstring")  Gyoto::Metric::Generic::deltaMaxOverR "

Get delta_max_over_r_. ";

%feature("docstring")  Gyoto::Metric::Generic::deltaMaxOverR "

Set delta_max_over_r_. ";

%feature("docstring")  Gyoto::Metric::Generic::keplerian "

Get keplerian_. ";

%feature("docstring")  Gyoto::Metric::Generic::keplerian "

Set keplerian_. ";

%feature("docstring")  Gyoto::Metric::Generic::cartesianVelocity "

Compute xprime, yprime and zprime from 8-coordinates. ";

%feature("docstring")  Gyoto::Metric::Generic::SysPrimeToTdot "

Compute tdot as a function of dr/dt, dtheta/dt and dphi/dt. Everything
is in geometrical units.

Parameters:
-----------

coord:  4-position (geometrical units);

v:  3-velocity dx1/dx0, dx2/dx0, dx3/dx0;

tdot = dx0/dtau. ";

%feature("docstring")  Gyoto::Metric::Generic::circularVelocity "

Yield circular velocity at a given position.

Give the velocity of a massive particle in circular orbit at the given
position projected onto the equatorial plane. Such a velocity may not
exist everywhere (or anywhere) for a given metric. This method is
intended to be used by Astrobj classes such as Torus or ThinDisk.

If keplerian_ is set to true, this method should return the Keplerian
velcity instead (derived classes should ensure this, see
KerrBL::circularVelocity() for instance).

The default implementation throws an error if keplerian_ is set to
false.

Parameters:
-----------

pos:  input: position,

vel:  output: velocity,

dir:  1 for corotating, -1 for counterrotating. ";

%feature("docstring")  Gyoto::Metric::Generic::zamoVelocity "

Yield ZAMO velocity at a given position.

Give the velocity of a zero angular momentul observer (whatever is
closest to \"at rest\"). The default implementation simply projects
(1, 0, 0, 0) othogonally along ephi and normalizes it, thus ensuring
that vel is orthogonal to ephi.

Parameters:
-----------

pos:  input: position,

vel:  output: velocity, ";

%feature("docstring")  Gyoto::Metric::Generic::nullifyCoord "

Set tdot (coord[4]) such that coord is light-like. Everything is in
geometrical units.

Set coord[4] so that the 4-velocity coord[4:7] is lightlike, i.e. of
norm 0. There may be up to two solutions. coord[4] is set to the
hightest. The lowest can be retrieved using nullifyCoord(double
coord[8], double& tdot2) const. Everything is expressed in geometrical
units.

Parameters:
-----------

coord:  8-position, coord[4] will be set according to the other
elements; ";

%feature("docstring")  Gyoto::Metric::Generic::nullifyCoord "

Set tdot (coord[4]) such that coord is light-like and return other
possible tdot.

Set coord[4] so that the 4-velocity coord[4:7] is lightlike, i.e. of
norm 0. There may be up to two solutions. coord[4] is set to the
hightest. The lowest can be retrieved in tdot2. Everything is
expressed in geometrical units.

Parameters:
-----------

coord:  8-position, coord[4] will be set according to the other
elements;

tdot2:  will be set to the smallest solution ";

%feature("docstring")  Gyoto::Metric::Generic::normalizeFourVel "

Normalize fourvelvel to -1.

First computes threevel as xiprime=xidot/x0dot for i in {1, 2, 3},
then computes x0dot using SyPrimeToTdot, then computes again xidot as
xidot=xiprime*x0dot.

Parameters:
-----------

coord:  8-position, coord[4-7] will be set according to the other
elements; ";

%feature("docstring")  Gyoto::Metric::Generic::normalizeFourVel "

Normalize fourvelvel to -1.

First computes threevel as xiprime=xidot/x0dot for i in {1, 2, 3},
then computes x0dot using SyPrimeToTdot, then computes again xidot as
xidot=xiprime*x0dot.

Parameters:
-----------

pos:  4-position;

fourvel:  4-velocity, will be renormalized. ";

%feature("docstring")  Gyoto::Metric::Generic::ScalarProd "

Scalar product.

Compute the scalarproduct of the two quadrivectors u1 and u2 in this
Metric, at point pos expressed in coordinate system sys.

Parameters:
-----------

pos:  4-position;

u1:  1st quadrivector;

u2:  2nd quadrivector;

u1*u2 ";

%feature("docstring")  Gyoto::Metric::Generic::norm "

Scalar product.

Compute the norm of the quadrivector u1 in this Metric, at point pos
expressed in coordinate system sys.

Parameters:
-----------

pos:  4-position;

u1:  quadrivector;

||u1|| ";

%feature("docstring")  Gyoto::Metric::Generic::multiplyFourVect "

multiply vector by scalar ";

%feature("docstring")  Gyoto::Metric::Generic::addFourVect "

add second vector to first one ";

%feature("docstring")  Gyoto::Metric::Generic::projectFourVect "

project u1 orthogonally to u2 at pos ";

%feature("docstring")  Gyoto::Metric::Generic::dualOneForm "

Computes dual 1-form Compute the dual 1-form of 4-vector.

Parameters:
-----------

IN_ARRAY1_1:  4-position;

IN_ARRAY1_2:  quadrivector;

ARGOUT_ARRAY1:  output 1-form ";

%feature("docstring")  Gyoto::Metric::Generic::observerTetrad "

Computes the orthonormal local tetrad of the observer.

Parameters:
-----------

obskind:  input: kind of observer (eg:
\"ZAMO\",\"KeplerianObserver\"...)

pos:  input: position,

fourvel:  output: observer 4-velocity (norm -1)

screen1:  output: first vector in the screen plane

screen2:  output: second vector in the screen plane

screen3:  output: vector normal to the screen ";

%feature("docstring")  Gyoto::Metric::Generic::observerTetrad "

Computes the orthonormal local tetrad of the observer.

Parameters:
-----------

pos:  position,

fourvel:  observer 4-velocity (norm -1)

screen1:  first vector in the screen plane

screen2:  second vector in the screen plane

screen3:  vector normal to the screen ";

%feature("docstring")  Gyoto::Metric::Generic::GramSchmidt "

Apply Gram-Schmidt orthonormalization to a basis.

On input, u0 to u3 must be four non-zero norm, independent 4-vectors.
On output, they will form an orthonormal basis.

Parameters:
-----------

pos:  position,

u0:  basis vector

u1:  basis vector

u2:  basis vector

u3:  basis vector ";

%feature("docstring")  Gyoto::Metric::Generic::gmunu "

Metric coefficients.

The default implementation calls Metric:: gmunu(double g[4][4], const
double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::Generic::gmunu "

Metric coefficients.

The default implementation calls double gmunu(const double * x, int
mu, int nu) const.

Parameters:
-----------

ARGOUT_ARRAY2:  (g) 4x4 array to store the coeefficients

IN_ARRAY1:  (x) 4-position at which to compute the coefficients;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::Generic::gmunu_up "

Metric contravariant coefficients.

The default implementation calls Metric:: gmunu_up(double g[4][4],
const double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::Generic::gmunu_up "

Metric contravariant coefficients.

The default implementation inverts the covariant coefficients matrix.
";

%feature("docstring")  Gyoto::Metric::Generic::jacobian "

Derivatives of the metric covariant coefficients.

The default implementation evaluates them numerically. The gmunu
matrix is assumed to be symmetrical but no other assumptions are made
at the moment. ";

%feature("docstring")  Gyoto::Metric::Generic::gmunu_up_and_jacobian "

gmunu_up() and jacobian() in one go ";

%feature("docstring")  Gyoto::Metric::Generic::computeNBeta "

Computes lapse scalar and shift vector at coord. ";

%feature("docstring")  Gyoto::Metric::Generic::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3). ";

%feature("docstring")  Gyoto::Metric::Generic::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3).

1 on error, 0 otherwise ";

%feature("docstring")  Gyoto::Metric::Generic::myrk4 "

RK4 integrator. ";

%feature("docstring")  Gyoto::Metric::Generic::myrk4 "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::Generic::myrk4_adaptive "

RK4 integrator with adaptive step. ";

%feature("docstring")  Gyoto::Metric::Generic::myrk4_adaptive "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::Generic::isStopCondition "

Check whether integration should stop.

The integrating loop will ask this the Metric through this method
whether or not it is happy to continue the integration. Typically, the
Metric should answer 0 when everything is fine, 1 when too close to
the event horizon, inside the BH...

Parameters:
-----------

coord:  8-coordinate vector to check. ";

%feature("docstring")  Gyoto::Metric::Generic::diff "

F function such as dx/dt=F(x,cst) ";

%feature("docstring")  Gyoto::Metric::Generic::diff "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::Generic::diff "";

%feature("docstring")  Gyoto::Metric::Generic::diff31 "

F function such as dx/dt=F(x,cst) for 3+1 case. ";

%feature("docstring")  Gyoto::Metric::Generic::setParticleProperties "

Set Metric-specific constants of motion. Used e.g. in KerrBL. ";

%feature("docstring")  Gyoto::Metric::Generic::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Metric::Generic::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Metric::Generic::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Metric::Generic::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Metric::Generic::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Metric::Generic::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Metric::Generic::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Metric::Generic::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Metric::Generic::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Metric::Generic::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Metric::Generic::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Metric::Generic::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Metric::Generic::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Metric::Generic::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Metric::Generic::setParameters "

Main loop for parsing Properties from XML description.

This function queries the FactoryMessenger for elements to parse, and
tries to matche each element to a Property to set it  accordingly. Any
class that tries to be buildable from XML must supply a subcontractor
(for base classes such as Metric, Astrobj, Spectrum  and Spectrometer,
it is done as a template that must be  specialized for each class).
This subcontractor typically looks somewhat like this: Although this
is discouraged, it is possible to override the following functions to
customize how XML entities are parsed:    - setParameters() if low-
level access to the      FactoryMessenger is required;    -
setParameter(std::string name, std::string content,
std::string unit)      to interpret an entity that does not match a
Property      (e.g. alternative name);    -
setParameter(Gyoto::Property const &p, std::string const &name,
std::string const &content, std::string const &unit)      to change
how a Property is interpreted. ";

%feature("docstring")  Gyoto::Metric::Generic::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Metric::Generic::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Metric::Generic::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Metric::Generic::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Metric::Generic::kind "

Get kind_. ";

%feature("docstring")  Gyoto::Metric::Generic::hook "

Start listening.

Use from a Hook::Listener object method: where \"this\" is a Listener
and \"teller\" is a Teller.

Use unhook() later to stop listening to a given Teller.

Parameters:
-----------

listener:  pointer to the new listener ";

%feature("docstring")  Gyoto::Metric::Generic::unhook "

Stop listening.

Use from a Hook::Listener object method:

where \"this\" is a Listener, \"teller\" is a Teller, and \"this\" has
called teller->hook(this) previously.

Parameters:
-----------

listener:  pointer to the listener ";


// File: class_gyoto_1_1_spectrometer_1_1_generic.xml
%feature("docstring") Gyoto::Spectrometer::Generic "

Base class for spectrometers.

Example: class Gyoto::Spectrometer::Uniform

See Gyoto::Spectrometer for an introduction.

Generic inherits from Gyoto::SmartPointee so that it is possible to
create a SmartPointer to a Spectrometer.

It also inherits from Gyoto::Hook::Teller. This allows a consistent
implementation of Spectrometer::Complex (in particular). Any method
which mutates a Spectrometer should call tellListeners().

C++ includes: GyotoSpectrometer.h ";

%feature("docstring")  Gyoto::Spectrometer::Generic::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Spectrometer::Generic::Generic "

Default constructor.

Sets each member to 0. ";

%feature("docstring")  Gyoto::Spectrometer::Generic::Generic "

Constructor setting kindid.

Sets the other members to 0. This is usually the right constructor to
use:

Always set kindid to the address of a static variable, not to a
temporary. Usually your class should have a static member for that
purpose: ";

%feature("docstring")  Gyoto::Spectrometer::Generic::Generic "

Copy constructor.

Takes care of (deep) copying all the members known to the base class.
";

%feature("docstring")  Gyoto::Spectrometer::Generic::clone "

Clone an instance.

Use this to get a deep copy of an instance;

Most implementations will use the copy constructor: ";

%feature("docstring")  Gyoto::Spectrometer::Generic::~Generic "

Destructor.

Takes care of deleting the arrays (if the pointers are not NULL). ";

%feature("docstring")  Gyoto::Spectrometer::Generic::kindid "

Get kindid_.

You can check whether the Spectrometer sp is of a given kind MyKind
with something like:

See Uniform::WaveKind, Uniform::WaveLogKind, Uniform::FreqKind,
Uniform::FreqLogKind and Complex::Kind. ";

%feature("docstring")  Gyoto::Spectrometer::Generic::kindid "

Set Generic::kindid_.

This should rarely be used as the Generic::kindid_ attribute usually
is set in the constructor and doesn't change after that.

Always set to the address of a static variable, not to a temporary.
Usually your class should have a static member for that purpose: ";

%feature("docstring")  Gyoto::Spectrometer::Generic::nSamples "

Get Generic::nsamples_. ";

%feature("docstring")  Gyoto::Spectrometer::Generic::getNBoundaries "

Get Generic::nboundaries_. ";

%feature("docstring")  Gyoto::Spectrometer::Generic::getMidpoints "

Get Generic::midpoints_. ";

%feature("docstring")  Gyoto::Spectrometer::Generic::getMidpoints "

Copy Generic::midpoints_, converting to unit.

Parameters:
-----------

data:  an array of Generic::nsamples_ doubles to fill with result

unit:  a string ";

%feature("docstring")
Gyoto::Spectrometer::Generic::getChannelBoundaries "

Copy Generic::boundaries_, converting to unit.

Parameters:
-----------

data:  an array of Generic::nboundaries_ doubles to fill with result

unit:  a string ";

%feature("docstring")
Gyoto::Spectrometer::Generic::getChannelBoundaries "

Get Generic::boundaries_. ";

%feature("docstring")  Gyoto::Spectrometer::Generic::getChannelIndices
"

Get Generic::chanind_. ";

%feature("docstring")  Gyoto::Spectrometer::Generic::getWidths "

Get Generic::widths_. ";

%feature("docstring")  Gyoto::Spectrometer::Generic::getWidths "

Copy Generic::widths_, converting to unit.

Think carefully before using: widths are often used to convert
spectral flux density to flux. If flux density is per Herz, you don't
need to convert widths.

Parameters:
-----------

data:  an array of Generic::nboundaries_ doubles to fill with result

unit:  a string ";

%feature("docstring")  Gyoto::Spectrometer::Generic::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Spectrometer::Generic::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Spectrometer::Generic::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Spectrometer::Generic::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Spectrometer::Generic::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Spectrometer::Generic::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Spectrometer::Generic::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Spectrometer::Generic::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Spectrometer::Generic::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Spectrometer::Generic::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Spectrometer::Generic::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Spectrometer::Generic::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Spectrometer::Generic::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Spectrometer::Generic::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Spectrometer::Generic::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Spectrometer::Generic::setParameters "

Main loop for parsing Properties from XML description.

This function queries the FactoryMessenger for elements to parse, and
tries to matche each element to a Property to set it  accordingly. Any
class that tries to be buildable from XML must supply a subcontractor
(for base classes such as Metric, Astrobj, Spectrum  and Spectrometer,
it is done as a template that must be  specialized for each class).
This subcontractor typically looks somewhat like this: Although this
is discouraged, it is possible to override the following functions to
customize how XML entities are parsed:    - setParameters() if low-
level access to the      FactoryMessenger is required;    -
setParameter(std::string name, std::string content,
std::string unit)      to interpret an entity that does not match a
Property      (e.g. alternative name);    -
setParameter(Gyoto::Property const &p, std::string const &name,
std::string const &content, std::string const &unit)      to change
how a Property is interpreted. ";

%feature("docstring")  Gyoto::Spectrometer::Generic::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Spectrometer::Generic::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Spectrometer::Generic::describeProperty
"

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Spectrometer::Generic::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Spectrometer::Generic::kind "

Get kind_. ";

%feature("docstring")  Gyoto::Spectrometer::Generic::hook "

Start listening.

Use from a Hook::Listener object method: where \"this\" is a Listener
and \"teller\" is a Teller.

Use unhook() later to stop listening to a given Teller.

Parameters:
-----------

listener:  pointer to the new listener ";

%feature("docstring")  Gyoto::Spectrometer::Generic::unhook "

Stop listening.

Use from a Hook::Listener object method:

where \"this\" is a Listener, \"teller\" is a Teller, and \"this\" has
called teller->hook(this) previously.

Parameters:
-----------

listener:  pointer to the listener ";


// File: class_gyoto_1_1_spectrum_1_1_generic.xml
%feature("docstring") Gyoto::Spectrum::Generic "

Spectrum emitted by an Astrobj.

Light emitted by e.g. a Star

C++ includes: GyotoSpectrum.h ";

%feature("docstring")  Gyoto::Spectrum::Generic::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Spectrum::Generic::Generic "";

%feature("docstring")  Gyoto::Spectrum::Generic::Generic "

Set kind in constructor. ";

%feature("docstring")  Gyoto::Spectrum::Generic::Generic "";

%feature("docstring")  Gyoto::Spectrum::Generic::clone "

Cloner. ";

%feature("docstring")  Gyoto::Spectrum::Generic::~Generic "

Destructor: does nothing. ";

%feature("docstring")  Gyoto::Spectrum::Generic::integrate "

Integrate optically thick I_nu.

See operator()(double nu) const

Parameters:
-----------

nu1:  nu2:  boundaries for the integration

I, the integral of I_nu between nu1 and nu2 ";

%feature("docstring")  Gyoto::Spectrum::Generic::integrate "

Integrate optically thin I_nu.

See operator()(double nu, double opacity, double ds) const

Parameters:
-----------

nu1:  nu2:  boundaries for the integration

opacity:  the frequency-dependent opacity law given as a pointer to a
Gyoto::Spectrum::Generic sub-class instance

ds:  the element length for spatial integration

I, the integral of I_nu between nu1 and nu2 ";

%feature("docstring")  Gyoto::Spectrum::Generic::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Spectrum::Generic::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Spectrum::Generic::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Spectrum::Generic::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Spectrum::Generic::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Spectrum::Generic::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Spectrum::Generic::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Spectrum::Generic::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Spectrum::Generic::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Spectrum::Generic::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Spectrum::Generic::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Spectrum::Generic::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Spectrum::Generic::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Spectrum::Generic::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Spectrum::Generic::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Spectrum::Generic::setParameters "

Main loop for parsing Properties from XML description.

This function queries the FactoryMessenger for elements to parse, and
tries to matche each element to a Property to set it  accordingly. Any
class that tries to be buildable from XML must supply a subcontractor
(for base classes such as Metric, Astrobj, Spectrum  and Spectrometer,
it is done as a template that must be  specialized for each class).
This subcontractor typically looks somewhat like this: Although this
is discouraged, it is possible to override the following functions to
customize how XML entities are parsed:    - setParameters() if low-
level access to the      FactoryMessenger is required;    -
setParameter(std::string name, std::string content,
std::string unit)      to interpret an entity that does not match a
Property      (e.g. alternative name);    -
setParameter(Gyoto::Property const &p, std::string const &name,
std::string const &content, std::string const &unit)      to change
how a Property is interpreted. ";

%feature("docstring")  Gyoto::Spectrum::Generic::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Spectrum::Generic::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Spectrum::Generic::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Spectrum::Generic::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Spectrum::Generic::kind "

Get kind_. ";


// File: class_gyoto_1_1_worldline_1_1_integ_state_1_1_generic.xml
%feature("docstring") Gyoto::Worldline::IntegState::Generic "

Current state of a geodesic integration.

C++ includes: GyotoWorldline.h ";

%feature("docstring")  Gyoto::Worldline::IntegState::Generic::Generic
"

Normal constructor.

Sets line_ ";

%feature("docstring")  Gyoto::Worldline::IntegState::Generic::~Generic
"

Virtual destructor. ";

%feature("docstring")  Gyoto::Worldline::IntegState::Generic::clone "

Deep copy.

Derived classes must implement it ";

%feature("docstring")  Gyoto::Worldline::IntegState::Generic::init "

Parameters:

line:  The Worldline that we are integrating. Sets: Worldline::line_,
Worldline::gg_, Worldline::adaptive_.

coord:  Initial coordinate.

delta:  Integration step. Sign determines direction. ";

%feature("docstring")  Gyoto::Worldline::IntegState::Generic::init "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Worldline::IntegState::Generic::init "

Cache whatever needs to be cached.

This is called by all the methods in Worldline each time an member
that could be cached in Worldline::state_ changes. Therefore, user
code should normally not have to call it. ";

%feature("docstring")
Gyoto::Worldline::IntegState::Generic::checkNorm "

Check norm.

Issue a warning using GYOTO_SEVERE if norm is drifting. nextStep()
implementations should call it. ";

%feature("docstring")  Gyoto::Worldline::IntegState::Generic::kind "

Return the integrator kind. ";

%feature("docstring")  Gyoto::Worldline::IntegState::Generic::integ31
"

Defines the kind of geodesic equation to integrate (3+1, 4D) ";

%feature("docstring")  Gyoto::Worldline::IntegState::Generic::integ31
"";

%feature("docstring")  Gyoto::Worldline::IntegState::Generic::nextStep
"

Make one step.

Parameters:
-----------

coord:  Next position-velocity;

tau:  Next proper time or affine parameter

h1max:  maximum step in case of adaptive integration ";

%feature("docstring")  Gyoto::Worldline::IntegState::Generic::nextStep
"

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Worldline::IntegState::Generic::doStep "

Make one step of exactly this size.

doStep() is meant to refine a computation made using nextStep(). In
particular, there is no checking for norm conservation.

Parameters:
-----------

coordin:  current position-velocity;

step:  exact step to use.

coordout:  next position-velocity; ";

%feature("docstring")  Gyoto::Worldline::IntegState::Generic::doStep "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Worldline::IntegState::Generic::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")
Gyoto::Worldline::IntegState::Generic::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")
Gyoto::Worldline::IntegState::Generic::getRefCount "

Get the current number of references. ";


// File: union_gyoto_1_1_property_1_1getter__t.xml


// File: union_gyoto_1_1_property_1_1getter__unit__t.xml


// File: class_gyoto_1_1_screen_1_1_grid.xml
%feature("docstring") Grid "

Class containing 2D-points organized in a grid.

C++ includes: GyotoScreen.h ";

%feature("docstring")  Grid::Grid "";

%feature("docstring")  Grid::~Grid "";

%feature("docstring")  Grid::begin "

Reset pointer. ";

%feature("docstring")  Grid::valid "

Whether the end has not been passed. ";

%feature("docstring")  Grid::size "

Number of positions contained. ";

%feature("docstring")  Grid::angles "

Get angle coordinates. ";


// File: class_gyoto_1_1_grid_data2_d.xml
%feature("docstring") Gyoto::GridData2D "

Class for reading data stored in a 2D grid.

C++ includes: GyotoFitsRW.h ";

%feature("docstring")  Gyoto::GridData2D::GridData2D "

Constructor. ";

%feature("docstring")  Gyoto::GridData2D::GridData2D "

Copy constructor. ";

%feature("docstring")  Gyoto::GridData2D::clone "";

%feature("docstring")  Gyoto::GridData2D::~GridData2D "

Destructor. ";

%feature("docstring")  Gyoto::GridData2D::rmin "";

%feature("docstring")  Gyoto::GridData2D::rmin "";

%feature("docstring")  Gyoto::GridData2D::rmax "";

%feature("docstring")  Gyoto::GridData2D::rmax "";

%feature("docstring")  Gyoto::GridData2D::nr "";

%feature("docstring")  Gyoto::GridData2D::nr "";

%feature("docstring")  Gyoto::GridData2D::dr "";

%feature("docstring")  Gyoto::GridData2D::dr "";

%feature("docstring")  Gyoto::GridData2D::phimin "";

%feature("docstring")  Gyoto::GridData2D::phimin "";

%feature("docstring")  Gyoto::GridData2D::phimax "";

%feature("docstring")  Gyoto::GridData2D::phimax "";

%feature("docstring")  Gyoto::GridData2D::dphi "";

%feature("docstring")  Gyoto::GridData2D::dphi "";

%feature("docstring")  Gyoto::GridData2D::tmin "";

%feature("docstring")  Gyoto::GridData2D::tmin "";

%feature("docstring")  Gyoto::GridData2D::tmax "";

%feature("docstring")  Gyoto::GridData2D::tmax "";

%feature("docstring")  Gyoto::GridData2D::nt "";

%feature("docstring")  Gyoto::GridData2D::nt "";

%feature("docstring")  Gyoto::GridData2D::nphi "";

%feature("docstring")  Gyoto::GridData2D::nphi "";

%feature("docstring")  Gyoto::GridData2D::getIndices "";

%feature("docstring")  Gyoto::GridData2D::interpolate "";


// File: class_g_y_o_t_o___a_r_r_a_y.xml
%feature("docstring") GYOTO_ARRAY "";


// File: class_gyoto_1_1_metric_1_1_hayward.xml
%feature("docstring") Gyoto::Metric::Hayward "

Metric of a regular rotating black hole or naked worm-hole.

This is a regular rotating extension of Hayward's metric.

The metric reads:
ds^2=-(1-2*M(r)*r/Sigma)*dt^2-(4*a*M(r)*sin^2(theta)/Sigma)*dt*dphi+(Sigma/Delta)*dr^2+(Sigma)*dtheta^2+sin^2(theta)*[r^2+a^2+2*a^2*r*M(r)*sin^2(theta)/Sigma]*dphi^2,
where: Sigma=r^2+a^2*cos^2(theta) Delta=r^2-2*M(r)*r+a^2
M(r)=M*abs(r)^3/(abs(r)^3+2*m*b^2), m being the mass of the black hole
seen at infinity and b a magnetic charge parameter.

See Lamy et al. (2018), Classical and Quantum Gravity,
submitted,https://arxiv.org/abs/1802.01635

See Hayward (2006) for the original nonrotating
metric,https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.96.031103

See Bambi & Modesto (2013) for a rotating (but singular)
extension.https://www.sciencedirect.com/science/article/pii/S0370269313002505?via%3Dihub

C++ includes: GyotoHayward.h ";

%feature("docstring")  Gyoto::Metric::Hayward::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Metric::Hayward::Hayward "

Default constructor. ";

%feature("docstring")  Gyoto::Metric::Hayward::clone "

Virtual copy constructor. ";

%feature("docstring")  Gyoto::Metric::Hayward::spin "

Set spin. ";

%feature("docstring")  Gyoto::Metric::Hayward::spin "

Returns spin. ";

%feature("docstring")  Gyoto::Metric::Hayward::charge "

Set charge. ";

%feature("docstring")  Gyoto::Metric::Hayward::charge "

Returns charge. ";

%feature("docstring")
Gyoto::Metric::Hayward::getSpecificAngularMomentum "

Returns the specific angular momentum l=-u_phi/u_t Should be
implemented in derived classes if useful If called on the base class,
returns an error ";

%feature("docstring")  Gyoto::Metric::Hayward::getPotential "

Returns potential W=-ln(|u_t|) for a cst specific angular momentum
l_cst Should be implemented in derived classes if useful If called on
the base class, returns an error ";

%feature("docstring")  Gyoto::Metric::Hayward::circularVelocity "

Yield circular velocity at a given position.

Give the velocity of a massive particle in circular orbit at the given
position projected onto the equatorial plane. Such a velocity may not
exist everywhere (or anywhere) for a given metric. This method is
intended to be used by Astrobj classes such as Torus or ThinDisk.

If keplerian_ is set to true, this method should return the Keplerian
velcity instead (derived classes should ensure this, see
KerrBL::circularVelocity() for instance).

The default implementation throws an error if keplerian_ is set to
false.

Parameters:
-----------

pos:  input: position,

vel:  output: velocity,

dir:  1 for corotating, -1 for counterrotating. ";

%feature("docstring")  Gyoto::Metric::Hayward::gmunu "

Metric coefficients.

The default implementation calls double gmunu(const double * x, int
mu, int nu) const.

Parameters:
-----------

ARGOUT_ARRAY2:  (g) 4x4 array to store the coeefficients

IN_ARRAY1:  (x) 4-position at which to compute the coefficients;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::Hayward::gmunu "

Metric coefficients.

The default implementation calls Metric:: gmunu(double g[4][4], const
double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::Hayward::gmunu_up "

Metric contravariant coefficients.

The default implementation inverts the covariant coefficients matrix.
";

%feature("docstring")  Gyoto::Metric::Hayward::gmunu_up "

Metric contravariant coefficients.

The default implementation calls Metric:: gmunu_up(double g[4][4],
const double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::Hayward::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3).

1 on error, 0 otherwise ";

%feature("docstring")  Gyoto::Metric::Hayward::ScalarProd "

Scalar product.

Compute the scalarproduct of the two quadrivectors u1 and u2 in this
Metric, at point pos expressed in coordinate system sys.

Parameters:
-----------

pos:  4-position;

u1:  1st quadrivector;

u2:  2nd quadrivector;

u1*u2 ";

%feature("docstring")  Gyoto::Metric::Hayward::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3). ";

%feature("docstring")  Gyoto::Metric::Hayward::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3).

1 on error, 0 otherwise ";

%feature("docstring")  Gyoto::Metric::Hayward::coordKind "

Get coordinate kind. ";

%feature("docstring")  Gyoto::Metric::Hayward::getRefCount "";

%feature("docstring")  Gyoto::Metric::Hayward::mass "

Set mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::Hayward::mass "

Set mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::Hayward::mass "

Get mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::Hayward::mass "

Get mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::Hayward::unitLength "

M * G / c^2, M is in kg, unitLength in meters.

Metrics implementations are free to express lengths and distances in
whatever unit they see fit (presumably most often geometrical units).
This function returns this unit in SI (meters). ";

%feature("docstring")  Gyoto::Metric::Hayward::unitLength "

unitLength expressed in specified unit ";

%feature("docstring")  Gyoto::Metric::Hayward::getRmb "

Returns the marginally bound radius Should be implemented in derived
classes if useful If called on the base class, returns an error ";

%feature("docstring")  Gyoto::Metric::Hayward::getRms "

Returns the marginally stable (ISCO) radius Should be implemented in
derived classes if useful If called on the base class, returns an
error ";

%feature("docstring")  Gyoto::Metric::Hayward::deltaMin "

Get delta_min_ ";

%feature("docstring")  Gyoto::Metric::Hayward::deltaMin "

Set delta_min_ ";

%feature("docstring")  Gyoto::Metric::Hayward::deltaMax "

Get delta_max_ ";

%feature("docstring")  Gyoto::Metric::Hayward::deltaMax "

Get delta max at a given position

Parameters:
-----------

pos:  4-position

[optional]:  delta_max_external external constraint on delta_max

the smallest value between delta_max_, delta_max_external, and
R*delta_max_over_r_ where R is pos[1] in spherical coordinates and
max(x1, x2, x3) in Cartesian coordinates. ";

%feature("docstring")  Gyoto::Metric::Hayward::deltaMax "

Set delta_max_ ";

%feature("docstring")  Gyoto::Metric::Hayward::deltaMaxOverR "

Get delta_max_over_r_. ";

%feature("docstring")  Gyoto::Metric::Hayward::deltaMaxOverR "

Set delta_max_over_r_. ";

%feature("docstring")  Gyoto::Metric::Hayward::keplerian "

Get keplerian_. ";

%feature("docstring")  Gyoto::Metric::Hayward::keplerian "

Set keplerian_. ";

%feature("docstring")  Gyoto::Metric::Hayward::cartesianVelocity "

Compute xprime, yprime and zprime from 8-coordinates. ";

%feature("docstring")  Gyoto::Metric::Hayward::SysPrimeToTdot "

Compute tdot as a function of dr/dt, dtheta/dt and dphi/dt. Everything
is in geometrical units.

Parameters:
-----------

coord:  4-position (geometrical units);

v:  3-velocity dx1/dx0, dx2/dx0, dx3/dx0;

tdot = dx0/dtau. ";

%feature("docstring")  Gyoto::Metric::Hayward::zamoVelocity "

Yield ZAMO velocity at a given position.

Give the velocity of a zero angular momentul observer (whatever is
closest to \"at rest\"). The default implementation simply projects
(1, 0, 0, 0) othogonally along ephi and normalizes it, thus ensuring
that vel is orthogonal to ephi.

Parameters:
-----------

pos:  input: position,

vel:  output: velocity, ";

%feature("docstring")  Gyoto::Metric::Hayward::nullifyCoord "

Set tdot (coord[4]) such that coord is light-like. Everything is in
geometrical units.

Set coord[4] so that the 4-velocity coord[4:7] is lightlike, i.e. of
norm 0. There may be up to two solutions. coord[4] is set to the
hightest. The lowest can be retrieved using nullifyCoord(double
coord[8], double& tdot2) const. Everything is expressed in geometrical
units.

Parameters:
-----------

coord:  8-position, coord[4] will be set according to the other
elements; ";

%feature("docstring")  Gyoto::Metric::Hayward::nullifyCoord "

Set tdot (coord[4]) such that coord is light-like and return other
possible tdot.

Set coord[4] so that the 4-velocity coord[4:7] is lightlike, i.e. of
norm 0. There may be up to two solutions. coord[4] is set to the
hightest. The lowest can be retrieved in tdot2. Everything is
expressed in geometrical units.

Parameters:
-----------

coord:  8-position, coord[4] will be set according to the other
elements;

tdot2:  will be set to the smallest solution ";

%feature("docstring")  Gyoto::Metric::Hayward::normalizeFourVel "

Normalize fourvelvel to -1.

First computes threevel as xiprime=xidot/x0dot for i in {1, 2, 3},
then computes x0dot using SyPrimeToTdot, then computes again xidot as
xidot=xiprime*x0dot.

Parameters:
-----------

coord:  8-position, coord[4-7] will be set according to the other
elements; ";

%feature("docstring")  Gyoto::Metric::Hayward::normalizeFourVel "

Normalize fourvelvel to -1.

First computes threevel as xiprime=xidot/x0dot for i in {1, 2, 3},
then computes x0dot using SyPrimeToTdot, then computes again xidot as
xidot=xiprime*x0dot.

Parameters:
-----------

pos:  4-position;

fourvel:  4-velocity, will be renormalized. ";

%feature("docstring")  Gyoto::Metric::Hayward::norm "

Scalar product.

Compute the norm of the quadrivector u1 in this Metric, at point pos
expressed in coordinate system sys.

Parameters:
-----------

pos:  4-position;

u1:  quadrivector;

||u1|| ";

%feature("docstring")  Gyoto::Metric::Hayward::multiplyFourVect "

multiply vector by scalar ";

%feature("docstring")  Gyoto::Metric::Hayward::addFourVect "

add second vector to first one ";

%feature("docstring")  Gyoto::Metric::Hayward::projectFourVect "

project u1 orthogonally to u2 at pos ";

%feature("docstring")  Gyoto::Metric::Hayward::dualOneForm "

Computes dual 1-form Compute the dual 1-form of 4-vector.

Parameters:
-----------

IN_ARRAY1_1:  4-position;

IN_ARRAY1_2:  quadrivector;

ARGOUT_ARRAY1:  output 1-form ";

%feature("docstring")  Gyoto::Metric::Hayward::observerTetrad "

Computes the orthonormal local tetrad of the observer.

Parameters:
-----------

obskind:  input: kind of observer (eg:
\"ZAMO\",\"KeplerianObserver\"...)

pos:  input: position,

fourvel:  output: observer 4-velocity (norm -1)

screen1:  output: first vector in the screen plane

screen2:  output: second vector in the screen plane

screen3:  output: vector normal to the screen ";

%feature("docstring")  Gyoto::Metric::Hayward::observerTetrad "

Computes the orthonormal local tetrad of the observer.

Parameters:
-----------

pos:  position,

fourvel:  observer 4-velocity (norm -1)

screen1:  first vector in the screen plane

screen2:  second vector in the screen plane

screen3:  vector normal to the screen ";

%feature("docstring")  Gyoto::Metric::Hayward::GramSchmidt "

Apply Gram-Schmidt orthonormalization to a basis.

On input, u0 to u3 must be four non-zero norm, independent 4-vectors.
On output, they will form an orthonormal basis.

Parameters:
-----------

pos:  position,

u0:  basis vector

u1:  basis vector

u2:  basis vector

u3:  basis vector ";

%feature("docstring")  Gyoto::Metric::Hayward::jacobian "

Derivatives of the metric covariant coefficients.

The default implementation evaluates them numerically. The gmunu
matrix is assumed to be symmetrical but no other assumptions are made
at the moment. ";

%feature("docstring")  Gyoto::Metric::Hayward::gmunu_up_and_jacobian "

gmunu_up() and jacobian() in one go ";

%feature("docstring")  Gyoto::Metric::Hayward::computeNBeta "

Computes lapse scalar and shift vector at coord. ";

%feature("docstring")  Gyoto::Metric::Hayward::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3). ";

%feature("docstring")  Gyoto::Metric::Hayward::myrk4 "

RK4 integrator. ";

%feature("docstring")  Gyoto::Metric::Hayward::myrk4 "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::Hayward::myrk4_adaptive "

RK4 integrator with adaptive step. ";

%feature("docstring")  Gyoto::Metric::Hayward::myrk4_adaptive "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::Hayward::isStopCondition "

Check whether integration should stop.

The integrating loop will ask this the Metric through this method
whether or not it is happy to continue the integration. Typically, the
Metric should answer 0 when everything is fine, 1 when too close to
the event horizon, inside the BH...

Parameters:
-----------

coord:  8-coordinate vector to check. ";

%feature("docstring")  Gyoto::Metric::Hayward::diff "

F function such as dx/dt=F(x,cst) ";

%feature("docstring")  Gyoto::Metric::Hayward::diff "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::Hayward::diff "";

%feature("docstring")  Gyoto::Metric::Hayward::diff31 "

F function such as dx/dt=F(x,cst) for 3+1 case. ";

%feature("docstring")  Gyoto::Metric::Hayward::setParticleProperties "

Set Metric-specific constants of motion. Used e.g. in KerrBL. ";

%feature("docstring")  Gyoto::Metric::Hayward::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Metric::Hayward::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Metric::Hayward::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Metric::Hayward::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Metric::Hayward::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Metric::Hayward::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Metric::Hayward::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Metric::Hayward::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Metric::Hayward::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Metric::Hayward::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Metric::Hayward::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Metric::Hayward::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Metric::Hayward::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Metric::Hayward::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Metric::Hayward::setParameters "

Main loop for parsing Properties from XML description.

This function queries the FactoryMessenger for elements to parse, and
tries to matche each element to a Property to set it  accordingly. Any
class that tries to be buildable from XML must supply a subcontractor
(for base classes such as Metric, Astrobj, Spectrum  and Spectrometer,
it is done as a template that must be  specialized for each class).
This subcontractor typically looks somewhat like this: Although this
is discouraged, it is possible to override the following functions to
customize how XML entities are parsed:    - setParameters() if low-
level access to the      FactoryMessenger is required;    -
setParameter(std::string name, std::string content,
std::string unit)      to interpret an entity that does not match a
Property      (e.g. alternative name);    -
setParameter(Gyoto::Property const &p, std::string const &name,
std::string const &content, std::string const &unit)      to change
how a Property is interpreted. ";

%feature("docstring")  Gyoto::Metric::Hayward::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Metric::Hayward::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Metric::Hayward::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Metric::Hayward::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Metric::Hayward::kind "

Get kind_. ";

%feature("docstring")  Gyoto::Metric::Hayward::hook "

Start listening.

Use from a Hook::Listener object method: where \"this\" is a Listener
and \"teller\" is a Teller.

Use unhook() later to stop listening to a given Teller.

Parameters:
-----------

listener:  pointer to the new listener ";

%feature("docstring")  Gyoto::Metric::Hayward::unhook "

Stop listening.

Use from a Hook::Listener object method:

where \"this\" is a Listener, \"teller\" is a Teller, and \"this\" has
called teller->hook(this) previously.

Parameters:
-----------

listener:  pointer to the listener ";


// File: class_gyoto_1_1_screen_1_1_indices.xml
%feature("docstring") Indices "

1D specifier for an arbitrary pixel coordinate set.

C++ includes: GyotoScreen.h ";

%feature("docstring")  Indices::Indices "";

%feature("docstring")  Indices::~Indices "";

%feature("docstring")  Indices::begin "

Reset specifier to point to the first value. ";

%feature("docstring")  Indices::valid "

True if pointing to something, false if end has been reached. ";

%feature("docstring")  Indices::size "

Number of values in this container. ";

%feature("docstring")  Indices::index "

Get index of value currently pointed to.

Starts at 0 and is implemented each time operator++ is called.
Depending on the implementation, this may be a real index or computed
on demand. ";

%feature("docstring")  Indices::angle "

Get double value currently pointed to. ";


// File: class_gyoto_1_1_astrobj_1_1_inflate_star.xml
%feature("docstring") Gyoto::Astrobj::InflateStar "

An Astrobj::Star with growing size.

C++ includes: GyotoInflateStar.h ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::InflateStar "

Default constructor.

Create InflateStar object with undefined initial conditions. One needs
to set the coordinate system, the metric, and the initial position and
velocity before integrating the orbit. setInititialCondition() can be
used for that. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::InflateStar "

Copy constructor. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::clone "

Cloner.

This method must be implemented by the various Astrobj::Generic
subclasses in order to support cloning:

Cloning is necessary for multi-threading, recommended for interaction
with the Yorick plug-in etc.

Implementing it is very straightforward, as long as the copy
constructor Generic(const Generic& ) has been implemented: ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::~InflateStar "

Destructor. ";

%feature("docstring")
Gyoto::Astrobj::InflateStar::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")
Gyoto::Astrobj::InflateStar::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")
Gyoto::Astrobj::InflateStar::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::InflateStar::radiusAt "

Radius at a given time. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::radiusAt "

Radius at a given time. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::radiusAt "

Radius at a given time. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::className "

\"InflateStar\" ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::className_l "

\"inflate_star\" ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::emission "

Emission is determined by spectrum_ and opacity_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::getMass "

Return 1.

The mass of a Star is always 1. Stars do not perturb the metric. The
only relevant point is that Stars are massive particules, their exact
mass is of no importance. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")
Gyoto::Astrobj::InflateStar::setInitialCondition "

Same as Worldline::setInitialCondition(gg, coord, sys,1) ";

%feature("docstring")
Gyoto::Astrobj::InflateStar::setInitialCondition "

Set or re-set the initial condition prior to integration.

Parameters:
-----------

gg:   Gyoto::SmartPointer to the Gyoto::Metric in this universe;

coord:  8 element array containing the initial condition, i.e. the
4-position and the 4-velocity of the Photon at the receiving end;

dir:  direction: 1 for future, -1 for past.

Ephi:  initial value of base vector to parallel-transport. Ignored if
parallel_transport_ is false.

Etheta:  initial value of base vector to parallel-transport. Ignored
if parallel_transport_ is false. ";

%feature("docstring")
Gyoto::Astrobj::InflateStar::setInitialCondition "

Set or re-set the initial condition prior to integration.

Parameters:
-----------

gg:   Gyoto::SmartPointer to the Gyoto::Metric in this universe;

coord:  8 element array containing the initial condition, i.e. the
4-position and the 4-velocity of the Photon at the receiving end;

dir:  direction: 1 for future, -1 for past. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::getCartesian "

Get the 6 Cartesian coordinates for specific dates.

This method is present in both the API of UniformSphere and Worldline.
It is pure virtual in UniformSphere. The Star reimplementation is a
trivial wrapper around Worldline::getCartesian(). ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::getVelocity "

Yield velocity of the center of the sphere. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::radiativeQ "

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::InflateStar::spectrum "

Set spectrum_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::spectrum "

Get spectrum_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::opacity "

Set opacity_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::opacity "

Get opacity_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::radius "

Get radius_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::radius "

Set radius_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::radius "

Get radius_ in specified unit. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::radius "

Set radius_ in specified unit. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::deltaMaxOverRadius
"

Get dltmor_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::deltaMaxOverRadius
"

Set dltmor_. ";

%feature("docstring")
Gyoto::Astrobj::InflateStar::deltaMaxOverDistance "

Get dltmod_. ";

%feature("docstring")
Gyoto::Astrobj::InflateStar::deltaMaxOverDistance "

Set dltmod_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::isotropic "";

%feature("docstring")  Gyoto::Astrobj::InflateStar::isotropic "";

%feature("docstring")  Gyoto::Astrobj::InflateStar::alpha "";

%feature("docstring")  Gyoto::Astrobj::InflateStar::alpha "";

%feature("docstring")  Gyoto::Astrobj::InflateStar::deltaMax "

Parameters:

coord:  current photon position

max( dltmor_* radius_, dltmod_*operator()(double coord[]) ) ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::deltaMax "

Get delta_max_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::deltaMax "

Get delta max at a given position

Parameters:
-----------

pos:  4-position

delta_max_external:  external constraint on delta_max

the smallest value between delta_max_, delta_max_external, and R*
delta_max_over_r_ where R is pos[1] in spherical coordinates and
max(x1, x2, x3) in Cartesian coordinates. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::deltaMax "

Set delta_max_ ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::integrateEmission
"

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::integrateEmission
"

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::integrateEmission
"

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")  Gyoto::Astrobj::InflateStar::integrateEmission
"

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::safetyValue "

Set Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::safetyValue "

Get Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::deltaInObj "

Get Generic::delta_inobj_.

Get the constant integration step inside the astrobj

delta_inobj_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::deltaInObj "

Set Generic::delta_inobj_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::giveDelta "

Maximum inside object.

Gives the requested integration stept (in coordinate time t) between
two neighbooring points along a portion of geodesic inside an astrobj;
the current implementation only considers a constant delta, equal to
Standard::deltaInobj()

Parameters:
-----------

coord:  input coordinate at whicht is given ";

%feature("docstring")
Gyoto::Astrobj::InflateStar::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::InflateStar::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::showshadow "";

%feature("docstring")  Gyoto::Astrobj::InflateStar::showshadow "";

%feature("docstring")  Gyoto::Astrobj::InflateStar::redshift "";

%feature("docstring")  Gyoto::Astrobj::InflateStar::redshift "";

%feature("docstring")
Gyoto::Astrobj::InflateStar::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")
Gyoto::Astrobj::InflateStar::processHitQuantities "

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")
Gyoto::Astrobj::InflateStar::processHitQuantities "";

%feature("docstring")  Gyoto::Astrobj::InflateStar::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::InflateStar::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::InflateStar::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::InflateStar::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::InflateStar::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::InflateStar::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")
Gyoto::Astrobj::InflateStar::computeB4vect_ipole "";

%feature("docstring")  Gyoto::Astrobj::InflateStar::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::InflateStar::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::kind "

Get kind_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::getImin "

Get imin_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::getImax "

Get imax_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::getI0 "

Get i0_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::initCoord "";

%feature("docstring")  Gyoto::Astrobj::InflateStar::initCoord "";

%feature("docstring")  Gyoto::Astrobj::InflateStar::setInitCoord "

Set Initial coordinate.

Set imin_= imax_= i0_, and x  [i0]=coord[ ].

If dir==1, i0_ is set to 0. If dir==-1, i0_ is set to x_size_-1.

If dir==0 and the Worldine has never been computed ( i0_==0, imin_==1
and imax_==0), then dir defaults to 1 for a massive particle and -1
for a massless particle.

If dir==0 and the Worldine has already been computed, i0_ is not
changed.



Parameters:
-----------

coord:  new initial coordinates

dir:  direction of integration. 1 for forward integration, -1 for
backards integration, 0 for unknown or both

Ephi:  initial value of base vector to parallel-transport. Ignored if
parallel_transport_ is false.

Etheta:  initial value of base vector to parallel-transport. Ignored
if parallel_transport_ is false. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::setInitCoord "

Set Initial coordinate.

Set imin_= imax_= i0_, and x  [i0]=coord[ ].

If dir==1, i0_ is set to 0. If dir==-1, i0_ is set to x_size_-1.

If dir==0 and the Worldine has never been computed ( i0_==0, imin_==1
and imax_==0), then dir defaults to 1 for a massive particle and -1
for a massless particle.

If dir==0 and the Worldine has already been computed, i0_ is not
changed.



Parameters:
-----------

coord:  new initial coordinates

dir:  direction of integration. 1 for forward integration, -1 for
backards integration, 0 for unknown or both ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::setInitCoord "

Set initial coordinate.

Parameters:
-----------

pos:  initial 4-position

vel:  initial 3-velocity

dir:  direction of integration ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::setPosition "

Set initial 4-position. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::setVelocity "

Set initial 3-velocity. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::reset "

Forget integration, keeping initial contition. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::reInit "

Reset and recompute particle properties. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::integrator "

Set the integrator.

Initialize state_ to use the required integrator.

Parameters:
-----------

type:  Either \"Legacy\" or (if GYOTO_HAVE_BOOST_INTEGRATORS) one of
\"runge_kutta_cash_karp54\", \"runge_kutta_fehlberg78\",
\"runge_kutta_dopri5\", \"runge_kutta_cash_karp54_classic\" ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::integrator "

Describe the integrator used by state_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::integ31 "

Set the integrator kind to 3+1 or 4D.

Initialize state_ to use the required geodesic equation. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::integ31 "

Get the kind of geodesic equation integrated by state_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::deltaMin "

Get delta_min_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::deltaMin "

Set delta_min_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::absTol "

Set abstol_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::absTol "

Get abstol_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::relTol "

Set reltol_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::relTol "

Get reltol_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::maxCrossEqplane "

Set #maxCrosEqplane_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::maxCrossEqplane "

Get maxCrossEqplane_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::deltaMaxOverR "

Get delta_max_over_r_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::deltaMaxOverR "

Set delta_max_over_r_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::delta "

Expand memory slots for polarization vectors.

Assignment to another Worldline Set delta_ ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::delta "

Set delta_ in specified units. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::delta "

Get delta_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::delta "

Get delta_ in specified units. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::tMin "

Get tmin_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::tMin "

Get tmin_ in specified unit. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::tMin "

Set tmin_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::tMin "

Set tmin_ in specified unit. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::adaptive "

Set adaptive_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::adaptive "

Get adaptive_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::secondary "

Set secondary_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::secondary "

Get secondary_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::parallelTransport
"

Set parallel_transport_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::parallelTransport
"

Get parallel_transport_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::maxiter "

Set maxiter_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::maxiter "

Get maxiter_. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::getCst "

Returns the worldline's cst of motion (if any)

Return pointer to array holding the previously set Metric-specific
constants of motion.

This function returns a pointer to the actual storage location and
should be handled with care. std::vector<double> Worldline:
constantsOfMotion() constprovides a convenient way to retrieve a copy
of the content. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::setCst "

Set Metric-specific constants of motion.

The will (re)allocate Worldline::cst_, copy cst into it, and set
Worldline::cst_n_.

This is the same as void Worldline:
constantsOfMotion(std::vector<double> const cstv) using a C-style
array instead of a vector. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::constantsOfMotion
"

Set Metric-specific constants of motion.

The will (re)allocate Worldline::cst_, copy cst into it, and set
Worldline::cst_n_.

This is the same as getCst using a vector instead of a C-style array.
";

%feature("docstring")  Gyoto::Astrobj::InflateStar::constantsOfMotion
"

Return a copy of the Metric-specific constants of motion.

This funtion return a copy of the constants of motion. getCst() can be
used to retrieve a pointer to the actual array used internally which
is slightly more efficient for read-only access. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::getInitialCoord "

Get initial coordinates + base vectors.

Depending on the size of dest and on the value of parallel_transport_,
get position (xi_), velocity (xidot_) and possibly other triad vectors
(epi_ and eti_). ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::getCoord "

Get coordinates+base vectors corresponding to index.

Depending on the value of parallel_transport_, get position (xi_),
velocity (xidot_) and possibly other triad vectors (epi_ and eti_).
coord is resized to the right number of elements. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::getCoord "

Get coordinates+base vectors corresponding to index.

We need this non-const implementation to allow the const, size_t and
the non-const, double implementations to coexist. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::getCoord "

Get coordinates+base vectors corresponding to date dest[0].

Depending on the value of parallel_transport_, get position (xi_),
velocity (xidot_) and possibly other triad vectors (epi_ and eti_).
coord is resized to the right number of elements. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::getCoord "

Get 8-coordinates for specific dates.

The coordinates will be computed using the integrator, so they will be
as accurate as possible. Some heuristics are used to speed up the
process and it is presumably faster to call this routine with a sorted
list of dates. The line will be integrated further as required. An
error will be thrown if it is not possible to reach a certain date.

Parameters:
-----------

dates:  the list of dates for which the coordinates are to be computed
in proper time or affine parameter if #proper is true or in coordinate
time if #proper is false (default);

n_dates:  the number of dates to compute ;

x1dest:  x2dest:  x3dest:  x0dot:  x1dot:  x2dot:  x3dot:  arrays in
which to store the result. These pointer may be set to NULL to
retrieve only part of the information. They must be pre-allocated.

ephi0:  ephi1:  ephi2:  ephi3:  etheta0:  etheta1:  etheta2:  etheta3:
arrays in which to store the ephi and etheta (parallel transport
case). These pointer may be set to NULL to retrieve only part of the
information. They must be pre-allocated.

otime:  array in which to store the other time: coordinate time if
#proper, else proper time or affine parameter.

proper:  bool: whether #dates is proper time (or affine parameter) or
coordinate time. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::getCoord "

Get all computed positions.

Get all the pre-computed 8 coordinates (e.g. thanks to a prior call to
xFill()) of this worldline. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::getCartesianPos "

Get Cartesian expression of 4-position at index. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::xStore "

Store coord at index ind. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::xStore "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::xStore "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::xFill "

Fill x0, x1... by integrating the Worldline from previously set
inittial condition to time tlim. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::get_nelements "

Get number of computed dates. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::get_t "

Get computed dates. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::get_tau "

Get computed proper times or values of the affine parameter. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::get_xyz "

Get 3-position in cartesian coordinates for computed dates. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::checkPhiTheta "

Bring in [0,] and in [0,2].

checkPhiTheta() Modifies coord if the corrdinates are spherical-like
so that coord[2]=theta is in [0,pi] and coord[3]=phi is in [0,2pi].
Important to use in all astrobj in spherical coordinates to prevent
\"z-axis problems\". ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::getSkyPos "

Get computed positions in sky coordinates. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::get_dot "

Get computed 4-velocities. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::get_prime "

Get computed 3-velocities. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::save_txyz "

Save in a file. ";

%feature("docstring")  Gyoto::Astrobj::InflateStar::save_txyz "

Save, converted. ";


// File: class_gyoto_1_1_worldline_1_1_integ_state.xml


// File: class_gyoto_1_1_astrobj_1_1_polish_doughnut_1_1intersection__t.xml


// File: class_gyoto_1_1_astrobj_1_1_jet.xml
%feature("docstring") Gyoto::Astrobj::Jet "

Simple jet model with thermal or kappa-distribution synchrotron
emission from Pandya et al. (2016)

This class implements a jet defined as the volume contained between
the two conical surfaces defined by angles jetInnerOpeningAngle_ and
jetOuterOpeningAngle_, with apex located on the black hole rotation
axis at altitude jetBaseHeight_ in units of M.

The Lorentz factor is assumed constant at gammaJet_. The electron
number density at the base of the jet is baseNumberDensity_cgs_, its
z-evolution is dedictated by mass conservation. The electron
temperature is baseTemperature_, its z-evolution is assumed to follow
a power law z^temperatureSlope_. The magnetic field amplitude is
defined by the magnetization parameter, magnetizationParameter_.

The jet emits synchrotron radiation, assuming that the electrons
follow a thermal or kappa distribution, ie the smooth gluing of a
thermal distribution at low electron Lorentz factor, to a power-law
distribution at high electron Lorentz factor. This distribution, as
well as the resulting emission and absorption coefficients are taken
from: Pandya et al., ApJ, 822, 34 (2016), section 5.3.3

C++ includes: GyotoJet.h ";

%feature("docstring")  Gyoto::Astrobj::Jet::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Astrobj::Jet::Jet "

Standard constructor. ";

%feature("docstring")  Gyoto::Astrobj::Jet::Jet "

Copy constructor. ";

%feature("docstring")  Gyoto::Astrobj::Jet::clone "

Cloner. ";

%feature("docstring")  Gyoto::Astrobj::Jet::~Jet "

Destructor. ";

%feature("docstring")  Gyoto::Astrobj::Jet::jetOuterOpeningAngle "";

%feature("docstring")  Gyoto::Astrobj::Jet::jetOuterOpeningAngle "";

%feature("docstring")  Gyoto::Astrobj::Jet::jetInnerOpeningAngle "";

%feature("docstring")  Gyoto::Astrobj::Jet::jetInnerOpeningAngle "";

%feature("docstring")  Gyoto::Astrobj::Jet::jetBaseHeight "";

%feature("docstring")  Gyoto::Astrobj::Jet::jetBaseHeight "";

%feature("docstring")  Gyoto::Astrobj::Jet::gammaJet "";

%feature("docstring")  Gyoto::Astrobj::Jet::gammaJet "";

%feature("docstring")  Gyoto::Astrobj::Jet::jetVphiOverVr "";

%feature("docstring")  Gyoto::Astrobj::Jet::jetVphiOverVr "";

%feature("docstring")  Gyoto::Astrobj::Jet::baseNumberDensity "";

%feature("docstring")  Gyoto::Astrobj::Jet::baseNumberDensity "";

%feature("docstring")  Gyoto::Astrobj::Jet::baseNumberDensity "";

%feature("docstring")  Gyoto::Astrobj::Jet::baseNumberDensity "";

%feature("docstring")  Gyoto::Astrobj::Jet::baseTemperature "";

%feature("docstring")  Gyoto::Astrobj::Jet::baseTemperature "";

%feature("docstring")  Gyoto::Astrobj::Jet::temperatureSlope "";

%feature("docstring")  Gyoto::Astrobj::Jet::temperatureSlope "";

%feature("docstring")  Gyoto::Astrobj::Jet::magnetizationParameter "";

%feature("docstring")  Gyoto::Astrobj::Jet::magnetizationParameter "";

%feature("docstring")  Gyoto::Astrobj::Jet::kappaIndex "";

%feature("docstring")  Gyoto::Astrobj::Jet::kappaIndex "";

%feature("docstring")  Gyoto::Astrobj::Jet::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::Jet::radiativeQ "

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::Jet::getVelocity "

Fluid velocity field.

Fill vel with the 4-vector velocity of the fluid at 4-position pos.

Parameters:
-----------

pos:  4-position at which to compute velocity;

vel:  4-velocity at pos. ";

%feature("docstring")  Gyoto::Astrobj::Jet::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::Jet::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::Jet::safetyValue "

Set Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::Jet::safetyValue "

Get Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::Jet::deltaInObj "

Get Generic::delta_inobj_.

Get the constant integration step inside the astrobj

delta_inobj_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Jet::deltaInObj "

Set Generic::delta_inobj_. ";

%feature("docstring")  Gyoto::Astrobj::Jet::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::Jet::giveDelta "

Maximum inside object.

Gives the requested integration stept (in coordinate time t) between
two neighbooring points along a portion of geodesic inside an astrobj;
the current implementation only considers a constant delta, equal to
Standard::deltaInobj()

Parameters:
-----------

coord:  input coordinate at whicht is given ";

%feature("docstring")  Gyoto::Astrobj::Jet::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::Jet::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Jet::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::Jet::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::Jet::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::Jet::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::Jet::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")  Gyoto::Astrobj::Jet::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")
Gyoto::Astrobj::Jet::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::Jet::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")  Gyoto::Astrobj::Jet::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::Jet::showshadow "";

%feature("docstring")  Gyoto::Astrobj::Jet::showshadow "";

%feature("docstring")  Gyoto::Astrobj::Jet::redshift "";

%feature("docstring")  Gyoto::Astrobj::Jet::redshift "";

%feature("docstring")  Gyoto::Astrobj::Jet::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")  Gyoto::Astrobj::Jet::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")  Gyoto::Astrobj::Jet::processHitQuantities "

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")  Gyoto::Astrobj::Jet::processHitQuantities "";

%feature("docstring")  Gyoto::Astrobj::Jet::emission "

Specific intensity I

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem, in the emitter's frame. It should take self-absorption
along dsem into account.

Reminder : intensity = I [J m^-2 s^-1 ster^-1 Hz^-1];

invariant intensity = I/3, which has the same value in any frame;

emission coefficient = j [J m^-3 s^-1 ster^-1 Hz^-1] , defined by dI =
j*ds, where ds is the distance travelled by the photon inside the
object;

invariant emission coef = j/2, which has the same value in any frame.

The equation used for radiative transfer (without absorption) is:

d(I/3)/d = (j/2) [*]

where is the integration parameter along the null geodesic.

NB: Let us consider a particular observer, with being the frequency
measured by this observer, and ds being the proper distance (as
measured by the observer) that the photon travels as it moves from
to+d along its geodesic. Then it can be shown that:

d = ds/

This shows that Eq. [*] is homogeneous.

The default implementation returns 1. if optically thick and dsem if
optically thin. It allows for a quick implementation of your object
for visualization purposes.

Parameters:
-----------

nu_em:  Frequency at emission [Hz]

dsem:  length over which to integrate inside the object [geometrical
units]

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position ";

%feature("docstring")  Gyoto::Astrobj::Jet::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::Jet::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::Jet::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Jet::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::Jet::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")  Gyoto::Astrobj::Jet::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")  Gyoto::Astrobj::Jet::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Jet::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")  Gyoto::Astrobj::Jet::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Jet::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Jet::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Jet::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Jet::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Jet::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Jet::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Jet::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Jet::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::Jet::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::Jet::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::Jet::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::Jet::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::Jet::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")  Gyoto::Astrobj::Jet::computeB4vect_ipole "";

%feature("docstring")  Gyoto::Astrobj::Jet::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::Jet::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::Jet::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::Jet::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::Jet::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::Jet::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::Jet::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Jet::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Jet::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Jet::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Jet::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Jet::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Jet::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::Jet::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::Jet::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::Jet::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Astrobj::Jet::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Astrobj::Jet::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Astrobj::Jet::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Astrobj::Jet::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::Jet::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::Jet::kind "

Get kind_. ";


// File: class_gyoto_1_1_spectrum_1_1_kappa_distribution_synchrotron.xml
%feature("docstring") Gyoto::Spectrum::KappaDistributionSynchrotron "

Kappa-distribution synchrotron spectrum from Pandya et al. (2016)

Example XML entity:

C++ includes: GyotoKappaDistributionSynchrotronSpectrum.h ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::KappaDistributionSynchrotron
"";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::KappaDistributionSynchrotron
"";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::clone "

Cloner. ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::numberdensityCGS "";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::numberdensityCGS "";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::angle_B_pem "";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::angle_B_pem "";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::cyclotron_freq "";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::cyclotron_freq "";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::thetae "";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::thetae "";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::kappaindex "";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::kappaindex "";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::hypergeometric "";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::hypergeometric "";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::angle_averaged "";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::angle_averaged "";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::gamma_max "";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::gamma_max "";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::jnuCGS "

Returns the emission coefficient j_nu in cgs units i.e. erg cm^-3 s^-1
ster^-1 Hz^-1

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::jQnuCGS "

Returns the Stokes Q emission coefficient j_nu in cgs units i.e. erg
cm^-3 s^-1 ster^-1 Hz^-1

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::jUnuCGS "

Returns the Stokes U emission coefficient j_nu in cgs units i.e. erg
cm^-3 s^-1 ster^-1 Hz^-1

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::jVnuCGS "

Returns the Stokes V emission coefficient j_nu in cgs units i.e. erg
cm^-3 s^-1 ster^-1 Hz^-1

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::alphanuCGS "

Returns the absorption coefficient alpha_nu in cgs units [cm^-1]

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::alphaQnuCGS "

Returns the Stokes Q absorption coefficient alpha_nu in cgs units
[cm^-1]

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::alphaUnuCGS "

Returns the Stokes U absorption coefficient alpha_nu in cgs units
[cm^-1]

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::alphaVnuCGS "

Returns the Stokes V absorption coefficient alpha_nu in cgs units
[cm^-1]

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::rQnuCGS "

Returns the Stokes Q Faraday rotation coefficient in cgs units [cm^-1]

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::rUnuCGS "

Returns the Stokes U Faraday rotation coefficient in cgs units [cm^-1]

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::rVnuCGS "

Returns the Stokes V Faraday rotation coefficient in cgs units [cm^-1]

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::radiativeQ "

Returns the emission and absorption coef in SI ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::radiativeQ "

Returns the emission, absorption and Fraday rotation coef in SI for
the 4 Stokes parameters ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::integrate "

Integrate optically thick I_nu.

See operator()(double nu) const

Parameters:
-----------

nu1:  nu2:  boundaries for the integration

I, the integral of I_nu between nu1 and nu2 ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::integrate "

Integrate optically thin I_nu.

See operator()(double nu, double opacity, double ds) const

Parameters:
-----------

nu1:  nu2:  boundaries for the integration

opacity:  the frequency-dependent opacity law given as a pointer to a
Gyoto::Spectrum::Generic sub-class instance

ds:  the element length for spatial integration

I, the integral of I_nu between nu1 and nu2 ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::getRefCount "

Get the current number of references. ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::set "

Set Value of a Property. ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::set "

Set Value of a Property. ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::get "

Get Value of a Property. ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::get "

Get Value of a Property. ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::setParameters "

Main loop for parsing Properties from XML description.

This function queries the FactoryMessenger for elements to parse, and
tries to matche each element to a Property to set it  accordingly. Any
class that tries to be buildable from XML must supply a subcontractor
(for base classes such as Metric, Astrobj, Spectrum  and Spectrometer,
it is done as a template that must be  specialized for each class).
This subcontractor typically looks somewhat like this: Although this
is discouraged, it is possible to override the following functions to
customize how XML entities are parsed:    - setParameters() if low-
level access to the      FactoryMessenger is required;    -
setParameter(std::string name, std::string content,
std::string unit)      to interpret an entity that does not match a
Property      (e.g. alternative name);    -
setParameter(Gyoto::Property const &p, std::string const &name,
std::string const &content, std::string const &unit)      to change
how a Property is interpreted. ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")
Gyoto::Spectrum::KappaDistributionSynchrotron::kind "

Get kind_. ";


// File: class_gyoto_1_1_metric_1_1_kerr_b_l.xml
%feature("docstring") Gyoto::Metric::KerrBL "

Metric around a Kerr black-hole in Boyer-Lindquist coordinates.

C++ includes: GyotoKerrBL.h ";

%feature("docstring")  Gyoto::Metric::KerrBL::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Metric::KerrBL::KerrBL "

Default constructor. ";

%feature("docstring")  Gyoto::Metric::KerrBL::clone "

Virtual copy constructor. ";

%feature("docstring")  Gyoto::Metric::KerrBL::spin "

Set spin. ";

%feature("docstring")  Gyoto::Metric::KerrBL::spin "

Returns spin. ";

%feature("docstring")  Gyoto::Metric::KerrBL::difftol "

Get difftol_. ";

%feature("docstring")  Gyoto::Metric::KerrBL::difftol "

Set difftol_. ";

%feature("docstring")  Gyoto::Metric::KerrBL::horizonSecurity "";

%feature("docstring")  Gyoto::Metric::KerrBL::horizonSecurity "";

%feature("docstring")  Gyoto::Metric::KerrBL::genericIntegrator "";

%feature("docstring")  Gyoto::Metric::KerrBL::genericIntegrator "";

%feature("docstring")  Gyoto::Metric::KerrBL::getRms "

Returns the marginally stable (ISCO) radius Should be implemented in
derived classes if useful If called on the base class, returns an
error ";

%feature("docstring")  Gyoto::Metric::KerrBL::getRmb "

Returns the marginally bound radius Should be implemented in derived
classes if useful If called on the base class, returns an error ";

%feature("docstring")
Gyoto::Metric::KerrBL::getSpecificAngularMomentum "

Returns the specific angular momentum l=-u_phi/u_t Should be
implemented in derived classes if useful If called on the base class,
returns an error ";

%feature("docstring")  Gyoto::Metric::KerrBL::getPotential "

Returns potential W=-ln(|u_t|) for a cst specific angular momentum
l_cst Should be implemented in derived classes if useful If called on
the base class, returns an error ";

%feature("docstring")  Gyoto::Metric::KerrBL::gmunu "

Metric coefficients.

The default implementation calls double gmunu(const double * x, int
mu, int nu) const.

Parameters:
-----------

ARGOUT_ARRAY2:  (g) 4x4 array to store the coeefficients

IN_ARRAY1:  (x) 4-position at which to compute the coefficients;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::KerrBL::gmunu "

Metric coefficients.

The default implementation calls Metric:: gmunu(double g[4][4], const
double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::KerrBL::gmunu_up "

g, ";

%feature("docstring")  Gyoto::Metric::KerrBL::gmunu_up "

Metric contravariant coefficients.

The default implementation calls Metric:: gmunu_up(double g[4][4],
const double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::KerrBL::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3).

1 on error, 0 otherwise ";

%feature("docstring")  Gyoto::Metric::KerrBL::ScalarProd "

Scalar product.

Compute the scalarproduct of the two quadrivectors u1 and u2 in this
Metric, at point pos expressed in coordinate system sys.

Parameters:
-----------

pos:  4-position;

u1:  1st quadrivector;

u2:  2nd quadrivector;

u1*u2 ";

%feature("docstring")  Gyoto::Metric::KerrBL::nullifyCoord "

Set tdot (coord[4]) such that coord is light-like and return other
possible tdot.

Set coord[4] so that the 4-velocity coord[4:7] is lightlike, i.e. of
norm 0. There may be up to two solutions. coord[4] is set to the
hightest. The lowest can be retrieved in tdot2. Everything is
expressed in geometrical units.

Parameters:
-----------

coord:  8-position, coord[4] will be set according to the other
elements;

tdot2:  will be set to the smallest solution ";

%feature("docstring")  Gyoto::Metric::KerrBL::nullifyCoord "

Set tdot (coord[4]) such that coord is light-like. Everything is in
geometrical units.

Set coord[4] so that the 4-velocity coord[4:7] is lightlike, i.e. of
norm 0. There may be up to two solutions. coord[4] is set to the
hightest. The lowest can be retrieved using nullifyCoord(double
coord[8], double& tdot2) const. Everything is expressed in geometrical
units.

Parameters:
-----------

coord:  8-position, coord[4] will be set according to the other
elements; ";

%feature("docstring")  Gyoto::Metric::KerrBL::circularVelocity "

Yield circular velocity at a given position.

Give the velocity of a massive particle in circular orbit at the given
position projected onto the equatorial plane. Such a velocity may not
exist everywhere (or anywhere) for a given metric. This method is
intended to be used by Astrobj classes such as Torus or ThinDisk.

If keplerian_ is set to true, this method should return the Keplerian
velcity instead (derived classes should ensure this, see
KerrBL::circularVelocity() for instance).

The default implementation throws an error if keplerian_ is set to
false.

Parameters:
-----------

pos:  input: position,

vel:  output: velocity,

dir:  1 for corotating, -1 for counterrotating. ";

%feature("docstring")  Gyoto::Metric::KerrBL::zamoVelocity "

Yield ZAMO velocity at a given position.

Give the velocity of a zero angular momentul observer (whatever is
closest to \"at rest\"). The default implementation simply projects
(1, 0, 0, 0) othogonally along ephi and normalizes it, thus ensuring
that vel is orthogonal to ephi.

Parameters:
-----------

pos:  input: position,

vel:  output: velocity, ";

%feature("docstring")  Gyoto::Metric::KerrBL::MakeCoord "

Inverse function of MakeMomentumAndCst.

Computes pr, ptheta, E and L from rdot, thetadot, phidot, tdot ";

%feature("docstring")  Gyoto::Metric::KerrBL::MakeMomentum "

Transforms from Boyer-Lindquist coordinates
[t,r,th,phi,tdot,rdot,thdot,phidot] to [t,r,th,phi,pt,pr,pth,pphi]
where pt,pr... are generalized momenta. ";

%feature("docstring")  Gyoto::Metric::KerrBL::myrk4 "

Internal-use RK4 proxy. ";

%feature("docstring")  Gyoto::Metric::KerrBL::myrk4_adaptive "

Internal-use adaptive RK4 proxy. ";

%feature("docstring")  Gyoto::Metric::KerrBL::setParticleProperties "";

%feature("docstring")  Gyoto::Metric::KerrBL::isStopCondition "

Check whether integration should stop.

The integrating loop will ask this the Metric through this method
whether or not it is happy to continue the integration. Typically, the
Metric should answer 0 when everything is fine, 1 when too close to
the event horizon, inside the BH...

Parameters:
-----------

coord:  8-coordinate vector to check. ";

%feature("docstring")  Gyoto::Metric::KerrBL::observerTetrad "

Computes the orthonormal local tetrad of the observer.

Parameters:
-----------

pos:  position,

fourvel:  observer 4-velocity (norm -1)

screen1:  first vector in the screen plane

screen2:  second vector in the screen plane

screen3:  vector normal to the screen ";

%feature("docstring")  Gyoto::Metric::KerrBL::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3). ";

%feature("docstring")  Gyoto::Metric::KerrBL::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3).

1 on error, 0 otherwise ";

%feature("docstring")  Gyoto::Metric::KerrBL::coordKind "

Get coordinate kind. ";

%feature("docstring")  Gyoto::Metric::KerrBL::getRefCount "";

%feature("docstring")  Gyoto::Metric::KerrBL::mass "

Set mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::KerrBL::mass "

Set mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::KerrBL::mass "

Get mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::KerrBL::mass "

Get mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::KerrBL::unitLength "

M * G / c^2, M is in kg, unitLength in meters.

Metrics implementations are free to express lengths and distances in
whatever unit they see fit (presumably most often geometrical units).
This function returns this unit in SI (meters). ";

%feature("docstring")  Gyoto::Metric::KerrBL::unitLength "

unitLength expressed in specified unit ";

%feature("docstring")  Gyoto::Metric::KerrBL::deltaMin "

Get delta_min_ ";

%feature("docstring")  Gyoto::Metric::KerrBL::deltaMin "

Set delta_min_ ";

%feature("docstring")  Gyoto::Metric::KerrBL::deltaMax "

Get delta_max_ ";

%feature("docstring")  Gyoto::Metric::KerrBL::deltaMax "

Get delta max at a given position

Parameters:
-----------

pos:  4-position

[optional]:  delta_max_external external constraint on delta_max

the smallest value between delta_max_, delta_max_external, and
R*delta_max_over_r_ where R is pos[1] in spherical coordinates and
max(x1, x2, x3) in Cartesian coordinates. ";

%feature("docstring")  Gyoto::Metric::KerrBL::deltaMax "

Set delta_max_ ";

%feature("docstring")  Gyoto::Metric::KerrBL::deltaMaxOverR "

Get delta_max_over_r_. ";

%feature("docstring")  Gyoto::Metric::KerrBL::deltaMaxOverR "

Set delta_max_over_r_. ";

%feature("docstring")  Gyoto::Metric::KerrBL::keplerian "

Get keplerian_. ";

%feature("docstring")  Gyoto::Metric::KerrBL::keplerian "

Set keplerian_. ";

%feature("docstring")  Gyoto::Metric::KerrBL::cartesianVelocity "

Compute xprime, yprime and zprime from 8-coordinates. ";

%feature("docstring")  Gyoto::Metric::KerrBL::SysPrimeToTdot "

Compute tdot as a function of dr/dt, dtheta/dt and dphi/dt. Everything
is in geometrical units.

Parameters:
-----------

coord:  4-position (geometrical units);

v:  3-velocity dx1/dx0, dx2/dx0, dx3/dx0;

tdot = dx0/dtau. ";

%feature("docstring")  Gyoto::Metric::KerrBL::normalizeFourVel "

Normalize fourvelvel to -1.

First computes threevel as xiprime=xidot/x0dot for i in {1, 2, 3},
then computes x0dot using SyPrimeToTdot, then computes again xidot as
xidot=xiprime*x0dot.

Parameters:
-----------

coord:  8-position, coord[4-7] will be set according to the other
elements; ";

%feature("docstring")  Gyoto::Metric::KerrBL::normalizeFourVel "

Normalize fourvelvel to -1.

First computes threevel as xiprime=xidot/x0dot for i in {1, 2, 3},
then computes x0dot using SyPrimeToTdot, then computes again xidot as
xidot=xiprime*x0dot.

Parameters:
-----------

pos:  4-position;

fourvel:  4-velocity, will be renormalized. ";

%feature("docstring")  Gyoto::Metric::KerrBL::norm "

Scalar product.

Compute the norm of the quadrivector u1 in this Metric, at point pos
expressed in coordinate system sys.

Parameters:
-----------

pos:  4-position;

u1:  quadrivector;

||u1|| ";

%feature("docstring")  Gyoto::Metric::KerrBL::multiplyFourVect "

multiply vector by scalar ";

%feature("docstring")  Gyoto::Metric::KerrBL::addFourVect "

add second vector to first one ";

%feature("docstring")  Gyoto::Metric::KerrBL::projectFourVect "

project u1 orthogonally to u2 at pos ";

%feature("docstring")  Gyoto::Metric::KerrBL::dualOneForm "

Computes dual 1-form Compute the dual 1-form of 4-vector.

Parameters:
-----------

IN_ARRAY1_1:  4-position;

IN_ARRAY1_2:  quadrivector;

ARGOUT_ARRAY1:  output 1-form ";

%feature("docstring")  Gyoto::Metric::KerrBL::observerTetrad "

Computes the orthonormal local tetrad of the observer.

Parameters:
-----------

obskind:  input: kind of observer (eg:
\"ZAMO\",\"KeplerianObserver\"...)

pos:  input: position,

fourvel:  output: observer 4-velocity (norm -1)

screen1:  output: first vector in the screen plane

screen2:  output: second vector in the screen plane

screen3:  output: vector normal to the screen ";

%feature("docstring")  Gyoto::Metric::KerrBL::GramSchmidt "

Apply Gram-Schmidt orthonormalization to a basis.

On input, u0 to u3 must be four non-zero norm, independent 4-vectors.
On output, they will form an orthonormal basis.

Parameters:
-----------

pos:  position,

u0:  basis vector

u1:  basis vector

u2:  basis vector

u3:  basis vector ";

%feature("docstring")  Gyoto::Metric::KerrBL::jacobian "

Derivatives of the metric covariant coefficients.

The default implementation evaluates them numerically. The gmunu
matrix is assumed to be symmetrical but no other assumptions are made
at the moment. ";

%feature("docstring")  Gyoto::Metric::KerrBL::gmunu_up_and_jacobian "

gmunu_up() and jacobian() in one go ";

%feature("docstring")  Gyoto::Metric::KerrBL::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3). ";

%feature("docstring")  Gyoto::Metric::KerrBL::myrk4 "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::KerrBL::myrk4_adaptive "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::KerrBL::diff "

F function such as dx/dt=F(x,cst) ";

%feature("docstring")  Gyoto::Metric::KerrBL::diff "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::KerrBL::diff "";

%feature("docstring")  Gyoto::Metric::KerrBL::setParticleProperties "

Set Metric-specific constants of motion. Used e.g. in KerrBL. ";

%feature("docstring")  Gyoto::Metric::KerrBL::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Metric::KerrBL::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Metric::KerrBL::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Metric::KerrBL::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Metric::KerrBL::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Metric::KerrBL::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Metric::KerrBL::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Metric::KerrBL::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Metric::KerrBL::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Metric::KerrBL::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Metric::KerrBL::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Metric::KerrBL::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Metric::KerrBL::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Metric::KerrBL::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Metric::KerrBL::setParameters "

Main loop for parsing Properties from XML description.

This function queries the FactoryMessenger for elements to parse, and
tries to matche each element to a Property to set it  accordingly. Any
class that tries to be buildable from XML must supply a subcontractor
(for base classes such as Metric, Astrobj, Spectrum  and Spectrometer,
it is done as a template that must be  specialized for each class).
This subcontractor typically looks somewhat like this: Although this
is discouraged, it is possible to override the following functions to
customize how XML entities are parsed:    - setParameters() if low-
level access to the      FactoryMessenger is required;    -
setParameter(std::string name, std::string content,
std::string unit)      to interpret an entity that does not match a
Property      (e.g. alternative name);    -
setParameter(Gyoto::Property const &p, std::string const &name,
std::string const &content, std::string const &unit)      to change
how a Property is interpreted. ";

%feature("docstring")  Gyoto::Metric::KerrBL::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Metric::KerrBL::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Metric::KerrBL::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Metric::KerrBL::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Metric::KerrBL::kind "

Get kind_. ";

%feature("docstring")  Gyoto::Metric::KerrBL::hook "

Start listening.

Use from a Hook::Listener object method: where \"this\" is a Listener
and \"teller\" is a Teller.

Use unhook() later to stop listening to a given Teller.

Parameters:
-----------

listener:  pointer to the new listener ";

%feature("docstring")  Gyoto::Metric::KerrBL::unhook "

Stop listening.

Use from a Hook::Listener object method:

where \"this\" is a Listener, \"teller\" is a Teller, and \"this\" has
called teller->hook(this) previously.

Parameters:
-----------

listener:  pointer to the listener ";


// File: class_gyoto_1_1_metric_1_1_kerr_k_s.xml
%feature("docstring") Gyoto::Metric::KerrKS "

Metric around a Kerr black-hole in Kerr-Schild coordinates Warning:
this metric is seldom used and may be buggy.

By default, uses the generic integrator ( Metric::Generic::myrk4()).
Use to use the specific integretor which is, as of writting, buggy.

C++ includes: GyotoKerrKS.h ";

%feature("docstring")  Gyoto::Metric::KerrKS::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Metric::KerrKS::KerrKS "

Default constructor. ";

%feature("docstring")  Gyoto::Metric::KerrKS::clone "

Copy constructor. ";

%feature("docstring")  Gyoto::Metric::KerrKS::spin "

Set spin. ";

%feature("docstring")  Gyoto::Metric::KerrKS::spin "

Returns spin. ";

%feature("docstring")  Gyoto::Metric::KerrKS::horizonSecurity "";

%feature("docstring")  Gyoto::Metric::KerrKS::horizonSecurity "";

%feature("docstring")  Gyoto::Metric::KerrKS::gmunu "

Metric coefficients.

The default implementation calls Metric:: gmunu(double g[4][4], const
double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::KerrKS::gmunu "

Metric coefficients.

The default implementation calls double gmunu(const double * x, int
mu, int nu) const.

Parameters:
-----------

ARGOUT_ARRAY2:  (g) 4x4 array to store the coeefficients

IN_ARRAY1:  (x) 4-position at which to compute the coefficients;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::KerrKS::gmunu_up "

The inverse matrix of gmunu. ";

%feature("docstring")  Gyoto::Metric::KerrKS::jacobian "

The derivatives of gmunu.

Used in the test suite ";

%feature("docstring")  Gyoto::Metric::KerrKS::gmunu_up_and_jacobian "

gmunu_up() and jacobian() in one go ";

%feature("docstring")  Gyoto::Metric::KerrKS::circularVelocity "

Yield circular velocity at a given position.

Give the velocity of a massive particle in circular orbit at the given
position projected onto the equatorial plane. Such a velocity may not
exist everywhere (or anywhere) for a given metric. This method is
intended to be used by Astrobj classes such as Torus or ThinDisk.

If keplerian_ is set to true, this method should return the Keplerian
velcity instead (derived classes should ensure this, see
KerrBL::circularVelocity() for instance).

The default implementation throws an error if keplerian_ is set to
false.

Parameters:
-----------

pos:  input: position,

vel:  output: velocity,

dir:  1 for corotating, -1 for counterrotating. ";

%feature("docstring")  Gyoto::Metric::KerrKS::isStopCondition "

Check whether integration should stop.

The integrating loop will ask this the Metric through this method
whether or not it is happy to continue the integration. Typically, the
Metric should answer 0 when everything is fine, 1 when too close to
the event horizon, inside the BH...

Parameters:
-----------

coord:  8-coordinate vector to check. ";

%feature("docstring")  Gyoto::Metric::KerrKS::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Metric::KerrKS::coordKind "

Get coordinate kind. ";

%feature("docstring")  Gyoto::Metric::KerrKS::getRefCount "";

%feature("docstring")  Gyoto::Metric::KerrKS::mass "

Set mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::KerrKS::mass "

Set mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::KerrKS::mass "

Get mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::KerrKS::mass "

Get mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::KerrKS::unitLength "

M * G / c^2, M is in kg, unitLength in meters.

Metrics implementations are free to express lengths and distances in
whatever unit they see fit (presumably most often geometrical units).
This function returns this unit in SI (meters). ";

%feature("docstring")  Gyoto::Metric::KerrKS::unitLength "

unitLength expressed in specified unit ";

%feature("docstring")  Gyoto::Metric::KerrKS::getRmb "

Returns the marginally bound radius Should be implemented in derived
classes if useful If called on the base class, returns an error ";

%feature("docstring")  Gyoto::Metric::KerrKS::getRms "

Returns the marginally stable (ISCO) radius Should be implemented in
derived classes if useful If called on the base class, returns an
error ";

%feature("docstring")
Gyoto::Metric::KerrKS::getSpecificAngularMomentum "

Returns the specific angular momentum l=-u_phi/u_t Should be
implemented in derived classes if useful If called on the base class,
returns an error ";

%feature("docstring")  Gyoto::Metric::KerrKS::getPotential "

Returns potential W=-ln(|u_t|) for a cst specific angular momentum
l_cst Should be implemented in derived classes if useful If called on
the base class, returns an error ";

%feature("docstring")  Gyoto::Metric::KerrKS::deltaMin "

Get delta_min_ ";

%feature("docstring")  Gyoto::Metric::KerrKS::deltaMin "

Set delta_min_ ";

%feature("docstring")  Gyoto::Metric::KerrKS::deltaMax "

Get delta_max_ ";

%feature("docstring")  Gyoto::Metric::KerrKS::deltaMax "

Get delta max at a given position

Parameters:
-----------

pos:  4-position

[optional]:  delta_max_external external constraint on delta_max

the smallest value between delta_max_, delta_max_external, and
R*delta_max_over_r_ where R is pos[1] in spherical coordinates and
max(x1, x2, x3) in Cartesian coordinates. ";

%feature("docstring")  Gyoto::Metric::KerrKS::deltaMax "

Set delta_max_ ";

%feature("docstring")  Gyoto::Metric::KerrKS::deltaMaxOverR "

Get delta_max_over_r_. ";

%feature("docstring")  Gyoto::Metric::KerrKS::deltaMaxOverR "

Set delta_max_over_r_. ";

%feature("docstring")  Gyoto::Metric::KerrKS::keplerian "

Get keplerian_. ";

%feature("docstring")  Gyoto::Metric::KerrKS::keplerian "

Set keplerian_. ";

%feature("docstring")  Gyoto::Metric::KerrKS::cartesianVelocity "

Compute xprime, yprime and zprime from 8-coordinates. ";

%feature("docstring")  Gyoto::Metric::KerrKS::SysPrimeToTdot "

Compute tdot as a function of dr/dt, dtheta/dt and dphi/dt. Everything
is in geometrical units.

Parameters:
-----------

coord:  4-position (geometrical units);

v:  3-velocity dx1/dx0, dx2/dx0, dx3/dx0;

tdot = dx0/dtau. ";

%feature("docstring")  Gyoto::Metric::KerrKS::zamoVelocity "

Yield ZAMO velocity at a given position.

Give the velocity of a zero angular momentul observer (whatever is
closest to \"at rest\"). The default implementation simply projects
(1, 0, 0, 0) othogonally along ephi and normalizes it, thus ensuring
that vel is orthogonal to ephi.

Parameters:
-----------

pos:  input: position,

vel:  output: velocity, ";

%feature("docstring")  Gyoto::Metric::KerrKS::nullifyCoord "

Set tdot (coord[4]) such that coord is light-like. Everything is in
geometrical units.

Set coord[4] so that the 4-velocity coord[4:7] is lightlike, i.e. of
norm 0. There may be up to two solutions. coord[4] is set to the
hightest. The lowest can be retrieved using nullifyCoord(double
coord[8], double& tdot2) const. Everything is expressed in geometrical
units.

Parameters:
-----------

coord:  8-position, coord[4] will be set according to the other
elements; ";

%feature("docstring")  Gyoto::Metric::KerrKS::nullifyCoord "

Set tdot (coord[4]) such that coord is light-like and return other
possible tdot.

Set coord[4] so that the 4-velocity coord[4:7] is lightlike, i.e. of
norm 0. There may be up to two solutions. coord[4] is set to the
hightest. The lowest can be retrieved in tdot2. Everything is
expressed in geometrical units.

Parameters:
-----------

coord:  8-position, coord[4] will be set according to the other
elements;

tdot2:  will be set to the smallest solution ";

%feature("docstring")  Gyoto::Metric::KerrKS::normalizeFourVel "

Normalize fourvelvel to -1.

First computes threevel as xiprime=xidot/x0dot for i in {1, 2, 3},
then computes x0dot using SyPrimeToTdot, then computes again xidot as
xidot=xiprime*x0dot.

Parameters:
-----------

coord:  8-position, coord[4-7] will be set according to the other
elements; ";

%feature("docstring")  Gyoto::Metric::KerrKS::normalizeFourVel "

Normalize fourvelvel to -1.

First computes threevel as xiprime=xidot/x0dot for i in {1, 2, 3},
then computes x0dot using SyPrimeToTdot, then computes again xidot as
xidot=xiprime*x0dot.

Parameters:
-----------

pos:  4-position;

fourvel:  4-velocity, will be renormalized. ";

%feature("docstring")  Gyoto::Metric::KerrKS::ScalarProd "

Scalar product.

Compute the scalarproduct of the two quadrivectors u1 and u2 in this
Metric, at point pos expressed in coordinate system sys.

Parameters:
-----------

pos:  4-position;

u1:  1st quadrivector;

u2:  2nd quadrivector;

u1*u2 ";

%feature("docstring")  Gyoto::Metric::KerrKS::norm "

Scalar product.

Compute the norm of the quadrivector u1 in this Metric, at point pos
expressed in coordinate system sys.

Parameters:
-----------

pos:  4-position;

u1:  quadrivector;

||u1|| ";

%feature("docstring")  Gyoto::Metric::KerrKS::multiplyFourVect "

multiply vector by scalar ";

%feature("docstring")  Gyoto::Metric::KerrKS::addFourVect "

add second vector to first one ";

%feature("docstring")  Gyoto::Metric::KerrKS::projectFourVect "

project u1 orthogonally to u2 at pos ";

%feature("docstring")  Gyoto::Metric::KerrKS::dualOneForm "

Computes dual 1-form Compute the dual 1-form of 4-vector.

Parameters:
-----------

IN_ARRAY1_1:  4-position;

IN_ARRAY1_2:  quadrivector;

ARGOUT_ARRAY1:  output 1-form ";

%feature("docstring")  Gyoto::Metric::KerrKS::observerTetrad "

Computes the orthonormal local tetrad of the observer.

Parameters:
-----------

obskind:  input: kind of observer (eg:
\"ZAMO\",\"KeplerianObserver\"...)

pos:  input: position,

fourvel:  output: observer 4-velocity (norm -1)

screen1:  output: first vector in the screen plane

screen2:  output: second vector in the screen plane

screen3:  output: vector normal to the screen ";

%feature("docstring")  Gyoto::Metric::KerrKS::observerTetrad "

Computes the orthonormal local tetrad of the observer.

Parameters:
-----------

pos:  position,

fourvel:  observer 4-velocity (norm -1)

screen1:  first vector in the screen plane

screen2:  second vector in the screen plane

screen3:  vector normal to the screen ";

%feature("docstring")  Gyoto::Metric::KerrKS::GramSchmidt "

Apply Gram-Schmidt orthonormalization to a basis.

On input, u0 to u3 must be four non-zero norm, independent 4-vectors.
On output, they will form an orthonormal basis.

Parameters:
-----------

pos:  position,

u0:  basis vector

u1:  basis vector

u2:  basis vector

u3:  basis vector ";

%feature("docstring")  Gyoto::Metric::KerrKS::gmunu_up "

Metric contravariant coefficients.

The default implementation calls Metric:: gmunu_up(double g[4][4],
const double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::KerrKS::computeNBeta "

Computes lapse scalar and shift vector at coord. ";

%feature("docstring")  Gyoto::Metric::KerrKS::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3). ";

%feature("docstring")  Gyoto::Metric::KerrKS::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3).

1 on error, 0 otherwise ";

%feature("docstring")  Gyoto::Metric::KerrKS::myrk4 "

RK4 integrator. ";

%feature("docstring")  Gyoto::Metric::KerrKS::myrk4 "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::KerrKS::myrk4_adaptive "

RK4 integrator with adaptive step. ";

%feature("docstring")  Gyoto::Metric::KerrKS::myrk4_adaptive "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::KerrKS::diff "

F function such as dx/dt=F(x,cst) ";

%feature("docstring")  Gyoto::Metric::KerrKS::diff "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::KerrKS::diff "";

%feature("docstring")  Gyoto::Metric::KerrKS::diff31 "

F function such as dx/dt=F(x,cst) for 3+1 case. ";

%feature("docstring")  Gyoto::Metric::KerrKS::setParticleProperties "

Set Metric-specific constants of motion. Used e.g. in KerrBL. ";

%feature("docstring")  Gyoto::Metric::KerrKS::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Metric::KerrKS::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Metric::KerrKS::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Metric::KerrKS::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Metric::KerrKS::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Metric::KerrKS::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Metric::KerrKS::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Metric::KerrKS::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Metric::KerrKS::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Metric::KerrKS::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Metric::KerrKS::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Metric::KerrKS::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Metric::KerrKS::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Metric::KerrKS::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Metric::KerrKS::setParameters "

Main loop for parsing Properties from XML description.

This function queries the FactoryMessenger for elements to parse, and
tries to matche each element to a Property to set it  accordingly. Any
class that tries to be buildable from XML must supply a subcontractor
(for base classes such as Metric, Astrobj, Spectrum  and Spectrometer,
it is done as a template that must be  specialized for each class).
This subcontractor typically looks somewhat like this: Although this
is discouraged, it is possible to override the following functions to
customize how XML entities are parsed:    - setParameters() if low-
level access to the      FactoryMessenger is required;    -
setParameter(std::string name, std::string content,
std::string unit)      to interpret an entity that does not match a
Property      (e.g. alternative name);    -
setParameter(Gyoto::Property const &p, std::string const &name,
std::string const &content, std::string const &unit)      to change
how a Property is interpreted. ";

%feature("docstring")  Gyoto::Metric::KerrKS::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Metric::KerrKS::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Metric::KerrKS::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Metric::KerrKS::kind "

Get kind_. ";

%feature("docstring")  Gyoto::Metric::KerrKS::hook "

Start listening.

Use from a Hook::Listener object method: where \"this\" is a Listener
and \"teller\" is a Teller.

Use unhook() later to stop listening to a given Teller.

Parameters:
-----------

listener:  pointer to the new listener ";

%feature("docstring")  Gyoto::Metric::KerrKS::unhook "

Stop listening.

Use from a Hook::Listener object method:

where \"this\" is a Listener, \"teller\" is a Teller, and \"this\" has
called teller->hook(this) previously.

Parameters:
-----------

listener:  pointer to the listener ";


// File: class_gyoto_1_1_worldline_1_1_integ_state_1_1_legacy.xml
%feature("docstring") Gyoto::Worldline::IntegState::Legacy "

Obsolete: Home-brewed integrator.

Will be removed soon.

The integrator used by this IntegState::Generic implementation is
actually implemented in Metric::Generic::myrk4_adaptive(). It does not
use most of the tuning parameters Worldline, it uses the homonym
parameters in Metric::Generic instead. to use this integrator, pass
\"Legacy\" to Worldline::integrator(std::string type).

C++ includes: GyotoWorldline.h ";

%feature("docstring")  Gyoto::Worldline::IntegState::Legacy::Legacy "

Constructor. ";

%feature("docstring")  Gyoto::Worldline::IntegState::Legacy::clone "

Deep copy.

Derived classes must implement it ";

%feature("docstring")  Gyoto::Worldline::IntegState::Legacy::init "

Parameters:

line:  The Worldline that we are integrating. Sets: Worldline::line_,
Worldline::gg_, Worldline::adaptive_.

coord:  Initial coordinate.

delta:  Integration step. Sign determines direction. ";

%feature("docstring")  Gyoto::Worldline::IntegState::Legacy::kind "

Return the integrator kind. ";

%feature("docstring")  Gyoto::Worldline::IntegState::Legacy::nextStep
"

Make one step.

Parameters:
-----------

coord:  Next position-velocity;

tau:  Next proper time or affine parameter

h1max:  maximum step in case of adaptive integration ";

%feature("docstring")  Gyoto::Worldline::IntegState::Legacy::doStep "

Make one step of exactly this size.

doStep() is meant to refine a computation made using nextStep(). In
particular, there is no checking for norm conservation.

Parameters:
-----------

coordin:  current position-velocity;

step:  exact step to use.

coordout:  next position-velocity; ";

%feature("docstring")  Gyoto::Worldline::IntegState::Legacy::~Legacy "";

%feature("docstring")  Gyoto::Worldline::IntegState::Legacy::init "

Parameters:

line:  The Worldline that we are integrating. Sets: Worldline::line_,
Worldline::gg_, Worldline::adaptive_.

coord:  Initial coordinate.

delta:  Integration step. Sign determines direction. ";

%feature("docstring")  Gyoto::Worldline::IntegState::Legacy::init "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Worldline::IntegState::Legacy::init "

Cache whatever needs to be cached.

This is called by all the methods in Worldline each time an member
that could be cached in Worldline::state_ changes. Therefore, user
code should normally not have to call it. ";

%feature("docstring")  Gyoto::Worldline::IntegState::Legacy::init "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Worldline::IntegState::Legacy::checkNorm
"

Check norm.

Issue a warning using GYOTO_SEVERE if norm is drifting. nextStep()
implementations should call it. ";

%feature("docstring")  Gyoto::Worldline::IntegState::Legacy::integ31 "

Defines the kind of geodesic equation to integrate (3+1, 4D) ";

%feature("docstring")  Gyoto::Worldline::IntegState::Legacy::integ31 "";

%feature("docstring")  Gyoto::Worldline::IntegState::Legacy::nextStep
"

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Worldline::IntegState::Legacy::doStep "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Worldline::IntegState::Legacy::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")
Gyoto::Worldline::IntegState::Legacy::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")
Gyoto::Worldline::IntegState::Legacy::getRefCount "

Get the current number of references. ";


// File: class_gyoto_1_1_hook_1_1_listener.xml
%feature("docstring") Gyoto::Hook::Listener "

I might listen to a Teller.

Whisper to my ear by using my tell() method.

C++ includes: GyotoHooks.h ";

%feature("docstring")  Gyoto::Hook::Listener::Listener "

Constructor. ";

%feature("docstring")  Gyoto::Hook::Listener::~Listener "

Destructor. ";


// File: class_listener_item.xml


// File: class_gyoto_1_1_metric_1_1_minkowski.xml
%feature("docstring") Gyoto::Metric::Minkowski "

The Minkowski flat-space metric.

Use <Cartesian> or </Spherical> to select the coordinate system kind.

C++ includes: GyotoMinkowski.h ";

%feature("docstring")  Gyoto::Metric::Minkowski::spherical "";

%feature("docstring")  Gyoto::Metric::Minkowski::spherical "";

%feature("docstring")  Gyoto::Metric::Minkowski::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Metric::Minkowski::Minkowski "";

%feature("docstring")  Gyoto::Metric::Minkowski::clone "

Virtual copy constructor. ";

%feature("docstring")  Gyoto::Metric::Minkowski::gmunu "

Metric coefficients.

The default implementation calls double gmunu(const double * x, int
mu, int nu) const.

Parameters:
-----------

ARGOUT_ARRAY2:  (g) 4x4 array to store the coeefficients

IN_ARRAY1:  (x) 4-position at which to compute the coefficients;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::Minkowski::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3).

1 on error, 0 otherwise ";

%feature("docstring")  Gyoto::Metric::Minkowski::gmunu "

Metric coefficients.

The default implementation calls Metric:: gmunu(double g[4][4], const
double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::Minkowski::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3). ";

%feature("docstring")  Gyoto::Metric::Minkowski::observerTetrad "

Computes the orthonormal local tetrad of the observer.

Parameters:
-----------

obskind:  input: kind of observer (eg:
\"ZAMO\",\"KeplerianObserver\"...)

pos:  input: position,

fourvel:  output: observer 4-velocity (norm -1)

screen1:  output: first vector in the screen plane

screen2:  output: second vector in the screen plane

screen3:  output: vector normal to the screen ";

%feature("docstring")  Gyoto::Metric::Minkowski::diff "

F function such as dx/dt=F(x,cst) ";

%feature("docstring")  Gyoto::Metric::Minkowski::coordKind "

Get coordinate kind. ";

%feature("docstring")  Gyoto::Metric::Minkowski::getRefCount "";

%feature("docstring")  Gyoto::Metric::Minkowski::mass "

Set mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::Minkowski::mass "

Set mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::Minkowski::mass "

Get mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::Minkowski::mass "

Get mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::Minkowski::unitLength "

M * G / c^2, M is in kg, unitLength in meters.

Metrics implementations are free to express lengths and distances in
whatever unit they see fit (presumably most often geometrical units).
This function returns this unit in SI (meters). ";

%feature("docstring")  Gyoto::Metric::Minkowski::unitLength "

unitLength expressed in specified unit ";

%feature("docstring")  Gyoto::Metric::Minkowski::getRmb "

Returns the marginally bound radius Should be implemented in derived
classes if useful If called on the base class, returns an error ";

%feature("docstring")  Gyoto::Metric::Minkowski::getRms "

Returns the marginally stable (ISCO) radius Should be implemented in
derived classes if useful If called on the base class, returns an
error ";

%feature("docstring")
Gyoto::Metric::Minkowski::getSpecificAngularMomentum "

Returns the specific angular momentum l=-u_phi/u_t Should be
implemented in derived classes if useful If called on the base class,
returns an error ";

%feature("docstring")  Gyoto::Metric::Minkowski::getPotential "

Returns potential W=-ln(|u_t|) for a cst specific angular momentum
l_cst Should be implemented in derived classes if useful If called on
the base class, returns an error ";

%feature("docstring")  Gyoto::Metric::Minkowski::deltaMin "

Get delta_min_ ";

%feature("docstring")  Gyoto::Metric::Minkowski::deltaMin "

Set delta_min_ ";

%feature("docstring")  Gyoto::Metric::Minkowski::deltaMax "

Get delta_max_ ";

%feature("docstring")  Gyoto::Metric::Minkowski::deltaMax "

Get delta max at a given position

Parameters:
-----------

pos:  4-position

[optional]:  delta_max_external external constraint on delta_max

the smallest value between delta_max_, delta_max_external, and
R*delta_max_over_r_ where R is pos[1] in spherical coordinates and
max(x1, x2, x3) in Cartesian coordinates. ";

%feature("docstring")  Gyoto::Metric::Minkowski::deltaMax "

Set delta_max_ ";

%feature("docstring")  Gyoto::Metric::Minkowski::deltaMaxOverR "

Get delta_max_over_r_. ";

%feature("docstring")  Gyoto::Metric::Minkowski::deltaMaxOverR "

Set delta_max_over_r_. ";

%feature("docstring")  Gyoto::Metric::Minkowski::keplerian "

Get keplerian_. ";

%feature("docstring")  Gyoto::Metric::Minkowski::keplerian "

Set keplerian_. ";

%feature("docstring")  Gyoto::Metric::Minkowski::cartesianVelocity "

Compute xprime, yprime and zprime from 8-coordinates. ";

%feature("docstring")  Gyoto::Metric::Minkowski::SysPrimeToTdot "

Compute tdot as a function of dr/dt, dtheta/dt and dphi/dt. Everything
is in geometrical units.

Parameters:
-----------

coord:  4-position (geometrical units);

v:  3-velocity dx1/dx0, dx2/dx0, dx3/dx0;

tdot = dx0/dtau. ";

%feature("docstring")  Gyoto::Metric::Minkowski::circularVelocity "

Yield circular velocity at a given position.

Give the velocity of a massive particle in circular orbit at the given
position projected onto the equatorial plane. Such a velocity may not
exist everywhere (or anywhere) for a given metric. This method is
intended to be used by Astrobj classes such as Torus or ThinDisk.

If keplerian_ is set to true, this method should return the Keplerian
velcity instead (derived classes should ensure this, see
KerrBL::circularVelocity() for instance).

The default implementation throws an error if keplerian_ is set to
false.

Parameters:
-----------

pos:  input: position,

vel:  output: velocity,

dir:  1 for corotating, -1 for counterrotating. ";

%feature("docstring")  Gyoto::Metric::Minkowski::zamoVelocity "

Yield ZAMO velocity at a given position.

Give the velocity of a zero angular momentul observer (whatever is
closest to \"at rest\"). The default implementation simply projects
(1, 0, 0, 0) othogonally along ephi and normalizes it, thus ensuring
that vel is orthogonal to ephi.

Parameters:
-----------

pos:  input: position,

vel:  output: velocity, ";

%feature("docstring")  Gyoto::Metric::Minkowski::nullifyCoord "

Set tdot (coord[4]) such that coord is light-like. Everything is in
geometrical units.

Set coord[4] so that the 4-velocity coord[4:7] is lightlike, i.e. of
norm 0. There may be up to two solutions. coord[4] is set to the
hightest. The lowest can be retrieved using nullifyCoord(double
coord[8], double& tdot2) const. Everything is expressed in geometrical
units.

Parameters:
-----------

coord:  8-position, coord[4] will be set according to the other
elements; ";

%feature("docstring")  Gyoto::Metric::Minkowski::nullifyCoord "

Set tdot (coord[4]) such that coord is light-like and return other
possible tdot.

Set coord[4] so that the 4-velocity coord[4:7] is lightlike, i.e. of
norm 0. There may be up to two solutions. coord[4] is set to the
hightest. The lowest can be retrieved in tdot2. Everything is
expressed in geometrical units.

Parameters:
-----------

coord:  8-position, coord[4] will be set according to the other
elements;

tdot2:  will be set to the smallest solution ";

%feature("docstring")  Gyoto::Metric::Minkowski::normalizeFourVel "

Normalize fourvelvel to -1.

First computes threevel as xiprime=xidot/x0dot for i in {1, 2, 3},
then computes x0dot using SyPrimeToTdot, then computes again xidot as
xidot=xiprime*x0dot.

Parameters:
-----------

coord:  8-position, coord[4-7] will be set according to the other
elements; ";

%feature("docstring")  Gyoto::Metric::Minkowski::normalizeFourVel "

Normalize fourvelvel to -1.

First computes threevel as xiprime=xidot/x0dot for i in {1, 2, 3},
then computes x0dot using SyPrimeToTdot, then computes again xidot as
xidot=xiprime*x0dot.

Parameters:
-----------

pos:  4-position;

fourvel:  4-velocity, will be renormalized. ";

%feature("docstring")  Gyoto::Metric::Minkowski::ScalarProd "

Scalar product.

Compute the scalarproduct of the two quadrivectors u1 and u2 in this
Metric, at point pos expressed in coordinate system sys.

Parameters:
-----------

pos:  4-position;

u1:  1st quadrivector;

u2:  2nd quadrivector;

u1*u2 ";

%feature("docstring")  Gyoto::Metric::Minkowski::norm "

Scalar product.

Compute the norm of the quadrivector u1 in this Metric, at point pos
expressed in coordinate system sys.

Parameters:
-----------

pos:  4-position;

u1:  quadrivector;

||u1|| ";

%feature("docstring")  Gyoto::Metric::Minkowski::multiplyFourVect "

multiply vector by scalar ";

%feature("docstring")  Gyoto::Metric::Minkowski::addFourVect "

add second vector to first one ";

%feature("docstring")  Gyoto::Metric::Minkowski::projectFourVect "

project u1 orthogonally to u2 at pos ";

%feature("docstring")  Gyoto::Metric::Minkowski::dualOneForm "

Computes dual 1-form Compute the dual 1-form of 4-vector.

Parameters:
-----------

IN_ARRAY1_1:  4-position;

IN_ARRAY1_2:  quadrivector;

ARGOUT_ARRAY1:  output 1-form ";

%feature("docstring")  Gyoto::Metric::Minkowski::observerTetrad "

Computes the orthonormal local tetrad of the observer.

Parameters:
-----------

pos:  position,

fourvel:  observer 4-velocity (norm -1)

screen1:  first vector in the screen plane

screen2:  second vector in the screen plane

screen3:  vector normal to the screen ";

%feature("docstring")  Gyoto::Metric::Minkowski::GramSchmidt "

Apply Gram-Schmidt orthonormalization to a basis.

On input, u0 to u3 must be four non-zero norm, independent 4-vectors.
On output, they will form an orthonormal basis.

Parameters:
-----------

pos:  position,

u0:  basis vector

u1:  basis vector

u2:  basis vector

u3:  basis vector ";

%feature("docstring")  Gyoto::Metric::Minkowski::gmunu_up "

Metric contravariant coefficients.

The default implementation calls Metric:: gmunu_up(double g[4][4],
const double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::Minkowski::gmunu_up "

Metric contravariant coefficients.

The default implementation inverts the covariant coefficients matrix.
";

%feature("docstring")  Gyoto::Metric::Minkowski::jacobian "

Derivatives of the metric covariant coefficients.

The default implementation evaluates them numerically. The gmunu
matrix is assumed to be symmetrical but no other assumptions are made
at the moment. ";

%feature("docstring")  Gyoto::Metric::Minkowski::gmunu_up_and_jacobian
"

gmunu_up() and jacobian() in one go ";

%feature("docstring")  Gyoto::Metric::Minkowski::computeNBeta "

Computes lapse scalar and shift vector at coord. ";

%feature("docstring")  Gyoto::Metric::Minkowski::myrk4 "

RK4 integrator. ";

%feature("docstring")  Gyoto::Metric::Minkowski::myrk4 "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::Minkowski::myrk4_adaptive "

RK4 integrator with adaptive step. ";

%feature("docstring")  Gyoto::Metric::Minkowski::myrk4_adaptive "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::Minkowski::isStopCondition "

Check whether integration should stop.

The integrating loop will ask this the Metric through this method
whether or not it is happy to continue the integration. Typically, the
Metric should answer 0 when everything is fine, 1 when too close to
the event horizon, inside the BH...

Parameters:
-----------

coord:  8-coordinate vector to check. ";

%feature("docstring")  Gyoto::Metric::Minkowski::diff "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::Minkowski::diff "";

%feature("docstring")  Gyoto::Metric::Minkowski::diff31 "

F function such as dx/dt=F(x,cst) for 3+1 case. ";

%feature("docstring")  Gyoto::Metric::Minkowski::setParticleProperties
"

Set Metric-specific constants of motion. Used e.g. in KerrBL. ";

%feature("docstring")  Gyoto::Metric::Minkowski::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Metric::Minkowski::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Metric::Minkowski::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Metric::Minkowski::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Metric::Minkowski::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Metric::Minkowski::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Metric::Minkowski::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Metric::Minkowski::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Metric::Minkowski::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Metric::Minkowski::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Metric::Minkowski::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Metric::Minkowski::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Metric::Minkowski::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Metric::Minkowski::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Metric::Minkowski::setParameters "

Main loop for parsing Properties from XML description.

This function queries the FactoryMessenger for elements to parse, and
tries to matche each element to a Property to set it  accordingly. Any
class that tries to be buildable from XML must supply a subcontractor
(for base classes such as Metric, Astrobj, Spectrum  and Spectrometer,
it is done as a template that must be  specialized for each class).
This subcontractor typically looks somewhat like this: Although this
is discouraged, it is possible to override the following functions to
customize how XML entities are parsed:    - setParameters() if low-
level access to the      FactoryMessenger is required;    -
setParameter(std::string name, std::string content,
std::string unit)      to interpret an entity that does not match a
Property      (e.g. alternative name);    -
setParameter(Gyoto::Property const &p, std::string const &name,
std::string const &content, std::string const &unit)      to change
how a Property is interpreted. ";

%feature("docstring")  Gyoto::Metric::Minkowski::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Metric::Minkowski::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Metric::Minkowski::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Metric::Minkowski::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Metric::Minkowski::kind "

Get kind_. ";

%feature("docstring")  Gyoto::Metric::Minkowski::hook "

Start listening.

Use from a Hook::Listener object method: where \"this\" is a Listener
and \"teller\" is a Teller.

Use unhook() later to stop listening to a given Teller.

Parameters:
-----------

listener:  pointer to the new listener ";

%feature("docstring")  Gyoto::Metric::Minkowski::unhook "

Stop listening.

Use from a Hook::Listener object method:

where \"this\" is a Listener, \"teller\" is a Teller, and \"this\" has
called teller->hook(this) previously.

Parameters:
-----------

listener:  pointer to the listener ";


// File: class_gyoto_1_1_astrobj_1_1_neutron_star.xml
%feature("docstring") Gyoto::Astrobj::NeutronStar "

Neutron star defined by its surface ; no emission.

The underlying Gyoto::Metric::Generic gg_ instance must be a
Gyoto::Metric::NumericalMetricLorene describing a neutron star.

C++ includes: GyotoNeutronStar.h ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::NeutronStar "

Standard constructor. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::NeutronStar "";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::NeutronStar "

Copy constructor. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::clone "

Cloner. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::~NeutronStar "

Destructor. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::metric "

Get gg_. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::metric "

Set gg_. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::getVelocity "

Fluid velocity field.

Fill vel with the 4-vector velocity of the fluid at 4-position pos.

Parameters:
-----------

pos:  4-position at which to compute velocity;

vel:  4-velocity at pos. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::safetyValue "

Set Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::safetyValue "

Get Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::deltaInObj "

Get Generic::delta_inobj_.

Get the constant integration step inside the astrobj

delta_inobj_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::deltaInObj "

Set Generic::delta_inobj_. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::giveDelta "

Maximum inside object.

Gives the requested integration stept (in coordinate time t) between
two neighbooring points along a portion of geodesic inside an astrobj;
the current implementation only considers a constant delta, equal to
Standard::deltaInobj()

Parameters:
-----------

coord:  input coordinate at whicht is given ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")
Gyoto::Astrobj::NeutronStar::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::showshadow "";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::showshadow "";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::redshift "";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::redshift "";

%feature("docstring")
Gyoto::Astrobj::NeutronStar::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")
Gyoto::Astrobj::NeutronStar::processHitQuantities "

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStar::processHitQuantities "";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::emission "

Specific intensity I

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem, in the emitter's frame. It should take self-absorption
along dsem into account.

Reminder : intensity = I [J m^-2 s^-1 ster^-1 Hz^-1];

invariant intensity = I/3, which has the same value in any frame;

emission coefficient = j [J m^-3 s^-1 ster^-1 Hz^-1] , defined by dI =
j*ds, where ds is the distance travelled by the photon inside the
object;

invariant emission coef = j/2, which has the same value in any frame.

The equation used for radiative transfer (without absorption) is:

d(I/3)/d = (j/2) [*]

where is the integration parameter along the null geodesic.

NB: Let us consider a particular observer, with being the frequency
measured by this observer, and ds being the proper distance (as
measured by the observer) that the photon travels as it moves from
to+d along its geodesic. Then it can be shown that:

d = ds/

This shows that Eq. [*] is homogeneous.

The default implementation returns 1. if optically thick and dsem if
optically thin. It allows for a quick implementation of your object
for visualization purposes.

Parameters:
-----------

nu_em:  Frequency at emission [Hz]

dsem:  length over which to integrate inside the object [geometrical
units]

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::radiativeQ "

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::integrateEmission
"

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::integrateEmission
"

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::integrateEmission
"

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::integrateEmission
"

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")
Gyoto::Astrobj::NeutronStar::computeB4vect_ipole "";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStar::kind "

Get kind_. ";


// File: class_gyoto_1_1_astrobj_1_1_neutron_star_analytic_emission.xml
%feature("docstring") Gyoto::Astrobj::NeutronStarAnalyticEmission "

Neutron star emitting at its surface an analytic emission, typically
blackbody.

The emission law is given by spectrum_.

C++ includes: GyotoNeutronStarAnalyticEmission.h ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::NeutronStarAnalyticEmission
"

Standard constructor. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::NeutronStarAnalyticEmission
"

Copy constructor. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::clone "

Cloner. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::~NeutronStarAnalyticEmission
"

Destructor. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::spectrum "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::spectrum "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::emission "

Specific intensity I

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem, in the emitter's frame. It should take self-absorption
along dsem into account.

Reminder : intensity = I [J m^-2 s^-1 ster^-1 Hz^-1];

invariant intensity = I/3, which has the same value in any frame;

emission coefficient = j [J m^-3 s^-1 ster^-1 Hz^-1] , defined by dI =
j*ds, where ds is the distance travelled by the photon inside the
object;

invariant emission coef = j/2, which has the same value in any frame.

The equation used for radiative transfer (without absorption) is:

d(I/3)/d = (j/2) [*]

where is the integration parameter along the null geodesic.

NB: Let us consider a particular observer, with being the frequency
measured by this observer, and ds being the proper distance (as
measured by the observer) that the photon travels as it moves from
to+d along its geodesic. Then it can be shown that:

d = ds/

This shows that Eq. [*] is homogeneous.

The default implementation returns 1. if optically thick and dsem if
optically thin. It allows for a quick implementation of your object
for visualization purposes.

Parameters:
-----------

nu_em:  Frequency at emission [Hz]

dsem:  length over which to integrate inside the object [geometrical
units]

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::metric "

Get gg_. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::metric "

Set gg_. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::getVelocity "

Fluid velocity field.

Fill vel with the 4-vector velocity of the fluid at 4-position pos.

Parameters:
-----------

pos:  4-position at which to compute velocity;

vel:  4-velocity at pos. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::safetyValue "

Set Standard::safety_value_. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::safetyValue "

Get Standard::safety_value_. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::deltaInObj "

Get Generic::delta_inobj_.

Get the constant integration step inside the astrobj

delta_inobj_ in geometrical units ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::deltaInObj "

Set Generic::delta_inobj_. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::giveDelta "

Maximum inside object.

Gives the requested integration stept (in coordinate time t) between
two neighbooring points along a portion of geodesic inside an astrobj;
the current implementation only considers a constant delta, equal to
Standard::deltaInobj()

Parameters:
-----------

coord:  input coordinate at whicht is given ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::GYOTO_OBJECT_ACCESSORS_UNIT
"";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::showshadow "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::showshadow "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::redshift "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::redshift "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::processHitQuantities "

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::processHitQuantities "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::emission "

Obsolete, update your code;. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::emission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::radiativeQ "

emission and transmission together ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::radiativeQ "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::transmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::transmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::Omatrix "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::Omatrix "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::Omatrix "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::Pmatrix "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::rotateJs "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::computeB4vect_ipole "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::getRefCount "

Get the current number of references. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::set "

Set Value of a Property. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::set "

Set Value of a Property. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::get "

Get Value of a Property. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::get "

Get Value of a Property. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarAnalyticEmission::kind "

Get kind_. ";


// File: class_gyoto_1_1_astrobj_1_1_neutron_star_model_atmosphere.xml
%feature("docstring") Gyoto::Astrobj::NeutronStarModelAtmosphere "

Neutron star emitting at its surface an emission provided by a FITS
table.

C++ includes: GyotoNeutronStarModelAtmosphere.h ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::NeutronStarModelAtmosphere
"

Standard constructor. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::NeutronStarModelAtmosphere
"

Copy constructor. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::clone "

Cloner. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::~NeutronStarModelAtmosphere
"

Destructor. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::file "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::file "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::averageOverAngle "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::averageOverAngle "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::setEmission "

The pointer is copied directly, not the array content.

This is a low-level function. Beware that: previously allocated array
will not be freed automatically;

array attached when the destructor is called will be freed. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::surfgrav "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::copyIntensity "

NeutronStarModelAtmosphere::emission_ is freed if not NULL,
reallocated, and pattern is copied into emission_.

Finally, NeutronStarModelAtmosphere::nnu_,
NeutronStarModelAtmosphere::ni_, and NeutronStarModelAtmosphere::nsg_
are set according to naxes.

Parameters:
-----------

pattern:  Array to copy as emission_. May be NULL in which case
emission_ is simply deallocated and set to NULL.

naxes:  { nnu_, ni_, nsg_ }. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::getIntensity "

Get NeutronStarModelAtmosphere::emission_. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::getIntensityNaxes "

Get NeutronStarModelAtmosphere::nnu_, NeutronStarModelAtmosphere::ni_,
and NeutronStarModelAtmosphere::nsg_. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::copyGridSurfgrav "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::getGridSurfgrav "

Get NeutronStarModelAtmosphere::surfgrav_. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::copyGridCosi "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::getGridCosi "

Get NeutronStarModelAtmosphere::cosi_. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::copyGridFreq "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::getGridFreq "

Get NeutronStarModelAtmosphere::freq_. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::emission "

Specific intensity I

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem, in the emitter's frame. It should take self-absorption
along dsem into account.

Reminder : intensity = I [J m^-2 s^-1 ster^-1 Hz^-1];

invariant intensity = I/3, which has the same value in any frame;

emission coefficient = j [J m^-3 s^-1 ster^-1 Hz^-1] , defined by dI =
j*ds, where ds is the distance travelled by the photon inside the
object;

invariant emission coef = j/2, which has the same value in any frame.

The equation used for radiative transfer (without absorption) is:

d(I/3)/d = (j/2) [*]

where is the integration parameter along the null geodesic.

NB: Let us consider a particular observer, with being the frequency
measured by this observer, and ds being the proper distance (as
measured by the observer) that the photon travels as it moves from
to+d along its geodesic. Then it can be shown that:

d = ds/

This shows that Eq. [*] is homogeneous.

The default implementation returns 1. if optically thick and dsem if
optically thin. It allows for a quick implementation of your object
for visualization purposes.

Parameters:
-----------

nu_em:  Frequency at emission [Hz]

dsem:  length over which to integrate inside the object [geometrical
units]

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::metric "

Get gg_. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::metric "

Set gg_. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::getVelocity "

Fluid velocity field.

Fill vel with the 4-vector velocity of the fluid at 4-position pos.

Parameters:
-----------

pos:  4-position at which to compute velocity;

vel:  4-velocity at pos. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::safetyValue "

Set Standard::safety_value_. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::safetyValue "

Get Standard::safety_value_. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::deltaInObj "

Get Generic::delta_inobj_.

Get the constant integration step inside the astrobj

delta_inobj_ in geometrical units ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::deltaInObj "

Set Generic::delta_inobj_. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::giveDelta "

Maximum inside object.

Gives the requested integration stept (in coordinate time t) between
two neighbooring points along a portion of geodesic inside an astrobj;
the current implementation only considers a constant delta, equal to
Standard::deltaInobj()

Parameters:
-----------

coord:  input coordinate at whicht is given ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::GYOTO_OBJECT_ACCESSORS_UNIT
"";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::showshadow "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::showshadow "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::redshift "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::redshift "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::processHitQuantities "

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::processHitQuantities "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::emission "

Obsolete, update your code;. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::emission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::radiativeQ "

emission and transmission together ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::radiativeQ "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::transmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::transmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::Omatrix "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::Omatrix "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::Omatrix "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::Pmatrix "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::rotateJs "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::computeB4vect_ipole "";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::getRefCount "

Get the current number of references. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStarModelAtmosphere::set
"

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStarModelAtmosphere::set
"

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStarModelAtmosphere::set
"

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStarModelAtmosphere::set
"

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStarModelAtmosphere::get
"

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStarModelAtmosphere::get
"

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStarModelAtmosphere::get
"

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::NeutronStarModelAtmosphere::get
"

Get Value of a Property, converted to unit. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")
Gyoto::Astrobj::NeutronStarModelAtmosphere::kind "

Get kind_. ";


// File: class_gyoto_1_1_metric_1_1_numerical_metric_lorene.xml
%feature("docstring") Gyoto::Metric::NumericalMetricLorene "";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::NumericalMetricLorene "

Constructor. ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::NumericalMetricLorene "

Copy constructor. ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::clone "

Virtual copy constructor. ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::~NumericalMetricLorene "

Destructor. ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::setMetricSource "

Access functions to get or set private attributes ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::directory
"";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::directory
"";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::initialTime "";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::initialTime "";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::horizon "";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::horizon "";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::rico "";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::rico "";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::hasSurface "";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::hasSurface "";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::hasAccelerationVector "";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::hasAccelerationVector "";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::bosonstarcircular "";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::bosonstarcircular "";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::specifyMarginalOrbits "";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::specifyMarginalOrbits "";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::mapEt "";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::mapEt "";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::axisymCirc "";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::axisymCirc "";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::getShift_tab "";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::getLapse_tab "";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::getGamcon_tab "";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::getGamcov_tab "";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::getTimes
"";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::getNbtimes "";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::getNssurf_tab "";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::getVsurf_tab "";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::getAccel_tab "";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::getLorentz_tab "";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::getHor_tab "";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::getRms "

Returns the marginally stable (ISCO) radius Should be implemented in
derived classes if useful If called on the base class, returns an
error ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::getRmb "

Returns the marginally bound radius Should be implemented in derived
classes if useful If called on the base class, returns an error ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::setLapse_tab "";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::setShift_tab "";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::setGamcov_tab "";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::setGamcon_tab "";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::setKij_tab "";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::setTimes
"";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::getSpecificAngularMomentum "

Returns the specific angular momentum l=-u_phi/u_t Should be
implemented in derived classes if useful If called on the base class,
returns an error ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::getPotential "

Returns potential W=-ln(|u_t|) for a cst specific angular momentum
l_cst Should be implemented in derived classes if useful If called on
the base class, returns an error ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::computeNBeta "

Compute lapse and shift at given coordinates ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::gmunu "

Metric coefficients.

The default implementation calls Metric:: gmunu(double g[4][4], const
double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::gmunu "";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::gmunu_up
"

Metric contravariant coefficients.

The default implementation inverts the covariant coefficients matrix.
";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::gmunu_up
"";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::gmunu_di
"";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::gmunu_di
"";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::jacobian
"

Derivatives of the metric covariant coefficients.

The default implementation evaluates them numerically. The gmunu
matrix is assumed to be symmetrical but no other assumptions are made
at the moment. ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::gmunu_up_dr "

r derivative of contravariant 4-metric ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::gmunu_up_dr "";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3). ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::christoffel "";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3).

1 on error, 0 otherwise ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::christoffel "";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::Interpol3rdOrder "

3rd order interpolation routine

Interpolation at order 3 at point tt, the considered function taking
the values \"values\" at time indices \"indices\". ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::computeHorizon "

Computation of horizon value. ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::computeHorizon "";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::diff "

F function such as d(coord)/d(tau)=F(coord) ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::diff "";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::diff "";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::diff31 "

F function such as dx/dt=F(x,cst) for 3+1 case. ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::circularVelocity "

Yield circular velocity at a given position.

Give the velocity of a massive particle in circular orbit at the given
position projected onto the equatorial plane. Such a velocity may not
exist everywhere (or anywhere) for a given metric. This method is
intended to be used by Astrobj classes such as Torus or ThinDisk.

This circular velocity should be implemented for all specific
numerical metric used.

If bosonstarcircular_ is set to true, this method returns the boson
star circular velocity.

Parameters:
-----------

coor:  input: position,

vel:  output: velocity,

dir:  1 for corotating, -1 for counterrotating. ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::circularVelocity "";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::gmunu "

4- Metric ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::gmunu "

4- Metric ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::coordKind
"

Get coordinate kind. ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::getRefCount "";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::mass "

Set mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::mass "

Set mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::mass "

Get mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::mass "

Get mass used in unitLength() ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::unitLength "

M * G / c^2, M is in kg, unitLength in meters.

Metrics implementations are free to express lengths and distances in
whatever unit they see fit (presumably most often geometrical units).
This function returns this unit in SI (meters). ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::unitLength "

unitLength expressed in specified unit ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::deltaMin
"

Get delta_min_ ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::deltaMin
"

Set delta_min_ ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::deltaMax
"

Get delta_max_ ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::deltaMax
"

Get delta max at a given position

Parameters:
-----------

pos:  4-position

[optional]:  delta_max_external external constraint on delta_max

the smallest value between delta_max_, delta_max_external, and
R*delta_max_over_r_ where R is pos[1] in spherical coordinates and
max(x1, x2, x3) in Cartesian coordinates. ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::deltaMax
"

Set delta_max_ ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::deltaMaxOverR "

Get delta_max_over_r_. ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::deltaMaxOverR "

Set delta_max_over_r_. ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::keplerian
"

Get keplerian_. ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::keplerian
"

Set keplerian_. ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::cartesianVelocity "

Compute xprime, yprime and zprime from 8-coordinates. ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::SysPrimeToTdot "

Compute tdot as a function of dr/dt, dtheta/dt and dphi/dt. Everything
is in geometrical units.

Parameters:
-----------

coord:  4-position (geometrical units);

v:  3-velocity dx1/dx0, dx2/dx0, dx3/dx0;

tdot = dx0/dtau. ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::circularVelocity "

Yield circular velocity at a given position.

Give the velocity of a massive particle in circular orbit at the given
position projected onto the equatorial plane. Such a velocity may not
exist everywhere (or anywhere) for a given metric. This method is
intended to be used by Astrobj classes such as Torus or ThinDisk.

If keplerian_ is set to true, this method should return the Keplerian
velcity instead (derived classes should ensure this, see
KerrBL::circularVelocity() for instance).

The default implementation throws an error if keplerian_ is set to
false.

Parameters:
-----------

pos:  input: position,

vel:  output: velocity,

dir:  1 for corotating, -1 for counterrotating. ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::zamoVelocity "

Yield ZAMO velocity at a given position.

Give the velocity of a zero angular momentul observer (whatever is
closest to \"at rest\"). The default implementation simply projects
(1, 0, 0, 0) othogonally along ephi and normalizes it, thus ensuring
that vel is orthogonal to ephi.

Parameters:
-----------

pos:  input: position,

vel:  output: velocity, ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::nullifyCoord "

Set tdot (coord[4]) such that coord is light-like. Everything is in
geometrical units.

Set coord[4] so that the 4-velocity coord[4:7] is lightlike, i.e. of
norm 0. There may be up to two solutions. coord[4] is set to the
hightest. The lowest can be retrieved using nullifyCoord(double
coord[8], double& tdot2) const. Everything is expressed in geometrical
units.

Parameters:
-----------

coord:  8-position, coord[4] will be set according to the other
elements; ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::nullifyCoord "

Set tdot (coord[4]) such that coord is light-like and return other
possible tdot.

Set coord[4] so that the 4-velocity coord[4:7] is lightlike, i.e. of
norm 0. There may be up to two solutions. coord[4] is set to the
hightest. The lowest can be retrieved in tdot2. Everything is
expressed in geometrical units.

Parameters:
-----------

coord:  8-position, coord[4] will be set according to the other
elements;

tdot2:  will be set to the smallest solution ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::normalizeFourVel "

Normalize fourvelvel to -1.

First computes threevel as xiprime=xidot/x0dot for i in {1, 2, 3},
then computes x0dot using SyPrimeToTdot, then computes again xidot as
xidot=xiprime*x0dot.

Parameters:
-----------

coord:  8-position, coord[4-7] will be set according to the other
elements; ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::normalizeFourVel "

Normalize fourvelvel to -1.

First computes threevel as xiprime=xidot/x0dot for i in {1, 2, 3},
then computes x0dot using SyPrimeToTdot, then computes again xidot as
xidot=xiprime*x0dot.

Parameters:
-----------

pos:  4-position;

fourvel:  4-velocity, will be renormalized. ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::ScalarProd "

Scalar product.

Compute the scalarproduct of the two quadrivectors u1 and u2 in this
Metric, at point pos expressed in coordinate system sys.

Parameters:
-----------

pos:  4-position;

u1:  1st quadrivector;

u2:  2nd quadrivector;

u1*u2 ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::norm "

Scalar product.

Compute the norm of the quadrivector u1 in this Metric, at point pos
expressed in coordinate system sys.

Parameters:
-----------

pos:  4-position;

u1:  quadrivector;

||u1|| ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::multiplyFourVect "

multiply vector by scalar ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::addFourVect "

add second vector to first one ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::projectFourVect "

project u1 orthogonally to u2 at pos ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::dualOneForm "

Computes dual 1-form Compute the dual 1-form of 4-vector.

Parameters:
-----------

IN_ARRAY1_1:  4-position;

IN_ARRAY1_2:  quadrivector;

ARGOUT_ARRAY1:  output 1-form ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::observerTetrad "

Computes the orthonormal local tetrad of the observer.

Parameters:
-----------

obskind:  input: kind of observer (eg:
\"ZAMO\",\"KeplerianObserver\"...)

pos:  input: position,

fourvel:  output: observer 4-velocity (norm -1)

screen1:  output: first vector in the screen plane

screen2:  output: second vector in the screen plane

screen3:  output: vector normal to the screen ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::observerTetrad "

Computes the orthonormal local tetrad of the observer.

Parameters:
-----------

pos:  position,

fourvel:  observer 4-velocity (norm -1)

screen1:  first vector in the screen plane

screen2:  second vector in the screen plane

screen3:  vector normal to the screen ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::GramSchmidt "

Apply Gram-Schmidt orthonormalization to a basis.

On input, u0 to u3 must be four non-zero norm, independent 4-vectors.
On output, they will form an orthonormal basis.

Parameters:
-----------

pos:  position,

u0:  basis vector

u1:  basis vector

u2:  basis vector

u3:  basis vector ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::gmunu "

Metric coefficients.

The default implementation calls double gmunu(const double * x, int
mu, int nu) const.

Parameters:
-----------

ARGOUT_ARRAY2:  (g) 4x4 array to store the coeefficients

IN_ARRAY1:  (x) 4-position at which to compute the coefficients;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::gmunu_up
"

Metric contravariant coefficients.

The default implementation calls Metric:: gmunu_up(double g[4][4],
const double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::gmunu_up_and_jacobian "

gmunu_up() and jacobian() in one go ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::myrk4 "

RK4 integrator. ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::myrk4 "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::myrk4_adaptive "

RK4 integrator with adaptive step. ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::myrk4_adaptive "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::isStopCondition "

Check whether integration should stop.

The integrating loop will ask this the Metric through this method
whether or not it is happy to continue the integration. Typically, the
Metric should answer 0 when everything is fine, 1 when too close to
the event horizon, inside the BH...

Parameters:
-----------

coord:  8-coordinate vector to check. ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::diff "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::diff "";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::setParticleProperties "

Set Metric-specific constants of motion. Used e.g. in KerrBL. ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::property
"

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::setParameters "

Main loop for parsing Properties from XML description.

This function queries the FactoryMessenger for elements to parse, and
tries to matche each element to a Property to set it  accordingly. Any
class that tries to be buildable from XML must supply a subcontractor
(for base classes such as Metric, Astrobj, Spectrum  and Spectrometer,
it is done as a template that must be  specialized for each class).
This subcontractor typically looks somewhat like this: Although this
is discouraged, it is possible to override the following functions to
customize how XML entities are parsed:    - setParameters() if low-
level access to the      FactoryMessenger is required;    -
setParameter(std::string name, std::string content,
std::string unit)      to interpret an entity that does not match a
Property      (e.g. alternative name);    -
setParameter(Gyoto::Property const &p, std::string const &name,
std::string const &content, std::string const &unit)      to change
how a Property is interpreted. ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")
Gyoto::Metric::NumericalMetricLorene::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::kind "

Get kind_. ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::hook "

Start listening.

Use from a Hook::Listener object method: where \"this\" is a Listener
and \"teller\" is a Teller.

Use unhook() later to stop listening to a given Teller.

Parameters:
-----------

listener:  pointer to the new listener ";

%feature("docstring")  Gyoto::Metric::NumericalMetricLorene::unhook "

Stop listening.

Use from a Hook::Listener object method:

where \"this\" is a Listener, \"teller\" is a Teller, and \"this\" has
called teller->hook(this) previously.

Parameters:
-----------

listener:  pointer to the listener ";


// File: class_gyoto_1_1_numerical_metric_lorene.xml
%feature("docstring") Gyoto::NumericalMetricLorene "

Class for 3+1 numerical metrics computed by LORENE. This class can
handle (so far) any kind of LORENE metric, stars, collapsing stars,
Kerr, boson star e.g.

C++ includes: GyotoNumericalMetricLorene.h ";


// File: class_gyoto_1_1_object.xml
%feature("docstring") Gyoto::Object "

Object with properties.

The Object API allows declaring a list of Properties that can be set
and retrieved using a common, text-based interface. This interface
simplifies a lot how to read and write XML, as well as writing
bindings for interpreted langages (e.g. the Yorick interface).

In fact, any class member that has an interface implemented as a
Property can be readily read and written from/to XML as well as from
the Yorick plug-in, without the need for any additional code.

To declare a Property list: declare (in the class declaration, .h
file) and define (.C file) the pair or quadruplet of accessors for
your Property (see Property class documentation;

call the GYOTO_OBJECT macro in in a public section of the class
declaration (in the .h file):

call the various GYOTO_PROPERTY_* macros in the corresponding .C file
(see the documentation of the Property class).

It is possible to get a Property by name (Assume A is a class deriving
from Object): It then becomes possible to set or get the Property from
or to a Value: Of course the type of the Value instance and of the
Property instance must match. Refer to the documentation of these to
classes for details.

C++ includes: GyotoObject.h ";

%feature("docstring")  Gyoto::Object::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Object::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Object::Object "

Constructor setting kind. ";

%feature("docstring")  Gyoto::Object::Object "

Default constructor. ";

%feature("docstring")  Gyoto::Object::Object "

Deep copy constructor. ";

%feature("docstring")  Gyoto::Object::~Object "

Virtual destructor. ";

%feature("docstring")  Gyoto::Object::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Object::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Object::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Object::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Object::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Object::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Object::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Object::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Object::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Object::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Object::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Object::setParameters "

Main loop for parsing Properties from XML description.

This function queries the FactoryMessenger for elements to parse, and
tries to matche each element to a Property to set it  accordingly. Any
class that tries to be buildable from XML must supply a subcontractor
(for base classes such as Metric, Astrobj, Spectrum  and Spectrometer,
it is done as a template that must be  specialized for each class).
This subcontractor typically looks somewhat like this: Although this
is discouraged, it is possible to override the following functions to
customize how XML entities are parsed:    - setParameters() if low-
level access to the      FactoryMessenger is required;    -
setParameter(std::string name, std::string content,
std::string unit)      to interpret an entity that does not match a
Property      (e.g. alternative name);    -
setParameter(Gyoto::Property const &p, std::string const &name,
std::string const &content, std::string const &unit)      to change
how a Property is interpreted. ";

%feature("docstring")  Gyoto::Object::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Object::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Object::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Object::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Object::kind "

Get kind_. ";


// File: class_gyoto_1_1_python_1_1_object.xml
%feature("docstring") Gyoto::Python::Object "

Class template to implement parts of the Gyoto::Object API.

C++ includes: GyotoPython.h ";

%feature("docstring")  Gyoto::Python::Object::Object "";

%feature("docstring")  Gyoto::Python::Object::Object "";

%feature("docstring")  Gyoto::Python::Object::~Object "";

%feature("docstring")  Gyoto::Python::Object::set "";

%feature("docstring")  Gyoto::Python::Object::set "";

%feature("docstring")  Gyoto::Python::Object::set "";

%feature("docstring")  Gyoto::Python::Object::get "";

%feature("docstring")  Gyoto::Python::Object::get "";

%feature("docstring")  Gyoto::Python::Object::get "";

%feature("docstring")  Gyoto::Python::Object::setParameter "";

%feature("docstring")  Gyoto::Python::Object::fillElement "";

%feature("docstring")  Gyoto::Python::Object::setParameters "";

%feature("docstring")  Gyoto::Python::Object::module "

Return module_. ";

%feature("docstring")  Gyoto::Python::Object::module "

Set module_ and import the Python module.

Side effects: sets inline_module_ to \"\";

calls klass( class_) if class_ is already known, so module_ can be set
(or reset) after class_. ";

%feature("docstring")  Gyoto::Python::Object::inlineModule "

Return inline_module_. ";

%feature("docstring")  Gyoto::Python::Object::inlineModule "

Set inline_module_ and import the Python module.

Side effects: sets module_ to \"\";

calls klass( class_) if class_ is already known, so module_ can be set
(or reset) after class_. ";

%feature("docstring")  Gyoto::Python::Object::klass "

Retrieve class_. ";

%feature("docstring")  Gyoto::Python::Object::klass "

Set class_ and instantiate the Python class.

Sets pInstance_.

This generic implementation takes care of the common ground, but does
not set 'this' or call parameters( parameters_). Therefore, all the
derived classes should reimplement this method and at least call
Python::Base::klass(c) and parameters( parameters_). Between the two
is the right moment to check that the Python class implements the
required API and to cache PyObject* pointers to class methods. ";

%feature("docstring")  Gyoto::Python::Object::parameters "

Retrieve parameters_. ";

%feature("docstring")  Gyoto::Python::Object::parameters "

Set parameters_ and send them to pInstance_.

The parameters are sent to the class instance using the setitem method
with numerical keys. ";

%feature("docstring")  Gyoto::Python::Object::hasPythonProperty "";

%feature("docstring")  Gyoto::Python::Object::setPythonProperty "";

%feature("docstring")  Gyoto::Python::Object::getPythonProperty "";

%feature("docstring")  Gyoto::Python::Object::pythonPropertyType "";


// File: class_gyoto_1_1_astrobj_1_1_oscil_torus.xml
%feature("docstring") Gyoto::Astrobj::OscilTorus "";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::OscilTorus "";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::OscilTorus "";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::~OscilTorus "";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::clone "

Cloner.

This method must be implemented by the various Astrobj::Generic
subclasses in order to support cloning:

Cloning is necessary for multi-threading, recommended for interaction
with the Yorick plug-in etc.

Implementing it is very straightforward, as long as the copy
constructor Generic(const Generic& ) has been implemented: ";

%feature("docstring")
Gyoto::Astrobj::OscilTorus::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")
Gyoto::Astrobj::OscilTorus::GYOTO_OBJECT_ACCESSORS "";

%feature("docstring")
Gyoto::Astrobj::OscilTorus::GYOTO_OBJECT_ACCESSORS "";

%feature("docstring")
Gyoto::Astrobj::OscilTorus::GYOTO_OBJECT_ACCESSORS "";

%feature("docstring")
Gyoto::Astrobj::OscilTorus::GYOTO_OBJECT_ACCESSORS "";

%feature("docstring")
Gyoto::Astrobj::OscilTorus::GYOTO_OBJECT_ACCESSORS_STRING "";

%feature("docstring")
Gyoto::Astrobj::OscilTorus::GYOTO_OBJECT_ACCESSORS "";

%feature("docstring")
Gyoto::Astrobj::OscilTorus::GYOTO_OBJECT_ACCESSORS_STRING "";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::getVelocity "

Fluid velocity field.

Fill vel with the 4-vector velocity of the fluid at 4-position pos.

Parameters:
-----------

pos:  4-position at which to compute velocity;

vel:  4-velocity at pos. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::emission "";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::updateCachedValues
"";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::computeXbYb "";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::tell "

Update cached values.

Calls updateCachedValues().

See Hook::Listener::tell() ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::safetyValue "

Set Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::safetyValue "

Get Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::deltaInObj "

Get Generic::delta_inobj_.

Get the constant integration step inside the astrobj

delta_inobj_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::deltaInObj "

Set Generic::delta_inobj_. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::giveDelta "

Maximum inside object.

Gives the requested integration stept (in coordinate time t) between
two neighbooring points along a portion of geodesic inside an astrobj;
the current implementation only considers a constant delta, equal to
Standard::deltaInobj()

Parameters:
-----------

coord:  input coordinate at whicht is given ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")
Gyoto::Astrobj::OscilTorus::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::showshadow "";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::showshadow "";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::redshift "";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::redshift "";

%feature("docstring")
Gyoto::Astrobj::OscilTorus::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")
Gyoto::Astrobj::OscilTorus::processHitQuantities "

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")
Gyoto::Astrobj::OscilTorus::processHitQuantities "";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::emission "

Specific intensity I

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem, in the emitter's frame. It should take self-absorption
along dsem into account.

Reminder : intensity = I [J m^-2 s^-1 ster^-1 Hz^-1];

invariant intensity = I/3, which has the same value in any frame;

emission coefficient = j [J m^-3 s^-1 ster^-1 Hz^-1] , defined by dI =
j*ds, where ds is the distance travelled by the photon inside the
object;

invariant emission coef = j/2, which has the same value in any frame.

The equation used for radiative transfer (without absorption) is:

d(I/3)/d = (j/2) [*]

where is the integration parameter along the null geodesic.

NB: Let us consider a particular observer, with being the frequency
measured by this observer, and ds being the proper distance (as
measured by the observer) that the photon travels as it moves from
to+d along its geodesic. Then it can be shown that:

d = ds/

This shows that Eq. [*] is homogeneous.

The default implementation returns 1. if optically thick and dsem if
optically thin. It allows for a quick implementation of your object
for visualization purposes.

Parameters:
-----------

nu_em:  Frequency at emission [Hz]

dsem:  length over which to integrate inside the object [geometrical
units]

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::radiativeQ "

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::computeB4vect_ipole
"";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::OscilTorus::kind "

Get kind_. ";


// File: class_gyoto_1_1_astrobj_1_1_polish_doughnut_1_1outerradius__t.xml


// File: class_gyoto_1_1_astrobj_1_1_page_thorne_disk.xml
%feature("docstring") Gyoto::Astrobj::PageThorneDisk "

Geometrically thin disk in Kerr metric.

This class describes a disk contained in the z=0 (equatorial) plane,
extending from r=r_ISCO to r=infinity. The flux emitted at radius r is
given by Page & Thorne (1974, ApJ 191:499, Eqs. 11b, 14, 15).

The metric must be either KerrBL or KerrKS. Emission, Spectrum and
BinSpectrum are not provide, the only intensity provided is provided,
as quantity User4 and it is the default quantity returned if nothing
is requested. The other quantities implemented in ThinDisk are also
provided.

C++ includes: GyotoPageThorneDisk.h ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::PageThorneDisk
"

Standard constructor. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::PageThorneDisk
"

Copy constructor. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::clone "

Cloner. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::~PageThorneDisk
"

Destructor. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::metric "

Set metric, checking that it is either KerrBL or KerrKS. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::mdot "

Set mdot_ to v. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::mdot "";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::uniFlux "";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::uniFlux "";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::emission "

Not implemented Throws a Gyoto::Error. ";

%feature("docstring")
Gyoto::Astrobj::PageThorneDisk::bolometricEmission "

Bolometric emission.

Similar to Generic::emission(), but bolometric. ";

%feature("docstring")
Gyoto::Astrobj::PageThorneDisk::processHitQuantities "

processHitQuantities fills the requested data in Impact. For
PageThorneDisk, only fill User4, which corresponds to bolometric
intensity. ";

%feature("docstring")
Gyoto::Astrobj::PageThorneDisk::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::tell "

Update PageThorneDisk::aa_.

Calls updateSpin().

See Hook::Listener::tell() ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::innerRadius "

Get rin_. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::innerRadius "

Get rin_. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::innerRadius "

Set rin_. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::innerRadius "

Set rin_. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::outerRadius "

Get rout_. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::outerRadius "

Get rout_. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::outerRadius "

Set rout_. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::outerRadius "

Set rout_. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::thickness "

Get thickness_. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::thickness "

Get thickness_. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::thickness "

Set thickness_. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::thickness "

Set thickness_. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::dir "

Get dir_. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::dir "

Set dir_. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::corotating "";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::corotating "

Get dir_==1. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::velocityKind "

Set dir_=t?1:-1.

Get VelocityKind ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::velocityKind "

Set VelocityKind. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::projectedRadius
"

Projected radius of position coord on the equatorial plane. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::sphericalPhi "

Longitude. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::getVelocity "

Get fluid 4-velocity at point.

Fill vel with the 4-vector velocity of the fluid at 4-position pos.
getVelocity() should work at some distance from the equatorial plane.
The default implementation calls Metric::Generic::circularVelocity().

Parameters:
-----------

pos:  4-position at which to compute velocity;

vel:  4-velocity at pos. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")
Gyoto::Astrobj::PageThorneDisk::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::showshadow "";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::showshadow "";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::redshift "";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::redshift "";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")
Gyoto::Astrobj::PageThorneDisk::processHitQuantities "";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::radiativeQ "

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::radiativeQ "";

%feature("docstring")
Gyoto::Astrobj::PageThorneDisk::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")
Gyoto::Astrobj::PageThorneDisk::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::PageThorneDisk::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")
Gyoto::Astrobj::PageThorneDisk::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")
Gyoto::Astrobj::PageThorneDisk::computeB4vect_ipole "";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")
Gyoto::Astrobj::PageThorneDisk::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::PageThorneDisk::kind "

Get kind_. ";


// File: class_gyoto_1_1_astrobj_1_1_pattern_disk.xml
%feature("docstring") Gyoto::Astrobj::PatternDisk "

Geometrically thin disk read from FITS file.

This class describes a disk contained in the z=0 (equatorial) plane,
extending from r=r_ISCO to r=infinity. The flux emitted at radius r
and longitude phi at frequency nu is given in a FITS file.

C++ includes: GyotoPatternDisk.h ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::PatternDisk "

Standard constructor. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::PatternDisk "

Copy constructor. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::clone "

Cloner. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::~PatternDisk "

Destructor. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::innerRadius "

Set rin_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::outerRadius "

Set rout_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::patternVelocity "

Set PatternDisk::Omega_.

Unit: radians per geometrical unit time. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::patternVelocity "

Get PatternDisk::Omega_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::file "";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::file "";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::setEmission "

Set PatternDisk::emission_.

The pointer is copied directly, not the array content.

This is a low-level function. Beware that: previously allocated array
will not be freed automatically;

array attached when the destructor is called will be freed. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::setVelocity "

Set PatternDisk::velocity__.

The pointer is copied directly, not the array content.

This is a low-level function. Beware that: previously allocated array
will not be freed automatically;

array attached when the destructor is called will be freed. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::radius "

Set PatternDisk::radius_.

The pointer is copied directly, not the array content.

This is a low-level function. Beware that: previously allocated array
will not be freed automatically;

array attached when the destructor is called will be freed. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::copyIntensity "

Set PatternDisk::emission_.

PatternDisk::emission_ is freed if not NULL, reallocated, and pattern
is copied into emission_.

If PatternDisk::opacity_, PatternDisk::velocity_ or
PatternDisk::radius_ have been set previously with mismatching sizes,
they are deallocated too.

Finally, PatternDisk::nnu_, PatternDisk::nphi_, and PatternDisk::nr_
are set according to naxes.

Parameters:
-----------

pattern:  Array to copy as emission_. May be NULL in which case
emission_ is simply deallocated and set to NULL.

naxes:  { nnu_, nphi_, nr_ }. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::getIntensity "

Get PatternDisk::emission_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::getIntensityNaxes
"

Get PatternDisk::nnu_, PatternDisk::nphi_, and PatternDisk::nr_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::copyOpacity "

Set PatternDisk::opacity_.

PatternDisk::opacity_ is first freed if not NULL and set to NULL.

If pattern is not NULL, PatternDisk::emission_ must have been set
previously with matching dimensions. PatternDisk::opacity_ is then
reallocated, and pattern is copied into opacity_.

Parameters:
-----------

pattern:  Array to copy as opacity_. May be NULL in which case
opacity_ is simply deallocated and set to NULL.

naxes:  { nnu_, nphi_, nr_ }. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::opacity "

Get PatternDisk::opacity_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::copyVelocity "

Set PatternDisk::velocity_.

PatternDisk::velocity_ is first freed if not NULL and set to NULL.

If pattern is not NULL, PatternDisk::emission_ must have been set
previously with matching dimensions. PatternDisk::velocity_ is then
reallocated, and pattern is copied into velocity_.

Parameters:
-----------

pattern:  Array to copy as velocity_. May be NULL in which case
velocity_ is simply deallocated and set to NULL.

naxes:  { nphi_, nr_ }. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::getVelocity "

Get PatternDisk::velocity_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::copyGridRadius "

Set PatternDisk::radius_.

PatternDisk::radius_ is first freed if not NULL and set to NULL.

If pattern is not NULL, PatternDisk::emission_ must have been set
previously with matching dimensions. PatternDisk::radius_ is then
reallocated, and pattern is copied into radius_.

Parameters:
-----------

pattern:  Array to copy as radius_. May be NULL in which case radius_
is simply deallocated and set to NULL.

nr:  size of radius array. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::getGridRadius "

Get PatternDisk::radius_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::repeatPhi "

Set PatternDisk::repeat_phi_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::repeatPhi "

Get PatternDisk::repeat_phi_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::nu0 "

Set PatternDisk::nu0_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::nu0 "

Get PatternDisk::nu0_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::dnu "

Set PatternDisk::dnu_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::dnu "

Get PatternDisk::dnu_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::phimin "

Set PatternDisk::phimin_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::phimin "

Get PatternDisk::phimin_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::phimax "

Set PatternDisk::phimax_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::phimax "

Get PatternDisk::phimax_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::emission "

Specific intensity I

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem, in the emitter's frame. It should take self-absorption
along dsem into account.

Reminder : intensity = I [J m^-2 s^-1 ster^-1 Hz^-1];

invariant intensity = I/3, which has the same value in any frame;

emission coefficient = j [J m^-3 s^-1 ster^-1 Hz^-1] , defined by dI =
j*ds, where ds is the distance travelled by the photon inside the
object;

invariant emission coef = j/2, which has the same value in any frame.

The equation used for radiative transfer (without absorption) is:

d(I/3)/d = (j/2) [*]

where is the integration parameter along the null geodesic.

NB: Let us consider a particular observer, with being the frequency
measured by this observer, and ds being the proper distance (as
measured by the observer) that the photon travels as it moves from
to+d along its geodesic. Then it can be shown that:

d = ds/

This shows that Eq. [*] is homogeneous.

The default implementation returns 1. if optically thick and dsem if
optically thin. It allows for a quick implementation of your object
for visualization purposes.

Parameters:
-----------

nu_em:  Frequency at emission [Hz]

dsem:  length over which to integrate inside the object [geometrical
units]

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::getVelocity "

Get fluid 4-velocity at point.

Fill vel with the 4-vector velocity of the fluid at 4-position pos.
getVelocity() should work at some distance from the equatorial plane.
The default implementation calls Metric::Generic::circularVelocity().

Parameters:
-----------

pos:  4-position at which to compute velocity;

vel:  4-velocity at pos. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::innerRadius "

Get rin_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::innerRadius "

Get rin_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::innerRadius "

Set rin_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::innerRadius "

Set rin_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::outerRadius "

Get rout_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::outerRadius "

Get rout_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::outerRadius "

Set rout_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::outerRadius "

Set rout_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::innerRadius "

Get rin_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::innerRadius "

Get rin_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::innerRadius "

Set rin_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::outerRadius "

Get rout_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::outerRadius "

Get rout_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::outerRadius "

Set rout_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::thickness "

Get thickness_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::thickness "

Get thickness_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::thickness "

Set thickness_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::thickness "

Set thickness_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::dir "

Get dir_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::dir "

Set dir_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::corotating "";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::corotating "

Get dir_==1. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::velocityKind "

Set dir_=t?1:-1.

Get VelocityKind ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::velocityKind "

Set VelocityKind. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::projectedRadius "

Projected radius of position coord on the equatorial plane. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::sphericalPhi "

Longitude. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")
Gyoto::Astrobj::PatternDisk::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::showshadow "";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::showshadow "";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::redshift "";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::redshift "";

%feature("docstring")
Gyoto::Astrobj::PatternDisk::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")
Gyoto::Astrobj::PatternDisk::processHitQuantities "

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")
Gyoto::Astrobj::PatternDisk::processHitQuantities "";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::radiativeQ "

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::integrateEmission
"

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::integrateEmission
"

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::integrateEmission
"

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::integrateEmission
"

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")
Gyoto::Astrobj::PatternDisk::computeB4vect_ipole "";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::PatternDisk::kind "

Get kind_. ";


// File: class_gyoto_1_1_astrobj_1_1_pattern_disk_b_b.xml
%feature("docstring") Gyoto::Astrobj::PatternDiskBB "

Geometrically thin disk read from FITS file with black body spectrum.

This class describes a disk contained in the z=0 (equatorial) plane,
extending from r=r_ISCO to r=rmax_. The flux emitted at radius r and
longitude phi at frequency nu is given in a FITS file.

C++ includes: GyotoPatternDiskBB.h ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::PatternDiskBB "

Standard constructor. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::PatternDiskBB "

Copy constructor. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::clone "

Cloner. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::~PatternDiskBB "

Destructor. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::spectralEmission
"";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::spectralEmission
"";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::emission "

Specific intensity I

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem, in the emitter's frame. It should take self-absorption
along dsem into account.

Reminder : intensity = I [J m^-2 s^-1 ster^-1 Hz^-1];

invariant intensity = I/3, which has the same value in any frame;

emission coefficient = j [J m^-3 s^-1 ster^-1 Hz^-1] , defined by dI =
j*ds, where ds is the distance travelled by the photon inside the
object;

invariant emission coef = j/2, which has the same value in any frame.

The equation used for radiative transfer (without absorption) is:

d(I/3)/d = (j/2) [*]

where is the integration parameter along the null geodesic.

NB: Let us consider a particular observer, with being the frequency
measured by this observer, and ds being the proper distance (as
measured by the observer) that the photon travels as it moves from
to+d along its geodesic. Then it can be shown that:

d = ds/

This shows that Eq. [*] is homogeneous.

The default implementation returns 1. if optically thick and dsem if
optically thin. It allows for a quick implementation of your object
for visualization purposes.

Parameters:
-----------

nu_em:  Frequency at emission [Hz]

dsem:  length over which to integrate inside the object [geometrical
units]

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::emission "";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::innerRadius "

Set rin_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::innerRadius "

Get rin_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::innerRadius "

Get rin_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::innerRadius "

Set rin_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::innerRadius "

Set rin_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::innerRadius "

Get rin_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::innerRadius "

Get rin_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::innerRadius "

Set rin_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::outerRadius "

Set rout_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::outerRadius "

Get rout_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::outerRadius "

Get rout_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::outerRadius "

Set rout_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::outerRadius "

Set rout_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::outerRadius "

Get rout_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::outerRadius "

Get rout_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::outerRadius "

Set rout_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::patternVelocity
"

Set PatternDisk::Omega_.

Unit: radians per geometrical unit time. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::patternVelocity
"

Get PatternDisk::Omega_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::file "";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::file "";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::setEmission "

Set PatternDisk::emission_.

The pointer is copied directly, not the array content.

This is a low-level function. Beware that: previously allocated array
will not be freed automatically;

array attached when the destructor is called will be freed. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::setVelocity "

Set PatternDisk::velocity__.

The pointer is copied directly, not the array content.

This is a low-level function. Beware that: previously allocated array
will not be freed automatically;

array attached when the destructor is called will be freed. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::radius "

Set PatternDisk::radius_.

The pointer is copied directly, not the array content.

This is a low-level function. Beware that: previously allocated array
will not be freed automatically;

array attached when the destructor is called will be freed. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::copyIntensity "

Set PatternDisk::emission_.

PatternDisk::emission_ is freed if not NULL, reallocated, and pattern
is copied into emission_.

If PatternDisk::opacity_, PatternDisk::velocity_ or
PatternDisk::radius_ have been set previously with mismatching sizes,
they are deallocated too.

Finally, PatternDisk::nnu_, PatternDisk::nphi_, and PatternDisk::nr_
are set according to naxes.

Parameters:
-----------

pattern:  Array to copy as emission_. May be NULL in which case
emission_ is simply deallocated and set to NULL.

naxes:  { nnu_, nphi_, nr_ }. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::getIntensity "

Get PatternDisk::emission_. ";

%feature("docstring")
Gyoto::Astrobj::PatternDiskBB::getIntensityNaxes "

Get PatternDisk::nnu_, PatternDisk::nphi_, and PatternDisk::nr_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::copyOpacity "

Set PatternDisk::opacity_.

PatternDisk::opacity_ is first freed if not NULL and set to NULL.

If pattern is not NULL, PatternDisk::emission_ must have been set
previously with matching dimensions. PatternDisk::opacity_ is then
reallocated, and pattern is copied into opacity_.

Parameters:
-----------

pattern:  Array to copy as opacity_. May be NULL in which case
opacity_ is simply deallocated and set to NULL.

naxes:  { nnu_, nphi_, nr_ }. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::opacity "

Get PatternDisk::opacity_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::copyVelocity "

Set PatternDisk::velocity_.

PatternDisk::velocity_ is first freed if not NULL and set to NULL.

If pattern is not NULL, PatternDisk::emission_ must have been set
previously with matching dimensions. PatternDisk::velocity_ is then
reallocated, and pattern is copied into velocity_.

Parameters:
-----------

pattern:  Array to copy as velocity_. May be NULL in which case
velocity_ is simply deallocated and set to NULL.

naxes:  { nphi_, nr_ }. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::getVelocity "

Get PatternDisk::velocity_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::getVelocity "

Get fluid 4-velocity at point.

Fill vel with the 4-vector velocity of the fluid at 4-position pos.
getVelocity() should work at some distance from the equatorial plane.
The default implementation calls Metric::Generic::circularVelocity().

Parameters:
-----------

pos:  4-position at which to compute velocity;

vel:  4-velocity at pos. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::copyGridRadius "

Set PatternDisk::radius_.

PatternDisk::radius_ is first freed if not NULL and set to NULL.

If pattern is not NULL, PatternDisk::emission_ must have been set
previously with matching dimensions. PatternDisk::radius_ is then
reallocated, and pattern is copied into radius_.

Parameters:
-----------

pattern:  Array to copy as radius_. May be NULL in which case radius_
is simply deallocated and set to NULL.

nr:  size of radius array. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::getGridRadius "

Get PatternDisk::radius_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::repeatPhi "

Set PatternDisk::repeat_phi_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::repeatPhi "

Get PatternDisk::repeat_phi_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::nu0 "

Set PatternDisk::nu0_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::nu0 "

Get PatternDisk::nu0_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::dnu "

Set PatternDisk::dnu_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::dnu "

Get PatternDisk::dnu_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::phimin "

Set PatternDisk::phimin_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::phimin "

Get PatternDisk::phimin_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::phimax "

Set PatternDisk::phimax_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::phimax "

Get PatternDisk::phimax_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::thickness "

Get thickness_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::thickness "

Get thickness_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::thickness "

Set thickness_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::thickness "

Set thickness_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::dir "

Get dir_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::dir "

Set dir_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::corotating "";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::corotating "

Get dir_==1. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::velocityKind "

Set dir_=t?1:-1.

Get VelocityKind ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::velocityKind "

Set VelocityKind. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::projectedRadius
"

Projected radius of position coord on the equatorial plane. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::sphericalPhi "

Longitude. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")
Gyoto::Astrobj::PatternDiskBB::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::showshadow "";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::showshadow "";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::redshift "";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::redshift "";

%feature("docstring")
Gyoto::Astrobj::PatternDiskBB::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")
Gyoto::Astrobj::PatternDiskBB::processHitQuantities "

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")
Gyoto::Astrobj::PatternDiskBB::processHitQuantities "";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::radiativeQ "

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")
Gyoto::Astrobj::PatternDiskBB::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")
Gyoto::Astrobj::PatternDiskBB::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::PatternDiskBB::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")
Gyoto::Astrobj::PatternDiskBB::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")
Gyoto::Astrobj::PatternDiskBB::computeB4vect_ipole "";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::describeProperty
"

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::PatternDiskBB::kind "

Get kind_. ";


// File: class_gyoto_1_1_photon.xml
%feature("docstring") Gyoto::Photon "

A null geodesic transporting light.

This is the central object for ray-tracing.

C++ includes: GyotoPhoton.h ";

%feature("docstring")  Gyoto::Photon::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Photon::className "

\"Photon\" ";

%feature("docstring")  Gyoto::Photon::className_l "

\"photon\" ";

%feature("docstring")  Gyoto::Photon::Photon "

Default constructor.

Allocates the default size (GYOTO_DEFAULT_X_SIZE) for x1, x2 etc. ";

%feature("docstring")  Gyoto::Photon::Photon "

Copy constructor. ";

%feature("docstring")  Gyoto::Photon::clone "

Cloner. ";

%feature("docstring")  Gyoto::Photon::Photon "

Same as Photon() followed by
setInitialCondition(SmartPointer<Metric::Generic> gg,
SmartPointer<Astrobj::Generic> obj, const double coord[8]) ";

%feature("docstring")  Gyoto::Photon::Photon "

Same as Photon() followed by
setInitialCondition(SmartPointer<Metric::Generic> gg,
SmartPointer<Astrobj::Generic> obj, SmartPointer<Screen> screen,
double d_alpha, double d_delta) ";

%feature("docstring")  Gyoto::Photon::~Photon "

Destructor. ";

%feature("docstring")  Gyoto::Photon::getMass "

Return 0. ";

%feature("docstring")  Gyoto::Photon::astrobj "

Set Photon::object_. ";

%feature("docstring")  Gyoto::Photon::astrobj "

Get Photon::object_. ";

%feature("docstring")  Gyoto::Photon::metric "";

%feature("docstring")  Gyoto::Photon::spectrometer "

Set Photon::spectro_. ";

%feature("docstring")  Gyoto::Photon::spectrometer "

Get Photon::spectro_. ";

%feature("docstring")  Gyoto::Photon::freqObs "

Set Photon::freq_obs__. ";

%feature("docstring")  Gyoto::Photon::freqObs "

Get Photon::freq_obs__. ";

%feature("docstring")  Gyoto::Photon::nb_cross_eqplane "

Set Photon::nb_cross_eqplane_. ";

%feature("docstring")  Gyoto::Photon::nb_cross_eqplane "

Get Photon::nb_cross_eqplane_. ";

%feature("docstring")  Gyoto::Photon::setInitialCondition "

Set or re-set the initial condition prior to integration.

Set initial condition for this Photon. Several versions of this
function, with and without base vectors to parallel-transport, are
provided. If polarization is to be treated, use the version with the
base vectors.

Parameters:
-----------

gg:   Gyoto::SmartPointer to the Gyoto::Metric in this universe;

obj:   Gyoto::SmartPointer to the target Gyoto::Astrobj;

coord:  8-element array containing the initial condition, i.e. the
4-position and the 4-velocity of the Photon at the receiving end; ";

%feature("docstring")  Gyoto::Photon::setInitialCondition "

Set or re-set the initial condition prior to integration.

Set initial condition for this Photon. Several versions of this
function, with and without base vectors to parallel-transport, are
provided. If polarization is to be treated, use the version with the
base vectors. Initialize those vectors to the two base vectors for the
Stokes parameters in the observer screen.

Parameters:
-----------

gg:   Gyoto::SmartPointer to the Gyoto::Metric in this universe;

obj:   Gyoto::SmartPointer to the target Gyoto::Astrobj;

coord:  8-element array containing the initial condition, i.e. the
4-position and the 4-velocity of the Photon at the receiving end;

Ephi:  initial value of base vector to parallel-transport. Ignored if
parallel_transport_ is false.

Etheta:  initial value of base vector to parallel-transport. Ignored
if parallel_transport_ is false. ";

%feature("docstring")  Gyoto::Photon::setInitialCondition "

Set or re-set the initial condition prior to integration.

Set initial condition for this Photon. This version of this function
automatically takes care of initializing the base vectors for
polarization when needed.

Parameters:
-----------

gg:   Gyoto::SmartPointer to the Gyoto::Metric in this universe;

obj:   Gyoto::SmartPointer to the target Gyoto::Astrobj;

screen:  Observer's screen;

d_alpha:  Direction of arrival (RA offset) in radians;

d_delta:  Direction of arrival (Dec offset) in radians. ";

%feature("docstring")  Gyoto::Photon::hit "

Integrate the geodesic.

Parameters:
-----------

data:  Optional Astrobj::Properties to fill with observational
quantities.

1 if object was hit, else 0. ";

%feature("docstring")  Gyoto::Photon::findMin "

Find minimum of photonobject distance.

Return the minimum of (*object)(this-> getCoord()) between t1 and t2.
The date of this minimum is returned in tmin.

Parameters:
-----------

object:  the distance to minimize is given by object->operator()().
This method is in particular implemented by the subclasses of
Astrobj::Standard.

t1:  date

t2:  date

tmin:  on output, date correspondig to the minimum

threshold:  stop searching for a minimum if a value < threshold is
found (very often, we just want to find a date below the threshold,
not the accurate minimum). ";

%feature("docstring")  Gyoto::Photon::findValue "

Find date for which the photon is at a given distance from the object.

Parameters:
-----------

object:   Object, must implement operator() (e.g. Astrobj::Standard,
ThinDisk::Standard)

value:  The value to find

tinside:  A date for which
object->Astrobj::operator()(Photon::getCoord()) is < value

toutside:  On input: a date for which
object->Astrobj::operator()(Photon::getCoord()) is > value. on output,
(*object)(getCoord(toutside)) is < value, very close to value.
toutside is closer to tinside on output than on input. ";

%feature("docstring")  Gyoto::Photon::setParameters "

Main loop for parsing Properties from XML description.

This function queries the FactoryMessenger for elements to parse, and
tries to matche each element to a Property to set it  accordingly. Any
class that tries to be buildable from XML must supply a subcontractor
(for base classes such as Metric, Astrobj, Spectrum  and Spectrometer,
it is done as a template that must be  specialized for each class).
This subcontractor typically looks somewhat like this: Although this
is discouraged, it is possible to override the following functions to
customize how XML entities are parsed:    - setParameters() if low-
level access to the      FactoryMessenger is required;    -
setParameter(std::string name, std::string content,
std::string unit)      to interpret an entity that does not match a
Property      (e.g. alternative name);    -
setParameter(Gyoto::Property const &p, std::string const &name,
std::string const &content, std::string const &unit)      to change
how a Property is interpreted. ";

%feature("docstring")  Gyoto::Photon::resetTransmission "

Set transmission to 1 for each channel as well as scalar transmission.
";

%feature("docstring")  Gyoto::Photon::resetTransmissionMatrix "

Set transmission matrix to identity matrix for each frequency. ";

%feature("docstring")  Gyoto::Photon::getTransmission "

Get transmission.

Get either Photon::transmission_freqobs_ (with i=-1) or
Photon::transmission_[i].

Parameters:
-----------

i:  channel number of the requested frequency, -1 for
Photon::freq_obs_. ";

%feature("docstring")  Gyoto::Photon::getTransmissionMatrix "

Get transmission matrix.

Get either Photon::transmission_freqobs_ (with i=-1) or
Photon::transmission_[i].

Parameters:
-----------

i:  channel number of the requested frequency, -1 for
Photon::freq_obs_. ";

%feature("docstring")  Gyoto::Photon::getTransmissionMax "

Get maximum transmission;.

Get current maximum of all the transmissions,
Photon::transmission_freqobs_ or one elements of the
Photon::transmission_ array. ";

%feature("docstring")  Gyoto::Photon::getTransmission "

Get Photon::transmission_.

getTansmission()[i] == getTransmission(size_t i) ";

%feature("docstring")  Gyoto::Photon::getTransmissionMatrix "

Get Photon::transmissionMatrix_.

getTansmissionMatrix()[i] == getTransmissionMatrix(size_t i) ";

%feature("docstring")  Gyoto::Photon::transmit "

Update transmission in a given channel.

getTransmission(size_t i) *= t.

Parameters:
-----------

i:  channel number. -1 for scalar Photon::transmission_freqobs_.

t:  transmission of this fluid element. ";

%feature("docstring")  Gyoto::Photon::transmit "

Update transmission matrix in a given channel.

getTransmissionMatrix(size_t i) *= mat.

Parameters:
-----------

i:  channel number. -1 for Matrix Photon::transmissionMatrix_freqobs_.

mat:  transmission Matrix of this fluid element. ";

%feature("docstring")  Gyoto::Photon::transfer "

Perform one step of polarized radiative transfert and update
transmission matrix. ";

%feature("docstring")  Gyoto::Photon::metric "

Set metric Smartpointer. ";

%feature("docstring")  Gyoto::Photon::metric "

Get metric. ";

%feature("docstring")  Gyoto::Photon::setInitialCondition "

Set or re-set the initial condition prior to integration.

Parameters:
-----------

gg:   Gyoto::SmartPointer to the Gyoto::Metric in this universe;

coord:  8 element array containing the initial condition, i.e. the
4-position and the 4-velocity of the Photon at the receiving end;

dir:  direction: 1 for future, -1 for past.

Ephi:  initial value of base vector to parallel-transport. Ignored if
parallel_transport_ is false.

Etheta:  initial value of base vector to parallel-transport. Ignored
if parallel_transport_ is false. ";

%feature("docstring")  Gyoto::Photon::setInitialCondition "

Set or re-set the initial condition prior to integration.

Parameters:
-----------

gg:   Gyoto::SmartPointer to the Gyoto::Metric in this universe;

coord:  8 element array containing the initial condition, i.e. the
4-position and the 4-velocity of the Photon at the receiving end;

dir:  direction: 1 for future, -1 for past. ";

%feature("docstring")  Gyoto::Photon::getImin "

Get imin_. ";

%feature("docstring")  Gyoto::Photon::getImax "

Get imax_. ";

%feature("docstring")  Gyoto::Photon::getI0 "

Get i0_. ";

%feature("docstring")  Gyoto::Photon::metric "

Get metric. ";

%feature("docstring")  Gyoto::Photon::initCoord "";

%feature("docstring")  Gyoto::Photon::initCoord "";

%feature("docstring")  Gyoto::Photon::setInitCoord "

Set Initial coordinate.

Set imin_= imax_= i0_, and x  [i0]=coord[ ].

If dir==1, i0_ is set to 0. If dir==-1, i0_ is set to x_size_-1.

If dir==0 and the Worldine has never been computed ( i0_==0, imin_==1
and imax_==0), then dir defaults to 1 for a massive particle and -1
for a massless particle.

If dir==0 and the Worldine has already been computed, i0_ is not
changed.



Parameters:
-----------

coord:  new initial coordinates

dir:  direction of integration. 1 for forward integration, -1 for
backards integration, 0 for unknown or both

Ephi:  initial value of base vector to parallel-transport. Ignored if
parallel_transport_ is false.

Etheta:  initial value of base vector to parallel-transport. Ignored
if parallel_transport_ is false. ";

%feature("docstring")  Gyoto::Photon::setInitCoord "

Set Initial coordinate.

Set imin_= imax_= i0_, and x  [i0]=coord[ ].

If dir==1, i0_ is set to 0. If dir==-1, i0_ is set to x_size_-1.

If dir==0 and the Worldine has never been computed ( i0_==0, imin_==1
and imax_==0), then dir defaults to 1 for a massive particle and -1
for a massless particle.

If dir==0 and the Worldine has already been computed, i0_ is not
changed.



Parameters:
-----------

coord:  new initial coordinates

dir:  direction of integration. 1 for forward integration, -1 for
backards integration, 0 for unknown or both ";

%feature("docstring")  Gyoto::Photon::setInitCoord "

Set initial coordinate.

Parameters:
-----------

pos:  initial 4-position

vel:  initial 3-velocity

dir:  direction of integration ";

%feature("docstring")  Gyoto::Photon::setPosition "

Set initial 4-position. ";

%feature("docstring")  Gyoto::Photon::setVelocity "

Set initial 3-velocity. ";

%feature("docstring")  Gyoto::Photon::reset "

Forget integration, keeping initial contition. ";

%feature("docstring")  Gyoto::Photon::reInit "

Reset and recompute particle properties. ";

%feature("docstring")  Gyoto::Photon::integrator "

Set the integrator.

Initialize state_ to use the required integrator.

Parameters:
-----------

type:  Either \"Legacy\" or (if GYOTO_HAVE_BOOST_INTEGRATORS) one of
\"runge_kutta_cash_karp54\", \"runge_kutta_fehlberg78\",
\"runge_kutta_dopri5\", \"runge_kutta_cash_karp54_classic\" ";

%feature("docstring")  Gyoto::Photon::integrator "

Describe the integrator used by state_. ";

%feature("docstring")  Gyoto::Photon::integ31 "

Set the integrator kind to 3+1 or 4D.

Initialize state_ to use the required geodesic equation. ";

%feature("docstring")  Gyoto::Photon::integ31 "

Get the kind of geodesic equation integrated by state_. ";

%feature("docstring")  Gyoto::Photon::deltaMin "

Get delta_min_. ";

%feature("docstring")  Gyoto::Photon::deltaMin "

Set delta_min_. ";

%feature("docstring")  Gyoto::Photon::deltaMax "

Get delta_max_. ";

%feature("docstring")  Gyoto::Photon::deltaMax "

Get delta max at a given position

Parameters:
-----------

pos:  4-position

delta_max_external:  external constraint on delta_max

the smallest value between delta_max_, delta_max_external, and R*
delta_max_over_r_ where R is pos[1] in spherical coordinates and
max(x1, x2, x3) in Cartesian coordinates. ";

%feature("docstring")  Gyoto::Photon::deltaMax "

Set delta_max_ ";

%feature("docstring")  Gyoto::Photon::absTol "

Set abstol_. ";

%feature("docstring")  Gyoto::Photon::absTol "

Get abstol_. ";

%feature("docstring")  Gyoto::Photon::relTol "

Set reltol_. ";

%feature("docstring")  Gyoto::Photon::relTol "

Get reltol_. ";

%feature("docstring")  Gyoto::Photon::maxCrossEqplane "

Set #maxCrosEqplane_. ";

%feature("docstring")  Gyoto::Photon::maxCrossEqplane "

Get maxCrossEqplane_. ";

%feature("docstring")  Gyoto::Photon::deltaMaxOverR "

Get delta_max_over_r_. ";

%feature("docstring")  Gyoto::Photon::deltaMaxOverR "

Set delta_max_over_r_. ";

%feature("docstring")  Gyoto::Photon::delta "

Expand memory slots for polarization vectors.

Assignment to another Worldline Set delta_ ";

%feature("docstring")  Gyoto::Photon::delta "

Set delta_ in specified units. ";

%feature("docstring")  Gyoto::Photon::delta "

Get delta_. ";

%feature("docstring")  Gyoto::Photon::delta "

Get delta_ in specified units. ";

%feature("docstring")  Gyoto::Photon::tMin "

Get tmin_. ";

%feature("docstring")  Gyoto::Photon::tMin "

Get tmin_ in specified unit. ";

%feature("docstring")  Gyoto::Photon::tMin "

Set tmin_. ";

%feature("docstring")  Gyoto::Photon::tMin "

Set tmin_ in specified unit. ";

%feature("docstring")  Gyoto::Photon::adaptive "

Set adaptive_. ";

%feature("docstring")  Gyoto::Photon::adaptive "

Get adaptive_. ";

%feature("docstring")  Gyoto::Photon::secondary "

Set secondary_. ";

%feature("docstring")  Gyoto::Photon::secondary "

Get secondary_. ";

%feature("docstring")  Gyoto::Photon::parallelTransport "

Set parallel_transport_. ";

%feature("docstring")  Gyoto::Photon::parallelTransport "

Get parallel_transport_. ";

%feature("docstring")  Gyoto::Photon::maxiter "

Set maxiter_. ";

%feature("docstring")  Gyoto::Photon::maxiter "

Get maxiter_. ";

%feature("docstring")  Gyoto::Photon::getCst "

Returns the worldline's cst of motion (if any)

Return pointer to array holding the previously set Metric-specific
constants of motion.

This function returns a pointer to the actual storage location and
should be handled with care. std::vector<double> Worldline:
constantsOfMotion() constprovides a convenient way to retrieve a copy
of the content. ";

%feature("docstring")  Gyoto::Photon::setCst "

Set Metric-specific constants of motion.

The will (re)allocate Worldline::cst_, copy cst into it, and set
Worldline::cst_n_.

This is the same as void Worldline:
constantsOfMotion(std::vector<double> const cstv) using a C-style
array instead of a vector. ";

%feature("docstring")  Gyoto::Photon::constantsOfMotion "

Set Metric-specific constants of motion.

The will (re)allocate Worldline::cst_, copy cst into it, and set
Worldline::cst_n_.

This is the same as getCst using a vector instead of a C-style array.
";

%feature("docstring")  Gyoto::Photon::constantsOfMotion "

Return a copy of the Metric-specific constants of motion.

This funtion return a copy of the constants of motion. getCst() can be
used to retrieve a pointer to the actual array used internally which
is slightly more efficient for read-only access. ";

%feature("docstring")  Gyoto::Photon::setInitialCondition "

Set or re-set the initial condition prior to integration.

Parameters:
-----------

gg:   Gyoto::SmartPointer to the Gyoto::Metric in this universe;

coord:  8 element array containing the initial condition, i.e. the
4-position and the 4-velocity of the Photon at the receiving end;

dir:  direction: 1 for future, -1 for past.

Ephi:  initial value of base vector to parallel-transport. Ignored if
parallel_transport_ is false.

Etheta:  initial value of base vector to parallel-transport. Ignored
if parallel_transport_ is false. ";

%feature("docstring")  Gyoto::Photon::setInitialCondition "

Set or re-set the initial condition prior to integration.

Parameters:
-----------

gg:   Gyoto::SmartPointer to the Gyoto::Metric in this universe;

coord:  8 element array containing the initial condition, i.e. the
4-position and the 4-velocity of the Photon at the receiving end;

dir:  direction: 1 for future, -1 for past. ";

%feature("docstring")  Gyoto::Photon::getInitialCoord "

Get initial coordinates + base vectors.

Depending on the size of dest and on the value of parallel_transport_,
get position (xi_), velocity (xidot_) and possibly other triad vectors
(epi_ and eti_). ";

%feature("docstring")  Gyoto::Photon::getCoord "

Get coordinates+base vectors corresponding to index.

Depending on the value of parallel_transport_, get position (xi_),
velocity (xidot_) and possibly other triad vectors (epi_ and eti_).
coord is resized to the right number of elements. ";

%feature("docstring")  Gyoto::Photon::getCoord "

Get coordinates+base vectors corresponding to index.

We need this non-const implementation to allow the const, size_t and
the non-const, double implementations to coexist. ";

%feature("docstring")  Gyoto::Photon::getCoord "

Get coordinates+base vectors corresponding to date dest[0].

Depending on the value of parallel_transport_, get position (xi_),
velocity (xidot_) and possibly other triad vectors (epi_ and eti_).
coord is resized to the right number of elements. ";

%feature("docstring")  Gyoto::Photon::getCoord "

Get 8-coordinates for specific dates.

The coordinates will be computed using the integrator, so they will be
as accurate as possible. Some heuristics are used to speed up the
process and it is presumably faster to call this routine with a sorted
list of dates. The line will be integrated further as required. An
error will be thrown if it is not possible to reach a certain date.

Parameters:
-----------

dates:  the list of dates for which the coordinates are to be computed
in proper time or affine parameter if #proper is true or in coordinate
time if #proper is false (default);

n_dates:  the number of dates to compute ;

x1dest:  x2dest:  x3dest:  x0dot:  x1dot:  x2dot:  x3dot:  arrays in
which to store the result. These pointer may be set to NULL to
retrieve only part of the information. They must be pre-allocated.

ephi0:  ephi1:  ephi2:  ephi3:  etheta0:  etheta1:  etheta2:  etheta3:
arrays in which to store the ephi and etheta (parallel transport
case). These pointer may be set to NULL to retrieve only part of the
information. They must be pre-allocated.

otime:  array in which to store the other time: coordinate time if
#proper, else proper time or affine parameter.

proper:  bool: whether #dates is proper time (or affine parameter) or
coordinate time. ";

%feature("docstring")  Gyoto::Photon::getCoord "

Get all computed positions.

Get all the pre-computed 8 coordinates (e.g. thanks to a prior call to
xFill()) of this worldline. ";

%feature("docstring")  Gyoto::Photon::getCartesianPos "

Get Cartesian expression of 4-position at index. ";

%feature("docstring")  Gyoto::Photon::xStore "

Store coord at index ind. ";

%feature("docstring")  Gyoto::Photon::xStore "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Photon::xStore "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Photon::xFill "

Fill x0, x1... by integrating the Worldline from previously set
inittial condition to time tlim. ";

%feature("docstring")  Gyoto::Photon::get_nelements "

Get number of computed dates. ";

%feature("docstring")  Gyoto::Photon::get_t "

Get computed dates. ";

%feature("docstring")  Gyoto::Photon::get_tau "

Get computed proper times or values of the affine parameter. ";

%feature("docstring")  Gyoto::Photon::getCartesian "

Get the 6 Cartesian coordinates for specific dates.

The 6 coordinates (x, y, z, dx/dt, dy/dt, dz/dt) will be computed
using the integrator and interpolated if necessary, so they will be as
accurate as possible. Transforming to Cartesian coordinates is not
necessarily meaningful.

Parameters:
-----------

dates:  List of dates for which the coordinates are to be computed;

n_dates:  Number of dates to compute ;

x:  y:  z:  xprime:  yprime:  zprime:  Arrays in which to store the
result. These pointer may be set to NULL to retrieve only part of the
information. Else, they must be pre- allocated. ";

%feature("docstring")  Gyoto::Photon::get_xyz "

Get 3-position in cartesian coordinates for computed dates. ";

%feature("docstring")  Gyoto::Photon::checkPhiTheta "

Bring in [0,] and in [0,2].

checkPhiTheta() Modifies coord if the corrdinates are spherical-like
so that coord[2]=theta is in [0,pi] and coord[3]=phi is in [0,2pi].
Important to use in all astrobj in spherical coordinates to prevent
\"z-axis problems\". ";

%feature("docstring")  Gyoto::Photon::getSkyPos "

Get computed positions in sky coordinates. ";

%feature("docstring")  Gyoto::Photon::get_dot "

Get computed 4-velocities. ";

%feature("docstring")  Gyoto::Photon::get_prime "

Get computed 3-velocities. ";

%feature("docstring")  Gyoto::Photon::save_txyz "

Save in a file. ";

%feature("docstring")  Gyoto::Photon::save_txyz "

Save, converted. ";

%feature("docstring")  Gyoto::Photon::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Photon::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Photon::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Photon::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Photon::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Photon::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Photon::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Photon::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Photon::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Photon::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Photon::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Photon::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Photon::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Photon::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Photon::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Photon::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Photon::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Photon::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Photon::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Photon::kind "

Get kind_. ";


// File: class_gyoto_1_1_astrobj_1_1_plasmoid.xml
%feature("docstring") Gyoto::Astrobj::Plasmoid "

Plasmoid Shere of plasma emitting synchrotron, following a trajectory
specified in getVelocity (non-geodesic a priori)

C++ includes: GyotoPlasmoid.h ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::Plasmoid "

Default constructor.

Create Plasmoid object with undefined initial conditions. One needs to
set the coordinate system, the metric, the type of motion, and the
initial position and velocity before integrating the orbit.
initCoord() can be used for that. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::Plasmoid "

Copy constructor. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::clone "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::~Plasmoid "

Destructor. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::className "

\"Plasmoid\" ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::className_l "

\"inflate_star\" ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::motionType "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::initPosition "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::initPosition "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::initVelocity "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::initVelocity "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::initCoord "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::initCoord "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::radiusMax "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::radiusMax "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::Radius "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::radiativeQ "

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::getCartesian "

Yield the Cartesian coordinates of the center of the sphere.

If the coordinate system of the Metric object is spherical, use a
trivial conversion. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::getVelocity "

Yield velocity of the center of the sphere. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::file "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::fitsRead "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::numin "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::numin "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::numax "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::numax "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::nnu "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::nnu "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::tmin "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::tmin "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::tmax "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::tmax "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::nt "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::nt "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::dt "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::dt "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::getIndices "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::interpolate "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::spectrum "

Set spectrum_. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::spectrum "

Get spectrum_. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::opacity "

Set opacity_. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::opacity "

Get opacity_. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::radius "

Get radius_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::radius "

Set radius_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::radius "

Get radius_ in specified unit. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::radius "

Set radius_ in specified unit. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::deltaMaxOverRadius "

Get dltmor_. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::deltaMaxOverRadius "

Set dltmor_. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::deltaMaxOverDistance
"

Get dltmod_. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::deltaMaxOverDistance
"

Set dltmod_. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::isotropic "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::isotropic "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::alpha "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::alpha "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::deltaMax "

Parameters:

coord:  current photon position

max( dltmor_* radius_, dltmod_*operator()(double coord[]) ) ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::safetyValue "

Set Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::safetyValue "

Get Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::deltaInObj "

Get Generic::delta_inobj_.

Get the constant integration step inside the astrobj

delta_inobj_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::deltaInObj "

Set Generic::delta_inobj_. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::giveDelta "

Maximum inside object.

Gives the requested integration stept (in coordinate time t) between
two neighbooring points along a portion of geodesic inside an astrobj;
the current implementation only considers a constant delta, equal to
Standard::deltaInobj()

Parameters:
-----------

coord:  input coordinate at whicht is given ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")
Gyoto::Astrobj::Plasmoid::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::showshadow "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::showshadow "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::redshift "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::redshift "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::getDefaultQuantities
"

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::processHitQuantities
"

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::processHitQuantities
"";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::computeB4vect_ipole "";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::Plasmoid::kind "

Get kind_. ";


// File: class_gyoto_1_1_astrobj_1_1_polish_doughnut.xml
%feature("docstring") Gyoto::Astrobj::PolishDoughnut "

A toroidal accretion structure.

Latest reference: Vincent, F. H.; Yan, W.; Straub, O.; Zdziarski, A.
A.; Abramowicz, M. A. 2015, A magnetized torus for modeling
Sagittarius A* millimeter images and spectra, A&A 574:A48.

Reference: Straub, O.; Vincent, F. H.; Abramowicz, M. A.; Gourgoulhon,
E.; & Paumard, T. 2012, Modelling the black hole silhouette in
Sagittarius A* with ion tori, A&A 543:83.

C++ includes: GyotoPolishDoughnut.h ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::PolishDoughnut
"

Default constructor. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::PolishDoughnut
"

Copy constructor. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::clone "

Cloner.

This method must be implemented by the various Astrobj::Generic
subclasses in order to support cloning:

Cloning is necessary for multi-threading, recommended for interaction
with the Yorick plug-in etc.

Implementing it is very straightforward, as long as the copy
constructor Generic(const Generic& ) has been implemented: ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::~PolishDoughnut
"

Destructor. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::getL0 "

Get PolishDoughnut::l0_. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::lambda "

Get PolishDoughnut::lambda_. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::lambda "

Set PolishDoughnut::lambda_. ";

%feature("docstring")
Gyoto::Astrobj::PolishDoughnut::centralEnthalpyPerUnitVolume "

Get PolishDoughnut::central_enthalpy_cgs_. ";

%feature("docstring")
Gyoto::Astrobj::PolishDoughnut::centralEnthalpyPerUnitVolume "

Get PolishDoughnut::central_enthalpy_cgs_ in specified unit. ";

%feature("docstring")
Gyoto::Astrobj::PolishDoughnut::centralEnthalpyPerUnitVolume "

Set PolishDoughnut::central_enthalpy_cgs_. ";

%feature("docstring")
Gyoto::Astrobj::PolishDoughnut::centralEnthalpyPerUnitVolume "

Set PolishDoughnut::central_enthalpy_cgs_ in specified unit. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::centralTemp "

Get PolishDoughnut::central_temperature_. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::centralTemp "

Set PolishDoughnut::central_temperature_. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::beta "

Get PolishDoughnut::beta_. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::beta "

Set PolishDoughnut::beta_. ";

%feature("docstring")
Gyoto::Astrobj::PolishDoughnut::magnetizationParameter "";

%feature("docstring")
Gyoto::Astrobj::PolishDoughnut::magnetizationParameter "";

%feature("docstring")
Gyoto::Astrobj::PolishDoughnut::spectralOversampling "

Set PolishDoughnut::spectral_oversampling_. ";

%feature("docstring")
Gyoto::Astrobj::PolishDoughnut::spectralOversampling "

Get PolishDoughnut::spectral_oversampling_. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::changeCusp "

Get PolishDoughnut::komissarov_. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::changeCusp "

Set PolishDoughnut::komissarov_. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::bremsstrahlung
"

Get PolishDoughnut::bremsstrahlung_. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::bremsstrahlung
"

Set PolishDoughnut::bremsstrahlung_. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::angleAveraged "

Get PolishDoughnut::angle_averaged_. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::angleAveraged "

Set PolishDoughnut::angle_averaged_. ";

%feature("docstring")
Gyoto::Astrobj::PolishDoughnut::nonThermalDeltaExpo "";

%feature("docstring")
Gyoto::Astrobj::PolishDoughnut::nonThermalDeltaExpo "";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::angmomrinner "";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::angmomrinner "";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::adafparams "";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::adafparams "";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::adaf "";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::adaf "";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::getWsurface "

Get PolishDoughnut::W_surface_. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::getWcentre "

Get PolishDoughnut::W_centre_. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::getRcusp "

Get PolishDoughnut::r_cusp_. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::getRcentre "

Get PolishDoughnut::r_centre_. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::safetyValue "

Set Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::safetyValue "

Get Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::deltaInObj "

Get Generic::delta_inobj_.

Get the constant integration step inside the astrobj

delta_inobj_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::deltaInObj "

Set Generic::delta_inobj_. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::giveDelta "

Maximum inside object.

Gives the requested integration stept (in coordinate time t) between
two neighbooring points along a portion of geodesic inside an astrobj;
the current implementation only considers a constant delta, equal to
Standard::deltaInobj()

Parameters:
-----------

coord:  input coordinate at whicht is given ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")
Gyoto::Astrobj::PolishDoughnut::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::showshadow "";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::showshadow "";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::redshift "";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::redshift "";

%feature("docstring")
Gyoto::Astrobj::PolishDoughnut::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")
Gyoto::Astrobj::PolishDoughnut::processHitQuantities "

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")
Gyoto::Astrobj::PolishDoughnut::processHitQuantities "";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::emission "

Specific intensity I

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem, in the emitter's frame. It should take self-absorption
along dsem into account.

Reminder : intensity = I [J m^-2 s^-1 ster^-1 Hz^-1];

invariant intensity = I/3, which has the same value in any frame;

emission coefficient = j [J m^-3 s^-1 ster^-1 Hz^-1] , defined by dI =
j*ds, where ds is the distance travelled by the photon inside the
object;

invariant emission coef = j/2, which has the same value in any frame.

The equation used for radiative transfer (without absorption) is:

d(I/3)/d = (j/2) [*]

where is the integration parameter along the null geodesic.

NB: Let us consider a particular observer, with being the frequency
measured by this observer, and ds being the proper distance (as
measured by the observer) that the photon travels as it moves from
to+d along its geodesic. Then it can be shown that:

d = ds/

This shows that Eq. [*] is homogeneous.

The default implementation returns 1. if optically thick and dsem if
optically thin. It allows for a quick implementation of your object
for visualization purposes.

Parameters:
-----------

nu_em:  Frequency at emission [Hz]

dsem:  length over which to integrate inside the object [geometrical
units]

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")
Gyoto::Astrobj::PolishDoughnut::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")
Gyoto::Astrobj::PolishDoughnut::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::PolishDoughnut::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")
Gyoto::Astrobj::PolishDoughnut::computeB4vect_ipole "";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")
Gyoto::Astrobj::PolishDoughnut::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::PolishDoughnut::kind "

Get kind_. ";


// File: class_gyoto_1_1_spectrum_1_1_power_law.xml
%feature("docstring") Gyoto::Spectrum::PowerLaw "

I_nu=constant_*nu^exponent_.

Light emitted by e.g. a Star.

XML stanza:

C++ includes: GyotoPowerLawSpectrum.h ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::PowerLaw "";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::PowerLaw "

Constructor setting exponent_ and optionally constant_. ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::clone "

Cloner. ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::constant "

Get constant_. ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::constant "

Set constant_. ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::exponent "

Get exponent_. ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::exponent "

Set exponent_. ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::cutoff "

Get cutoffs, specifying unit. ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::cutoff "

Set cutoffs, specifying unit. ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::cutoff "

Get cutoffs, in Hz. ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::cutoff "

Set cutoffs, in Hz. ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::integrate "

Integrate optically thick I_nu.

See operator()(double nu) const

Parameters:
-----------

nu1:  nu2:  boundaries for the integration

I, the integral of I_nu between nu1 and nu2 ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::integrate "

Integrate optically thin I_nu.

See operator()(double nu, double opacity, double ds) const

Parameters:
-----------

nu1:  nu2:  boundaries for the integration

opacity:  the frequency-dependent opacity law given as a pointer to a
Gyoto::Spectrum::Generic sub-class instance

ds:  the element length for spatial integration

I, the integral of I_nu between nu1 and nu2 ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::setParameters "

Main loop for parsing Properties from XML description.

This function queries the FactoryMessenger for elements to parse, and
tries to matche each element to a Property to set it  accordingly. Any
class that tries to be buildable from XML must supply a subcontractor
(for base classes such as Metric, Astrobj, Spectrum  and Spectrometer,
it is done as a template that must be  specialized for each class).
This subcontractor typically looks somewhat like this: Although this
is discouraged, it is possible to override the following functions to
customize how XML entities are parsed:    - setParameters() if low-
level access to the      FactoryMessenger is required;    -
setParameter(std::string name, std::string content,
std::string unit)      to interpret an entity that does not match a
Property      (e.g. alternative name);    -
setParameter(Gyoto::Property const &p, std::string const &name,
std::string const &content, std::string const &unit)      to change
how a Property is interpreted. ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Spectrum::PowerLaw::kind "

Get kind_. ";


// File: class_gyoto_1_1_spectrum_1_1_power_law_synchrotron.xml
%feature("docstring") Gyoto::Spectrum::PowerLawSynchrotron "

Powerlaw synchrotron spectrum.

Example XML entity:

C++ includes: GyotoPowerLawSynchrotronSpectrum.h ";

%feature("docstring")
Gyoto::Spectrum::PowerLawSynchrotron::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")
Gyoto::Spectrum::PowerLawSynchrotron::PowerLawSynchrotron "";

%feature("docstring")
Gyoto::Spectrum::PowerLawSynchrotron::PowerLawSynchrotron "";

%feature("docstring")  Gyoto::Spectrum::PowerLawSynchrotron::clone "

Cloner. ";

%feature("docstring")
Gyoto::Spectrum::PowerLawSynchrotron::numberdensityCGS "";

%feature("docstring")
Gyoto::Spectrum::PowerLawSynchrotron::numberdensityCGS "";

%feature("docstring")
Gyoto::Spectrum::PowerLawSynchrotron::angle_B_pem "";

%feature("docstring")
Gyoto::Spectrum::PowerLawSynchrotron::angle_B_pem "";

%feature("docstring")
Gyoto::Spectrum::PowerLawSynchrotron::cyclotron_freq "";

%feature("docstring")
Gyoto::Spectrum::PowerLawSynchrotron::cyclotron_freq "";

%feature("docstring")  Gyoto::Spectrum::PowerLawSynchrotron::PLindex "";

%feature("docstring")  Gyoto::Spectrum::PowerLawSynchrotron::PLindex "";

%feature("docstring")
Gyoto::Spectrum::PowerLawSynchrotron::angle_averaged "";

%feature("docstring")
Gyoto::Spectrum::PowerLawSynchrotron::angle_averaged "";

%feature("docstring")  Gyoto::Spectrum::PowerLawSynchrotron::gamma_min
"";

%feature("docstring")  Gyoto::Spectrum::PowerLawSynchrotron::gamma_min
"";

%feature("docstring")  Gyoto::Spectrum::PowerLawSynchrotron::gamma_max
"";

%feature("docstring")  Gyoto::Spectrum::PowerLawSynchrotron::gamma_max
"";

%feature("docstring")  Gyoto::Spectrum::PowerLawSynchrotron::jnuCGS "

Returns the emission coefficient j_nu in cgs units i.e. erg cm^-3 s^-1
ster^-1 Hz^-1

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")  Gyoto::Spectrum::PowerLawSynchrotron::jQnuCGS "

Returns the Stokes Q emission coefficient j_nu in cgs units i.e. erg
cm^-3 s^-1 ster^-1 Hz^-1

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")  Gyoto::Spectrum::PowerLawSynchrotron::jUnuCGS "

Returns the Stokes U emission coefficient j_nu in cgs units i.e. erg
cm^-3 s^-1 ster^-1 Hz^-1

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")  Gyoto::Spectrum::PowerLawSynchrotron::jVnuCGS "

Returns the Stokes V emission coefficient j_nu in cgs units i.e. erg
cm^-3 s^-1 ster^-1 Hz^-1

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")
Gyoto::Spectrum::PowerLawSynchrotron::alphanuCGS "

Returns the absorption coefficient alpha_nu in cgs units [cm^-1]

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")
Gyoto::Spectrum::PowerLawSynchrotron::alphaQnuCGS "

Returns the Stokes Q absorption coefficient alpha_nu in cgs units
[cm^-1]

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")
Gyoto::Spectrum::PowerLawSynchrotron::alphaUnuCGS "

Returns the Stokes U absorption coefficient alpha_nu in cgs units
[cm^-1]

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")
Gyoto::Spectrum::PowerLawSynchrotron::alphaVnuCGS "

Returns the Stokes V absorption coefficient alpha_nu in cgs units
[cm^-1]

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")  Gyoto::Spectrum::PowerLawSynchrotron::rQnuCGS "

Returns the Stokes Q Faraday rotation coefficient in cgs units [cm^-1]

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")  Gyoto::Spectrum::PowerLawSynchrotron::rUnuCGS "

Returns the Stokes U Faraday rotation coefficient in cgs units [cm^-1]

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")  Gyoto::Spectrum::PowerLawSynchrotron::rVnuCGS "

Returns the Stokes V Faraday rotation coefficient in cgs units [cm^-1]

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")
Gyoto::Spectrum::PowerLawSynchrotron::radiativeQ "

Returns the emission and absorption coef in SI ";

%feature("docstring")
Gyoto::Spectrum::PowerLawSynchrotron::radiativeQ "

Returns the emission, absorption and Fraday rotation coef in SI for
the 4 Stokes parameters ";

%feature("docstring")  Gyoto::Spectrum::PowerLawSynchrotron::integrate
"

Integrate optically thick I_nu.

See operator()(double nu) const

Parameters:
-----------

nu1:  nu2:  boundaries for the integration

I, the integral of I_nu between nu1 and nu2 ";

%feature("docstring")  Gyoto::Spectrum::PowerLawSynchrotron::integrate
"

Integrate optically thin I_nu.

See operator()(double nu, double opacity, double ds) const

Parameters:
-----------

nu1:  nu2:  boundaries for the integration

opacity:  the frequency-dependent opacity law given as a pointer to a
Gyoto::Spectrum::Generic sub-class instance

ds:  the element length for spatial integration

I, the integral of I_nu between nu1 and nu2 ";

%feature("docstring")
Gyoto::Spectrum::PowerLawSynchrotron::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")
Gyoto::Spectrum::PowerLawSynchrotron::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")
Gyoto::Spectrum::PowerLawSynchrotron::getRefCount "

Get the current number of references. ";

%feature("docstring")
Gyoto::Spectrum::PowerLawSynchrotron::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Spectrum::PowerLawSynchrotron::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Spectrum::PowerLawSynchrotron::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Spectrum::PowerLawSynchrotron::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Spectrum::PowerLawSynchrotron::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Spectrum::PowerLawSynchrotron::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Spectrum::PowerLawSynchrotron::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Spectrum::PowerLawSynchrotron::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Spectrum::PowerLawSynchrotron::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Spectrum::PowerLawSynchrotron::property
"

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")
Gyoto::Spectrum::PowerLawSynchrotron::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")
Gyoto::Spectrum::PowerLawSynchrotron::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")
Gyoto::Spectrum::PowerLawSynchrotron::setParameters "

Main loop for parsing Properties from XML description.

This function queries the FactoryMessenger for elements to parse, and
tries to matche each element to a Property to set it  accordingly. Any
class that tries to be buildable from XML must supply a subcontractor
(for base classes such as Metric, Astrobj, Spectrum  and Spectrometer,
it is done as a template that must be  specialized for each class).
This subcontractor typically looks somewhat like this: Although this
is discouraged, it is possible to override the following functions to
customize how XML entities are parsed:    - setParameters() if low-
level access to the      FactoryMessenger is required;    -
setParameter(std::string name, std::string content,
std::string unit)      to interpret an entity that does not match a
Property      (e.g. alternative name);    -
setParameter(Gyoto::Property const &p, std::string const &name,
std::string const &content, std::string const &unit)      to change
how a Property is interpreted. ";

%feature("docstring")
Gyoto::Spectrum::PowerLawSynchrotron::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")
Gyoto::Spectrum::PowerLawSynchrotron::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")
Gyoto::Spectrum::PowerLawSynchrotron::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Spectrum::PowerLawSynchrotron::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Spectrum::PowerLawSynchrotron::kind "

Get kind_. ";


// File: class_gyoto_1_1_astrobj_1_1_properties.xml
%feature("docstring") Gyoto::Astrobj::Properties "

Observable properties of an Astronomical object.

The sort of properties one wants to measure on a ray-traced
Gyoto::Photon which hits a Gyoto::Astrobj. Not all Astrobj are able to
fill all of these properties.

An instance of Properties essentially contains a bunch of pointers to
memory areas where the observable quantities (see Quantity_t) should
be stored.

Astrobj::Generic::processHitQuantities() fills the various arrays upon
request. A quantity is ignored if the corresponding pointer is NULL.

Scenery::operator()() increments the Properties between each Photon
using Properties::operator++().

The main application (gyoto, the yorick plug-in, or your user
application) is responsible for allocating the various arrays, filling
the various members of Properties, and doing whatever meaninful with
the arrays after they have been filled with values by the ray-tracing
code (e.g. saving them to disk or displaying them).

Also see Gyoto::Scenery and Gyoto::Quantity_t.

C++ includes: GyotoAstrobj.h ";

%feature("docstring")  Gyoto::Astrobj::Properties::Properties "

Default constructor (everything is set to NULL);. ";

%feature("docstring")  Gyoto::Astrobj::Properties::Properties "

< Set intensity and time pointers. ";

%feature("docstring")  Gyoto::Astrobj::Properties::init "

Initialize observable quantities.

The pointed-to values are initialized as follows (if the corresponding
pointer is not NULL):

intensity, firt_dmin_found, redshift, userN: 0

time, distance, first_dmin: DBL_MAX

for spectrum and binspectrum, nbnuobs values separated by offset in
memory are initialized to 0

for impactcoords, 16 contiguous values are initialized to DBL_MAX ";

%feature("docstring")  Gyoto::Astrobj::Properties::intensityConverter
"

Set Properties::intentity_converter_. ";

%feature("docstring")  Gyoto::Astrobj::Properties::intensityConverter
"

Set Properties::intentity_converter_. ";

%feature("docstring")  Gyoto::Astrobj::Properties::spectrumConverter "

Set Properties::spectrum_converter_. ";

%feature("docstring")  Gyoto::Astrobj::Properties::spectrumConverter "

Set Properties::spectrum_converter_. ";

%feature("docstring")
Gyoto::Astrobj::Properties::binSpectrumConverter "

Set Properties::binspectrum_converter_. ";

%feature("docstring")
Gyoto::Astrobj::Properties::binSpectrumConverter "

Set Properties::binspectrum_converter_. ";

%feature("docstring")  Gyoto::Astrobj::Properties::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::Properties::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::Properties::getRefCount "

Get the current number of references. ";


// File: class_gyoto_1_1_property.xml
%feature("docstring") Gyoto::Property "

Property that can be set and got using standard methods.

The Property API makes it easy to declare the parameters that can be
set in a class.

Developpers who simply write classes (deriving from Astrobj::Generic,
, Metric::Generic, Spectrum::Generic) need not know the inners of the
Property class and interact with it only using macros to declare the
parameters they need to read from XML.

To make use of the Property framework, a class must derive from
Gyoto::Object and use the GYOTO_OBJECT in a public section of the
class declaration (i.e. in the .h file). Then, in the corresponding .C
file, the GYOTO_PROPERTY_* macros are used as follows (note the
absence of punctuation after the macros):

In the above, GYOTO_PROPERTY_START starts the definition of the static
member MyClass::properties. Each GYOTO_PROPERTY_<type> macro declares
a new property. GYOTO_PROPERTY_END ends the definition of the property
list, with an optional pointer to the parent's class Property list,
and defines the MyClass::getProperties() method.

The underlying accessors must always be defined, both to set and to
get the property. For the sake of simplicity, only a limited number of
data types are allowed: double: see GYOTO_PROPERTY_DOUBLE,
GYOTO_PROPERTY_DOUBLE_UNIT;

long: see GYOTO_PROPERTY_LONG;

unsigned long: see GYOTO_PROPERTY_UNSIGNED_LONG (a.k.a. size_t: see
GYOTO_PROPERTY_SIZE_T, this may break on architectures where size_t is
not the same as unsigned long);

bool: see GYOTO_PROPERTY_BOOL;

std::vector<double>: see GYOTO_PROPERTY_VECTOR_DOUBLE and
GYOTO_PROPERTY_VECTOR_DOUBLE_UNIT;

std::vector<unsigned long>: see GYOTO_PROPERTY_VECTOR_UNSIGNED_LONG;

Gyoto::SmartPointers to various base classes: Screen, Metric::Generic,
Astrobj::Generic, Spectrum::Generic and Spectrometer::Generic. See
GYOTO_PROPERTY_METRIC, GYOTO_PROPERTY_SCREEN, GYOTO_PROPERTY_ASTROBJ,
GYOTO_PROPERTY_SPECTRUM and GYOTO_PROPERTY_SPECTROMETER.

For the floating point data-types (double and vector<double>), two
additional accessors supporting units can be provided. The accessors
must have the same name and have specific prototypes, see the various
function pointer typedefs, e.g. set_double_t and get_double_t.

The type used in these accessors may not be the same as the type of
the underlying class member. For instance, to read an array, it was
chosen to use the std::vector<type> type because it is easy to read
such a vector from XML and to thus determine dynamically the number of
elements provided. But this type is slow, so it is expected that the
class member will rather be a C-style array (double arr[]) or
something else entirely. It is not forbidden to have a set of high-
level accessors for the Property interface on top of lower-level, more
efficient accessors to be used in compiled, static code:

In this example, assuming MyClass is based directly on Object and
member_ is the only parameter to read from XML, the Property list may
be defined as:

Again, nothing more is required to read and write ArrayMember from XML
and from Yorick.

C++ includes: GyotoProperty.h ";

%feature("docstring")  Gyoto::Property::Property "

Default constructor. ";

%feature("docstring")  Gyoto::Property::Property "

Constructor for type== empty_t. ";

%feature("docstring")  Gyoto::Property::Property "

Constructor for class name pseudo-property. ";

%feature("docstring")  Gyoto::Property::Property "

Constructor for type== long_t. ";

%feature("docstring")  Gyoto::Property::Property "

Constructor for type== unsigned_long_t. ";

%feature("docstring")  Gyoto::Property::Property "

Constructor for type== size_t_t.

The dummy int parameter is only there to differenciate from the
unsigned long constructor on platforms where size_t is a typdef to
unsigned long. ";

%feature("docstring")  Gyoto::Property::Property "

Constructor for type== double_t, without unit support. ";

%feature("docstring")  Gyoto::Property::Property "

Constructor for type== double_t, with unit support. ";

%feature("docstring")  Gyoto::Property::Property "

Constructor for type== bool_t. ";

%feature("docstring")  Gyoto::Property::Property "

Constructor for type== string_t or filename_t.

Parameters:
-----------

name:  name of the Property

set_string:  pointer to the setter accessor

get_string:  pointer to the getter accessor

is_filename:  true means type= filename_t ";

%feature("docstring")  Gyoto::Property::Property "

Constructor for type== vector_double_t, without unit support. ";

%feature("docstring")  Gyoto::Property::Property "

Constructor for type== vector_double_t, with unit support. ";

%feature("docstring")  Gyoto::Property::Property "

Constructor for type== vector_unsigned_long_t. ";

%feature("docstring")  Gyoto::Property::Property "

Constructor for type== metric_t. ";

%feature("docstring")  Gyoto::Property::Property "

Constructor for type== screen_t. ";

%feature("docstring")  Gyoto::Property::Property "

Constructor for type== astrobj_t. ";

%feature("docstring")  Gyoto::Property::Property "

Constructor for type== spectrum_t. ";

%feature("docstring")  Gyoto::Property::Property "

Constructor for type== spectrometer_t. ";

%feature("docstring")  Gyoto::Property::Property "

Constructor setting only name and type.

Used in the Python plug-in to provide peudo-properties ";


// File: class_gyoto_1_1_metric_1_1_python.xml
%feature("docstring") Gyoto::Metric::Python "

Metric coded in Python.

Loader for Python Metric classes. It interfaces with a Python class
which must implement at least the gmunu and christoffel methods.

Other methods are optional: getRmb, getRms,
getSpecificAngularMomentum, getPotential.

Use <Cartesian> or </Spherical> to select the coordinate system kind.

Sample XML file: Sample Python module:

C++ includes: GyotoPython.h ";

%feature("docstring")  Gyoto::Metric::Python::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Metric::Python::Python "";

%feature("docstring")  Gyoto::Metric::Python::Python "";

%feature("docstring")  Gyoto::Metric::Python::~Python "";

%feature("docstring")  Gyoto::Metric::Python::clone "

Virtual copy constructor. ";

%feature("docstring")  Gyoto::Metric::Python::spherical "";

%feature("docstring")  Gyoto::Metric::Python::spherical "";

%feature("docstring")  Gyoto::Metric::Python::module "

Return module_. ";

%feature("docstring")  Gyoto::Metric::Python::module "

Set module_ and import the Python module.

Side effects: sets inline_module_ to \"\";

calls klass( class_) if class_ is already known, so module_ can be set
(or reset) after class_. ";

%feature("docstring")  Gyoto::Metric::Python::inlineModule "

Return inline_module_. ";

%feature("docstring")  Gyoto::Metric::Python::inlineModule "

Set inline_module_ and import the Python module.

Side effects: sets module_ to \"\";

calls klass( class_) if class_ is already known, so module_ can be set
(or reset) after class_. ";

%feature("docstring")  Gyoto::Metric::Python::klass "

Retrieve class_. ";

%feature("docstring")  Gyoto::Metric::Python::klass "

Set class_ and instantiate the Python class.

Sets pInstance_.

This generic implementation takes care of the common ground, but does
not set 'this' or call parameters( parameters_). Therefore, all the
derived classes should reimplement this method and at least call
Python::Base::klass(c) and parameters( parameters_). Between the two
is the right moment to check that the Python class implements the
required API and to cache PyObject* pointers to class methods. ";

%feature("docstring")  Gyoto::Metric::Python::parameters "

Retrieve parameters_. ";

%feature("docstring")  Gyoto::Metric::Python::parameters "

Set parameters_ and send them to pInstance_.

The parameters are sent to the class instance using the setitem method
with numerical keys. ";

%feature("docstring")  Gyoto::Metric::Python::mass "

Set mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::Python::gmunu "";

%feature("docstring")  Gyoto::Metric::Python::christoffel "";

%feature("docstring")  Gyoto::Metric::Python::getRmb "

Returns the marginally bound radius Should be implemented in derived
classes if useful If called on the base class, returns an error ";

%feature("docstring")  Gyoto::Metric::Python::getRms "

Returns the marginally stable (ISCO) radius Should be implemented in
derived classes if useful If called on the base class, returns an
error ";

%feature("docstring")
Gyoto::Metric::Python::getSpecificAngularMomentum "

Returns the specific angular momentum l=-u_phi/u_t Should be
implemented in derived classes if useful If called on the base class,
returns an error ";

%feature("docstring")  Gyoto::Metric::Python::getPotential "

Returns potential W=-ln(|u_t|) for a cst specific angular momentum
l_cst Should be implemented in derived classes if useful If called on
the base class, returns an error ";

%feature("docstring")  Gyoto::Metric::Python::isStopCondition "

Check whether integration should stop.

The integrating loop will ask this the Metric through this method
whether or not it is happy to continue the integration. Typically, the
Metric should answer 0 when everything is fine, 1 when too close to
the event horizon, inside the BH...

Parameters:
-----------

coord:  8-coordinate vector to check. ";

%feature("docstring")  Gyoto::Metric::Python::circularVelocity "

Yield circular velocity at a given position.

Give the velocity of a massive particle in circular orbit at the given
position projected onto the equatorial plane. Such a velocity may not
exist everywhere (or anywhere) for a given metric. This method is
intended to be used by Astrobj classes such as Torus or ThinDisk.

If keplerian_ is set to true, this method should return the Keplerian
velcity instead (derived classes should ensure this, see
KerrBL::circularVelocity() for instance).

The default implementation throws an error if keplerian_ is set to
false.

Parameters:
-----------

pos:  input: position,

vel:  output: velocity,

dir:  1 for corotating, -1 for counterrotating. ";

%feature("docstring")  Gyoto::Metric::Python::set "";

%feature("docstring")  Gyoto::Metric::Python::set "";

%feature("docstring")  Gyoto::Metric::Python::set "";

%feature("docstring")  Gyoto::Metric::Python::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Metric::Python::get "";

%feature("docstring")  Gyoto::Metric::Python::get "";

%feature("docstring")  Gyoto::Metric::Python::get "";

%feature("docstring")  Gyoto::Metric::Python::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Metric::Python::setParameter "";

%feature("docstring")  Gyoto::Metric::Python::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Metric::Python::fillElement "";

%feature("docstring")  Gyoto::Metric::Python::setParameters "";

%feature("docstring")  Gyoto::Metric::Python::coordKind "

Get coordinate kind. ";

%feature("docstring")  Gyoto::Metric::Python::getRefCount "";

%feature("docstring")  Gyoto::Metric::Python::mass "

Set mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::Python::mass "

Get mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::Python::mass "

Get mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::Python::unitLength "

M * G / c^2, M is in kg, unitLength in meters.

Metrics implementations are free to express lengths and distances in
whatever unit they see fit (presumably most often geometrical units).
This function returns this unit in SI (meters). ";

%feature("docstring")  Gyoto::Metric::Python::unitLength "

unitLength expressed in specified unit ";

%feature("docstring")  Gyoto::Metric::Python::deltaMin "

Get delta_min_ ";

%feature("docstring")  Gyoto::Metric::Python::deltaMin "

Set delta_min_ ";

%feature("docstring")  Gyoto::Metric::Python::deltaMax "

Get delta_max_ ";

%feature("docstring")  Gyoto::Metric::Python::deltaMax "

Get delta max at a given position

Parameters:
-----------

pos:  4-position

[optional]:  delta_max_external external constraint on delta_max

the smallest value between delta_max_, delta_max_external, and
R*delta_max_over_r_ where R is pos[1] in spherical coordinates and
max(x1, x2, x3) in Cartesian coordinates. ";

%feature("docstring")  Gyoto::Metric::Python::deltaMax "

Set delta_max_ ";

%feature("docstring")  Gyoto::Metric::Python::deltaMaxOverR "

Get delta_max_over_r_. ";

%feature("docstring")  Gyoto::Metric::Python::deltaMaxOverR "

Set delta_max_over_r_. ";

%feature("docstring")  Gyoto::Metric::Python::keplerian "

Get keplerian_. ";

%feature("docstring")  Gyoto::Metric::Python::keplerian "

Set keplerian_. ";

%feature("docstring")  Gyoto::Metric::Python::cartesianVelocity "

Compute xprime, yprime and zprime from 8-coordinates. ";

%feature("docstring")  Gyoto::Metric::Python::SysPrimeToTdot "

Compute tdot as a function of dr/dt, dtheta/dt and dphi/dt. Everything
is in geometrical units.

Parameters:
-----------

coord:  4-position (geometrical units);

v:  3-velocity dx1/dx0, dx2/dx0, dx3/dx0;

tdot = dx0/dtau. ";

%feature("docstring")  Gyoto::Metric::Python::zamoVelocity "

Yield ZAMO velocity at a given position.

Give the velocity of a zero angular momentul observer (whatever is
closest to \"at rest\"). The default implementation simply projects
(1, 0, 0, 0) othogonally along ephi and normalizes it, thus ensuring
that vel is orthogonal to ephi.

Parameters:
-----------

pos:  input: position,

vel:  output: velocity, ";

%feature("docstring")  Gyoto::Metric::Python::nullifyCoord "

Set tdot (coord[4]) such that coord is light-like. Everything is in
geometrical units.

Set coord[4] so that the 4-velocity coord[4:7] is lightlike, i.e. of
norm 0. There may be up to two solutions. coord[4] is set to the
hightest. The lowest can be retrieved using nullifyCoord(double
coord[8], double& tdot2) const. Everything is expressed in geometrical
units.

Parameters:
-----------

coord:  8-position, coord[4] will be set according to the other
elements; ";

%feature("docstring")  Gyoto::Metric::Python::nullifyCoord "

Set tdot (coord[4]) such that coord is light-like and return other
possible tdot.

Set coord[4] so that the 4-velocity coord[4:7] is lightlike, i.e. of
norm 0. There may be up to two solutions. coord[4] is set to the
hightest. The lowest can be retrieved in tdot2. Everything is
expressed in geometrical units.

Parameters:
-----------

coord:  8-position, coord[4] will be set according to the other
elements;

tdot2:  will be set to the smallest solution ";

%feature("docstring")  Gyoto::Metric::Python::normalizeFourVel "

Normalize fourvelvel to -1.

First computes threevel as xiprime=xidot/x0dot for i in {1, 2, 3},
then computes x0dot using SyPrimeToTdot, then computes again xidot as
xidot=xiprime*x0dot.

Parameters:
-----------

coord:  8-position, coord[4-7] will be set according to the other
elements; ";

%feature("docstring")  Gyoto::Metric::Python::normalizeFourVel "

Normalize fourvelvel to -1.

First computes threevel as xiprime=xidot/x0dot for i in {1, 2, 3},
then computes x0dot using SyPrimeToTdot, then computes again xidot as
xidot=xiprime*x0dot.

Parameters:
-----------

pos:  4-position;

fourvel:  4-velocity, will be renormalized. ";

%feature("docstring")  Gyoto::Metric::Python::ScalarProd "

Scalar product.

Compute the scalarproduct of the two quadrivectors u1 and u2 in this
Metric, at point pos expressed in coordinate system sys.

Parameters:
-----------

pos:  4-position;

u1:  1st quadrivector;

u2:  2nd quadrivector;

u1*u2 ";

%feature("docstring")  Gyoto::Metric::Python::norm "

Scalar product.

Compute the norm of the quadrivector u1 in this Metric, at point pos
expressed in coordinate system sys.

Parameters:
-----------

pos:  4-position;

u1:  quadrivector;

||u1|| ";

%feature("docstring")  Gyoto::Metric::Python::multiplyFourVect "

multiply vector by scalar ";

%feature("docstring")  Gyoto::Metric::Python::addFourVect "

add second vector to first one ";

%feature("docstring")  Gyoto::Metric::Python::projectFourVect "

project u1 orthogonally to u2 at pos ";

%feature("docstring")  Gyoto::Metric::Python::dualOneForm "

Computes dual 1-form Compute the dual 1-form of 4-vector.

Parameters:
-----------

IN_ARRAY1_1:  4-position;

IN_ARRAY1_2:  quadrivector;

ARGOUT_ARRAY1:  output 1-form ";

%feature("docstring")  Gyoto::Metric::Python::observerTetrad "

Computes the orthonormal local tetrad of the observer.

Parameters:
-----------

obskind:  input: kind of observer (eg:
\"ZAMO\",\"KeplerianObserver\"...)

pos:  input: position,

fourvel:  output: observer 4-velocity (norm -1)

screen1:  output: first vector in the screen plane

screen2:  output: second vector in the screen plane

screen3:  output: vector normal to the screen ";

%feature("docstring")  Gyoto::Metric::Python::observerTetrad "

Computes the orthonormal local tetrad of the observer.

Parameters:
-----------

pos:  position,

fourvel:  observer 4-velocity (norm -1)

screen1:  first vector in the screen plane

screen2:  second vector in the screen plane

screen3:  vector normal to the screen ";

%feature("docstring")  Gyoto::Metric::Python::GramSchmidt "

Apply Gram-Schmidt orthonormalization to a basis.

On input, u0 to u3 must be four non-zero norm, independent 4-vectors.
On output, they will form an orthonormal basis.

Parameters:
-----------

pos:  position,

u0:  basis vector

u1:  basis vector

u2:  basis vector

u3:  basis vector ";

%feature("docstring")  Gyoto::Metric::Python::gmunu "

Metric coefficients.

The default implementation calls Metric:: gmunu(double g[4][4], const
double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::Python::gmunu "

Metric coefficients.

The default implementation calls double gmunu(const double * x, int
mu, int nu) const.

Parameters:
-----------

ARGOUT_ARRAY2:  (g) 4x4 array to store the coeefficients

IN_ARRAY1:  (x) 4-position at which to compute the coefficients;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::Python::gmunu_up "

Metric contravariant coefficients.

The default implementation calls Metric:: gmunu_up(double g[4][4],
const double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::Python::gmunu_up "

Metric contravariant coefficients.

The default implementation inverts the covariant coefficients matrix.
";

%feature("docstring")  Gyoto::Metric::Python::jacobian "

Derivatives of the metric covariant coefficients.

The default implementation evaluates them numerically. The gmunu
matrix is assumed to be symmetrical but no other assumptions are made
at the moment. ";

%feature("docstring")  Gyoto::Metric::Python::gmunu_up_and_jacobian "

gmunu_up() and jacobian() in one go ";

%feature("docstring")  Gyoto::Metric::Python::computeNBeta "

Computes lapse scalar and shift vector at coord. ";

%feature("docstring")  Gyoto::Metric::Python::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3). ";

%feature("docstring")  Gyoto::Metric::Python::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3).

1 on error, 0 otherwise ";

%feature("docstring")  Gyoto::Metric::Python::myrk4 "

RK4 integrator. ";

%feature("docstring")  Gyoto::Metric::Python::myrk4 "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::Python::myrk4_adaptive "

RK4 integrator with adaptive step. ";

%feature("docstring")  Gyoto::Metric::Python::myrk4_adaptive "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::Python::diff "

F function such as dx/dt=F(x,cst) ";

%feature("docstring")  Gyoto::Metric::Python::diff "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::Python::diff "";

%feature("docstring")  Gyoto::Metric::Python::diff31 "

F function such as dx/dt=F(x,cst) for 3+1 case. ";

%feature("docstring")  Gyoto::Metric::Python::setParticleProperties "

Set Metric-specific constants of motion. Used e.g. in KerrBL. ";

%feature("docstring")  Gyoto::Metric::Python::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Metric::Python::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Metric::Python::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Metric::Python::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Metric::Python::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Metric::Python::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Metric::Python::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Metric::Python::kind "

Get kind_. ";

%feature("docstring")  Gyoto::Metric::Python::hook "

Start listening.

Use from a Hook::Listener object method: where \"this\" is a Listener
and \"teller\" is a Teller.

Use unhook() later to stop listening to a given Teller.

Parameters:
-----------

listener:  pointer to the new listener ";

%feature("docstring")  Gyoto::Metric::Python::unhook "

Stop listening.

Use from a Hook::Listener object method:

where \"this\" is a Listener, \"teller\" is a Teller, and \"this\" has
called teller->hook(this) previously.

Parameters:
-----------

listener:  pointer to the listener ";

%feature("docstring")  Gyoto::Metric::Python::hasPythonProperty "";

%feature("docstring")  Gyoto::Metric::Python::setPythonProperty "";

%feature("docstring")  Gyoto::Metric::Python::getPythonProperty "";

%feature("docstring")  Gyoto::Metric::Python::pythonPropertyType "";


// File: class_gyoto_1_1_spectrum_1_1_python.xml
%feature("docstring") Gyoto::Spectrum::Python "

Loader for Python classes implementing the Spectrum interface.

It interfaces with a Python class which must implement at least the
call method.

Sample XML file: Sample Python module:

C++ includes: GyotoPython.h ";

%feature("docstring")  Gyoto::Spectrum::Python::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Spectrum::Python::Python "";

%feature("docstring")  Gyoto::Spectrum::Python::Python "";

%feature("docstring")  Gyoto::Spectrum::Python::clone "

Cloner. ";

%feature("docstring")  Gyoto::Spectrum::Python::~Python "";

%feature("docstring")  Gyoto::Spectrum::Python::module "

Return module_. ";

%feature("docstring")  Gyoto::Spectrum::Python::module "

Set module_ and import the Python module.

Side effects: sets inline_module_ to \"\";

calls klass( class_) if class_ is already known, so module_ can be set
(or reset) after class_. ";

%feature("docstring")  Gyoto::Spectrum::Python::inlineModule "

Return inline_module_. ";

%feature("docstring")  Gyoto::Spectrum::Python::inlineModule "

Set inline_module_ and import the Python module.

Side effects: sets module_ to \"\";

calls klass( class_) if class_ is already known, so module_ can be set
(or reset) after class_. ";

%feature("docstring")  Gyoto::Spectrum::Python::klass "

Retrieve class_. ";

%feature("docstring")  Gyoto::Spectrum::Python::klass "

Set class_ and instantiate the Python class.

Sets pInstance_.

This generic implementation takes care of the common ground, but does
not set 'this' or call parameters( parameters_). Therefore, all the
derived classes should reimplement this method and at least call
Python::Base::klass(c) and parameters( parameters_). Between the two
is the right moment to check that the Python class implements the
required API and to cache PyObject* pointers to class methods. ";

%feature("docstring")  Gyoto::Spectrum::Python::parameters "

Retrieve parameters_. ";

%feature("docstring")  Gyoto::Spectrum::Python::parameters "

Set parameters_ and send them to pInstance_.

The parameters are sent to the class instance using the setitem method
with numerical keys. ";

%feature("docstring")  Gyoto::Spectrum::Python::integrate "

Integrate optically thick I_nu.

See operator()(double nu) const

Parameters:
-----------

nu1:  nu2:  boundaries for the integration

I, the integral of I_nu between nu1 and nu2 ";

%feature("docstring")  Gyoto::Spectrum::Python::set "";

%feature("docstring")  Gyoto::Spectrum::Python::set "";

%feature("docstring")  Gyoto::Spectrum::Python::set "";

%feature("docstring")  Gyoto::Spectrum::Python::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Spectrum::Python::get "";

%feature("docstring")  Gyoto::Spectrum::Python::get "";

%feature("docstring")  Gyoto::Spectrum::Python::get "";

%feature("docstring")  Gyoto::Spectrum::Python::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Spectrum::Python::setParameter "";

%feature("docstring")  Gyoto::Spectrum::Python::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Spectrum::Python::fillElement "";

%feature("docstring")  Gyoto::Spectrum::Python::setParameters "";

%feature("docstring")  Gyoto::Spectrum::Python::integrate "

Integrate optically thin I_nu.

See operator()(double nu, double opacity, double ds) const

Parameters:
-----------

nu1:  nu2:  boundaries for the integration

opacity:  the frequency-dependent opacity law given as a pointer to a
Gyoto::Spectrum::Generic sub-class instance

ds:  the element length for spatial integration

I, the integral of I_nu between nu1 and nu2 ";

%feature("docstring")  Gyoto::Spectrum::Python::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Spectrum::Python::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Spectrum::Python::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Spectrum::Python::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Spectrum::Python::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Spectrum::Python::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Spectrum::Python::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Spectrum::Python::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Spectrum::Python::kind "

Get kind_. ";

%feature("docstring")  Gyoto::Spectrum::Python::hasPythonProperty "";

%feature("docstring")  Gyoto::Spectrum::Python::setPythonProperty "";

%feature("docstring")  Gyoto::Spectrum::Python::getPythonProperty "";

%feature("docstring")  Gyoto::Spectrum::Python::pythonPropertyType "";


// File: class_gyoto_1_1_screen_1_1_range.xml
%feature("docstring") Range "

1D coordinated specifier for a range

C++ includes: GyotoScreen.h ";

%feature("docstring")  Range::Range "

Specify min, max and step of this range. ";

%feature("docstring")  Range::begin "

Reset specifier to point to the first value. ";

%feature("docstring")  Range::valid "

True if pointing to something, false if end has been reached. ";

%feature("docstring")  Range::size "

Number of values in this container. ";

%feature("docstring")  Range::index "

Get index of value currently pointed to.

Starts at 0 and is implemented each time operator++ is called.
Depending on the implementation, this may be a real index or computed
on demand. ";

%feature("docstring")  Range::angle "

Get double value currently pointed to. ";


// File: class_gyoto_1_1_photon_1_1_refined.xml
%feature("docstring") Gyoto::Photon::Refined "

Refine last step of integration in a Photon.

The integration step of a Photon's geodesic is adaptive. This is
computationally efficient, but sometimes it is necessary to get the
position of a Photon with a finer step.
Gyoto::ComplexAstrobj::Impact() is a typical use case.

A Refined photon is linked to its parent. In particular, care is taken
so that the parent's to update the parent's transmissions whenever the
Refined transmissions are touched.

Don't use this class blindly: what's guaranteed to work is what is
used in Gyoto::ComplexAstrobj::Impact().

XML description corresponding to this class is <Photon/>. It supports
all the parameters supported by the Gyoto::Worldline class plus an
optional <Astrobj/> section to attach a instance of a
Gyoto::Astrobj::Generic sub-class.

C++ includes: GyotoPhoton.h ";

%feature("docstring")  Gyoto::Photon::Refined::Refined "

Constructor. ";

%feature("docstring")  Gyoto::Photon::Refined::transmit "

Update transmission both in *this and in *parent_. ";

%feature("docstring")  Gyoto::Photon::Refined::transmit "

Update transmission Matrix both in *this and in *parent_. ";

%feature("docstring")  Gyoto::Photon::Refined::transfer "

Perform one step of polarized radiative transfert and update
transmission matrix. ";

%feature("docstring")  Gyoto::Photon::Refined::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Photon::Refined::className "

\"Photon\" ";

%feature("docstring")  Gyoto::Photon::Refined::className_l "

\"photon\" ";

%feature("docstring")  Gyoto::Photon::Refined::clone "

Cloner. ";

%feature("docstring")  Gyoto::Photon::Refined::getMass "

Return 0. ";

%feature("docstring")  Gyoto::Photon::Refined::astrobj "

Set Photon::object_. ";

%feature("docstring")  Gyoto::Photon::Refined::astrobj "

Get Photon::object_. ";

%feature("docstring")  Gyoto::Photon::Refined::metric "";

%feature("docstring")  Gyoto::Photon::Refined::metric "

Set metric Smartpointer. ";

%feature("docstring")  Gyoto::Photon::Refined::metric "

Get metric. ";

%feature("docstring")  Gyoto::Photon::Refined::metric "

Get metric. ";

%feature("docstring")  Gyoto::Photon::Refined::spectrometer "

Set Photon::spectro_. ";

%feature("docstring")  Gyoto::Photon::Refined::spectrometer "

Get Photon::spectro_. ";

%feature("docstring")  Gyoto::Photon::Refined::freqObs "

Set Photon::freq_obs__. ";

%feature("docstring")  Gyoto::Photon::Refined::freqObs "

Get Photon::freq_obs__. ";

%feature("docstring")  Gyoto::Photon::Refined::nb_cross_eqplane "

Set Photon::nb_cross_eqplane_. ";

%feature("docstring")  Gyoto::Photon::Refined::nb_cross_eqplane "

Get Photon::nb_cross_eqplane_. ";

%feature("docstring")  Gyoto::Photon::Refined::setInitialCondition "

Set or re-set the initial condition prior to integration.

Set initial condition for this Photon. Several versions of this
function, with and without base vectors to parallel-transport, are
provided. If polarization is to be treated, use the version with the
base vectors.

Parameters:
-----------

gg:   Gyoto::SmartPointer to the Gyoto::Metric in this universe;

obj:   Gyoto::SmartPointer to the target Gyoto::Astrobj;

coord:  8-element array containing the initial condition, i.e. the
4-position and the 4-velocity of the Photon at the receiving end; ";

%feature("docstring")  Gyoto::Photon::Refined::setInitialCondition "

Set or re-set the initial condition prior to integration.

Set initial condition for this Photon. Several versions of this
function, with and without base vectors to parallel-transport, are
provided. If polarization is to be treated, use the version with the
base vectors. Initialize those vectors to the two base vectors for the
Stokes parameters in the observer screen.

Parameters:
-----------

gg:   Gyoto::SmartPointer to the Gyoto::Metric in this universe;

obj:   Gyoto::SmartPointer to the target Gyoto::Astrobj;

coord:  8-element array containing the initial condition, i.e. the
4-position and the 4-velocity of the Photon at the receiving end;

Ephi:  initial value of base vector to parallel-transport. Ignored if
parallel_transport_ is false.

Etheta:  initial value of base vector to parallel-transport. Ignored
if parallel_transport_ is false. ";

%feature("docstring")  Gyoto::Photon::Refined::setInitialCondition "

Set or re-set the initial condition prior to integration.

Set initial condition for this Photon. This version of this function
automatically takes care of initializing the base vectors for
polarization when needed.

Parameters:
-----------

gg:   Gyoto::SmartPointer to the Gyoto::Metric in this universe;

obj:   Gyoto::SmartPointer to the target Gyoto::Astrobj;

screen:  Observer's screen;

d_alpha:  Direction of arrival (RA offset) in radians;

d_delta:  Direction of arrival (Dec offset) in radians. ";

%feature("docstring")  Gyoto::Photon::Refined::setInitialCondition "

Set or re-set the initial condition prior to integration.

Parameters:
-----------

gg:   Gyoto::SmartPointer to the Gyoto::Metric in this universe;

coord:  8 element array containing the initial condition, i.e. the
4-position and the 4-velocity of the Photon at the receiving end;

dir:  direction: 1 for future, -1 for past.

Ephi:  initial value of base vector to parallel-transport. Ignored if
parallel_transport_ is false.

Etheta:  initial value of base vector to parallel-transport. Ignored
if parallel_transport_ is false. ";

%feature("docstring")  Gyoto::Photon::Refined::setInitialCondition "

Set or re-set the initial condition prior to integration.

Parameters:
-----------

gg:   Gyoto::SmartPointer to the Gyoto::Metric in this universe;

coord:  8 element array containing the initial condition, i.e. the
4-position and the 4-velocity of the Photon at the receiving end;

dir:  direction: 1 for future, -1 for past. ";

%feature("docstring")  Gyoto::Photon::Refined::setInitialCondition "

Set or re-set the initial condition prior to integration.

Parameters:
-----------

gg:   Gyoto::SmartPointer to the Gyoto::Metric in this universe;

coord:  8 element array containing the initial condition, i.e. the
4-position and the 4-velocity of the Photon at the receiving end;

dir:  direction: 1 for future, -1 for past.

Ephi:  initial value of base vector to parallel-transport. Ignored if
parallel_transport_ is false.

Etheta:  initial value of base vector to parallel-transport. Ignored
if parallel_transport_ is false. ";

%feature("docstring")  Gyoto::Photon::Refined::setInitialCondition "

Set or re-set the initial condition prior to integration.

Parameters:
-----------

gg:   Gyoto::SmartPointer to the Gyoto::Metric in this universe;

coord:  8 element array containing the initial condition, i.e. the
4-position and the 4-velocity of the Photon at the receiving end;

dir:  direction: 1 for future, -1 for past. ";

%feature("docstring")  Gyoto::Photon::Refined::hit "

Integrate the geodesic.

Parameters:
-----------

data:  Optional Astrobj::Properties to fill with observational
quantities.

1 if object was hit, else 0. ";

%feature("docstring")  Gyoto::Photon::Refined::findMin "

Find minimum of photonobject distance.

Return the minimum of (*object)(this-> getCoord()) between t1 and t2.
The date of this minimum is returned in tmin.

Parameters:
-----------

object:  the distance to minimize is given by object->operator()().
This method is in particular implemented by the subclasses of
Astrobj::Standard.

t1:  date

t2:  date

tmin:  on output, date correspondig to the minimum

threshold:  stop searching for a minimum if a value < threshold is
found (very often, we just want to find a date below the threshold,
not the accurate minimum). ";

%feature("docstring")  Gyoto::Photon::Refined::findValue "

Find date for which the photon is at a given distance from the object.

Parameters:
-----------

object:   Object, must implement operator() (e.g. Astrobj::Standard,
ThinDisk::Standard)

value:  The value to find

tinside:  A date for which
object->Astrobj::operator()(Photon::getCoord()) is < value

toutside:  On input: a date for which
object->Astrobj::operator()(Photon::getCoord()) is > value. on output,
(*object)(getCoord(toutside)) is < value, very close to value.
toutside is closer to tinside on output than on input. ";

%feature("docstring")  Gyoto::Photon::Refined::setParameters "

Main loop for parsing Properties from XML description.

This function queries the FactoryMessenger for elements to parse, and
tries to matche each element to a Property to set it  accordingly. Any
class that tries to be buildable from XML must supply a subcontractor
(for base classes such as Metric, Astrobj, Spectrum  and Spectrometer,
it is done as a template that must be  specialized for each class).
This subcontractor typically looks somewhat like this: Although this
is discouraged, it is possible to override the following functions to
customize how XML entities are parsed:    - setParameters() if low-
level access to the      FactoryMessenger is required;    -
setParameter(std::string name, std::string content,
std::string unit)      to interpret an entity that does not match a
Property      (e.g. alternative name);    -
setParameter(Gyoto::Property const &p, std::string const &name,
std::string const &content, std::string const &unit)      to change
how a Property is interpreted. ";

%feature("docstring")  Gyoto::Photon::Refined::resetTransmission "

Set transmission to 1 for each channel as well as scalar transmission.
";

%feature("docstring")  Gyoto::Photon::Refined::resetTransmissionMatrix
"

Set transmission matrix to identity matrix for each frequency. ";

%feature("docstring")  Gyoto::Photon::Refined::getTransmission "

Get transmission.

Get either Photon::transmission_freqobs_ (with i=-1) or
Photon::transmission_[i].

Parameters:
-----------

i:  channel number of the requested frequency, -1 for
Photon::freq_obs_. ";

%feature("docstring")  Gyoto::Photon::Refined::getTransmission "

Get Photon::transmission_.

getTansmission()[i] == getTransmission(size_t i) ";

%feature("docstring")  Gyoto::Photon::Refined::getTransmissionMatrix "

Get transmission matrix.

Get either Photon::transmission_freqobs_ (with i=-1) or
Photon::transmission_[i].

Parameters:
-----------

i:  channel number of the requested frequency, -1 for
Photon::freq_obs_. ";

%feature("docstring")  Gyoto::Photon::Refined::getTransmissionMatrix "

Get Photon::transmissionMatrix_.

getTansmissionMatrix()[i] == getTransmissionMatrix(size_t i) ";

%feature("docstring")  Gyoto::Photon::Refined::getTransmissionMax "

Get maximum transmission;.

Get current maximum of all the transmissions,
Photon::transmission_freqobs_ or one elements of the
Photon::transmission_ array. ";

%feature("docstring")  Gyoto::Photon::Refined::getImin "

Get imin_. ";

%feature("docstring")  Gyoto::Photon::Refined::getImax "

Get imax_. ";

%feature("docstring")  Gyoto::Photon::Refined::getI0 "

Get i0_. ";

%feature("docstring")  Gyoto::Photon::Refined::initCoord "";

%feature("docstring")  Gyoto::Photon::Refined::initCoord "";

%feature("docstring")  Gyoto::Photon::Refined::setInitCoord "

Set Initial coordinate.

Set imin_= imax_= i0_, and x  [i0]=coord[ ].

If dir==1, i0_ is set to 0. If dir==-1, i0_ is set to x_size_-1.

If dir==0 and the Worldine has never been computed ( i0_==0, imin_==1
and imax_==0), then dir defaults to 1 for a massive particle and -1
for a massless particle.

If dir==0 and the Worldine has already been computed, i0_ is not
changed.



Parameters:
-----------

coord:  new initial coordinates

dir:  direction of integration. 1 for forward integration, -1 for
backards integration, 0 for unknown or both

Ephi:  initial value of base vector to parallel-transport. Ignored if
parallel_transport_ is false.

Etheta:  initial value of base vector to parallel-transport. Ignored
if parallel_transport_ is false. ";

%feature("docstring")  Gyoto::Photon::Refined::setInitCoord "

Set Initial coordinate.

Set imin_= imax_= i0_, and x  [i0]=coord[ ].

If dir==1, i0_ is set to 0. If dir==-1, i0_ is set to x_size_-1.

If dir==0 and the Worldine has never been computed ( i0_==0, imin_==1
and imax_==0), then dir defaults to 1 for a massive particle and -1
for a massless particle.

If dir==0 and the Worldine has already been computed, i0_ is not
changed.



Parameters:
-----------

coord:  new initial coordinates

dir:  direction of integration. 1 for forward integration, -1 for
backards integration, 0 for unknown or both ";

%feature("docstring")  Gyoto::Photon::Refined::setInitCoord "

Set initial coordinate.

Parameters:
-----------

pos:  initial 4-position

vel:  initial 3-velocity

dir:  direction of integration ";

%feature("docstring")  Gyoto::Photon::Refined::setPosition "

Set initial 4-position. ";

%feature("docstring")  Gyoto::Photon::Refined::setVelocity "

Set initial 3-velocity. ";

%feature("docstring")  Gyoto::Photon::Refined::reset "

Forget integration, keeping initial contition. ";

%feature("docstring")  Gyoto::Photon::Refined::reInit "

Reset and recompute particle properties. ";

%feature("docstring")  Gyoto::Photon::Refined::integrator "

Set the integrator.

Initialize state_ to use the required integrator.

Parameters:
-----------

type:  Either \"Legacy\" or (if GYOTO_HAVE_BOOST_INTEGRATORS) one of
\"runge_kutta_cash_karp54\", \"runge_kutta_fehlberg78\",
\"runge_kutta_dopri5\", \"runge_kutta_cash_karp54_classic\" ";

%feature("docstring")  Gyoto::Photon::Refined::integrator "

Describe the integrator used by state_. ";

%feature("docstring")  Gyoto::Photon::Refined::integ31 "

Set the integrator kind to 3+1 or 4D.

Initialize state_ to use the required geodesic equation. ";

%feature("docstring")  Gyoto::Photon::Refined::integ31 "

Get the kind of geodesic equation integrated by state_. ";

%feature("docstring")  Gyoto::Photon::Refined::deltaMin "

Get delta_min_. ";

%feature("docstring")  Gyoto::Photon::Refined::deltaMin "

Set delta_min_. ";

%feature("docstring")  Gyoto::Photon::Refined::deltaMax "

Get delta_max_. ";

%feature("docstring")  Gyoto::Photon::Refined::deltaMax "

Get delta max at a given position

Parameters:
-----------

pos:  4-position

delta_max_external:  external constraint on delta_max

the smallest value between delta_max_, delta_max_external, and R*
delta_max_over_r_ where R is pos[1] in spherical coordinates and
max(x1, x2, x3) in Cartesian coordinates. ";

%feature("docstring")  Gyoto::Photon::Refined::deltaMax "

Set delta_max_ ";

%feature("docstring")  Gyoto::Photon::Refined::absTol "

Set abstol_. ";

%feature("docstring")  Gyoto::Photon::Refined::absTol "

Get abstol_. ";

%feature("docstring")  Gyoto::Photon::Refined::relTol "

Set reltol_. ";

%feature("docstring")  Gyoto::Photon::Refined::relTol "

Get reltol_. ";

%feature("docstring")  Gyoto::Photon::Refined::maxCrossEqplane "

Set #maxCrosEqplane_. ";

%feature("docstring")  Gyoto::Photon::Refined::maxCrossEqplane "

Get maxCrossEqplane_. ";

%feature("docstring")  Gyoto::Photon::Refined::deltaMaxOverR "

Get delta_max_over_r_. ";

%feature("docstring")  Gyoto::Photon::Refined::deltaMaxOverR "

Set delta_max_over_r_. ";

%feature("docstring")  Gyoto::Photon::Refined::delta "

Expand memory slots for polarization vectors.

Assignment to another Worldline Set delta_ ";

%feature("docstring")  Gyoto::Photon::Refined::delta "

Set delta_ in specified units. ";

%feature("docstring")  Gyoto::Photon::Refined::delta "

Get delta_. ";

%feature("docstring")  Gyoto::Photon::Refined::delta "

Get delta_ in specified units. ";

%feature("docstring")  Gyoto::Photon::Refined::tMin "

Get tmin_. ";

%feature("docstring")  Gyoto::Photon::Refined::tMin "

Get tmin_ in specified unit. ";

%feature("docstring")  Gyoto::Photon::Refined::tMin "

Set tmin_. ";

%feature("docstring")  Gyoto::Photon::Refined::tMin "

Set tmin_ in specified unit. ";

%feature("docstring")  Gyoto::Photon::Refined::adaptive "

Set adaptive_. ";

%feature("docstring")  Gyoto::Photon::Refined::adaptive "

Get adaptive_. ";

%feature("docstring")  Gyoto::Photon::Refined::secondary "

Set secondary_. ";

%feature("docstring")  Gyoto::Photon::Refined::secondary "

Get secondary_. ";

%feature("docstring")  Gyoto::Photon::Refined::parallelTransport "

Set parallel_transport_. ";

%feature("docstring")  Gyoto::Photon::Refined::parallelTransport "

Get parallel_transport_. ";

%feature("docstring")  Gyoto::Photon::Refined::maxiter "

Set maxiter_. ";

%feature("docstring")  Gyoto::Photon::Refined::maxiter "

Get maxiter_. ";

%feature("docstring")  Gyoto::Photon::Refined::getCst "

Returns the worldline's cst of motion (if any)

Return pointer to array holding the previously set Metric-specific
constants of motion.

This function returns a pointer to the actual storage location and
should be handled with care. std::vector<double> Worldline:
constantsOfMotion() constprovides a convenient way to retrieve a copy
of the content. ";

%feature("docstring")  Gyoto::Photon::Refined::setCst "

Set Metric-specific constants of motion.

The will (re)allocate Worldline::cst_, copy cst into it, and set
Worldline::cst_n_.

This is the same as void Worldline:
constantsOfMotion(std::vector<double> const cstv) using a C-style
array instead of a vector. ";

%feature("docstring")  Gyoto::Photon::Refined::constantsOfMotion "

Set Metric-specific constants of motion.

The will (re)allocate Worldline::cst_, copy cst into it, and set
Worldline::cst_n_.

This is the same as getCst using a vector instead of a C-style array.
";

%feature("docstring")  Gyoto::Photon::Refined::constantsOfMotion "

Return a copy of the Metric-specific constants of motion.

This funtion return a copy of the constants of motion. getCst() can be
used to retrieve a pointer to the actual array used internally which
is slightly more efficient for read-only access. ";

%feature("docstring")  Gyoto::Photon::Refined::getInitialCoord "

Get initial coordinates + base vectors.

Depending on the size of dest and on the value of parallel_transport_,
get position (xi_), velocity (xidot_) and possibly other triad vectors
(epi_ and eti_). ";

%feature("docstring")  Gyoto::Photon::Refined::getCoord "

Get coordinates+base vectors corresponding to index.

Depending on the value of parallel_transport_, get position (xi_),
velocity (xidot_) and possibly other triad vectors (epi_ and eti_).
coord is resized to the right number of elements. ";

%feature("docstring")  Gyoto::Photon::Refined::getCoord "

Get coordinates+base vectors corresponding to index.

We need this non-const implementation to allow the const, size_t and
the non-const, double implementations to coexist. ";

%feature("docstring")  Gyoto::Photon::Refined::getCoord "

Get coordinates+base vectors corresponding to date dest[0].

Depending on the value of parallel_transport_, get position (xi_),
velocity (xidot_) and possibly other triad vectors (epi_ and eti_).
coord is resized to the right number of elements. ";

%feature("docstring")  Gyoto::Photon::Refined::getCoord "

Get 8-coordinates for specific dates.

The coordinates will be computed using the integrator, so they will be
as accurate as possible. Some heuristics are used to speed up the
process and it is presumably faster to call this routine with a sorted
list of dates. The line will be integrated further as required. An
error will be thrown if it is not possible to reach a certain date.

Parameters:
-----------

dates:  the list of dates for which the coordinates are to be computed
in proper time or affine parameter if #proper is true or in coordinate
time if #proper is false (default);

n_dates:  the number of dates to compute ;

x1dest:  x2dest:  x3dest:  x0dot:  x1dot:  x2dot:  x3dot:  arrays in
which to store the result. These pointer may be set to NULL to
retrieve only part of the information. They must be pre-allocated.

ephi0:  ephi1:  ephi2:  ephi3:  etheta0:  etheta1:  etheta2:  etheta3:
arrays in which to store the ephi and etheta (parallel transport
case). These pointer may be set to NULL to retrieve only part of the
information. They must be pre-allocated.

otime:  array in which to store the other time: coordinate time if
#proper, else proper time or affine parameter.

proper:  bool: whether #dates is proper time (or affine parameter) or
coordinate time. ";

%feature("docstring")  Gyoto::Photon::Refined::getCoord "

Get all computed positions.

Get all the pre-computed 8 coordinates (e.g. thanks to a prior call to
xFill()) of this worldline. ";

%feature("docstring")  Gyoto::Photon::Refined::getCartesianPos "

Get Cartesian expression of 4-position at index. ";

%feature("docstring")  Gyoto::Photon::Refined::xStore "

Store coord at index ind. ";

%feature("docstring")  Gyoto::Photon::Refined::xStore "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Photon::Refined::xStore "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Photon::Refined::xFill "

Fill x0, x1... by integrating the Worldline from previously set
inittial condition to time tlim. ";

%feature("docstring")  Gyoto::Photon::Refined::get_nelements "

Get number of computed dates. ";

%feature("docstring")  Gyoto::Photon::Refined::get_t "

Get computed dates. ";

%feature("docstring")  Gyoto::Photon::Refined::get_tau "

Get computed proper times or values of the affine parameter. ";

%feature("docstring")  Gyoto::Photon::Refined::getCartesian "

Get the 6 Cartesian coordinates for specific dates.

The 6 coordinates (x, y, z, dx/dt, dy/dt, dz/dt) will be computed
using the integrator and interpolated if necessary, so they will be as
accurate as possible. Transforming to Cartesian coordinates is not
necessarily meaningful.

Parameters:
-----------

dates:  List of dates for which the coordinates are to be computed;

n_dates:  Number of dates to compute ;

x:  y:  z:  xprime:  yprime:  zprime:  Arrays in which to store the
result. These pointer may be set to NULL to retrieve only part of the
information. Else, they must be pre- allocated. ";

%feature("docstring")  Gyoto::Photon::Refined::get_xyz "

Get 3-position in cartesian coordinates for computed dates. ";

%feature("docstring")  Gyoto::Photon::Refined::checkPhiTheta "

Bring in [0,] and in [0,2].

checkPhiTheta() Modifies coord if the corrdinates are spherical-like
so that coord[2]=theta is in [0,pi] and coord[3]=phi is in [0,2pi].
Important to use in all astrobj in spherical coordinates to prevent
\"z-axis problems\". ";

%feature("docstring")  Gyoto::Photon::Refined::getSkyPos "

Get computed positions in sky coordinates. ";

%feature("docstring")  Gyoto::Photon::Refined::get_dot "

Get computed 4-velocities. ";

%feature("docstring")  Gyoto::Photon::Refined::get_prime "

Get computed 3-velocities. ";

%feature("docstring")  Gyoto::Photon::Refined::save_txyz "

Save in a file. ";

%feature("docstring")  Gyoto::Photon::Refined::save_txyz "

Save, converted. ";

%feature("docstring")  Gyoto::Photon::Refined::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Photon::Refined::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Photon::Refined::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Photon::Refined::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Photon::Refined::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Photon::Refined::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Photon::Refined::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Photon::Refined::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Photon::Refined::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Photon::Refined::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Photon::Refined::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Photon::Refined::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Photon::Refined::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Photon::Refined::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Photon::Refined::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Photon::Refined::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Photon::Refined::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Photon::Refined::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Photon::Refined::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Photon::Refined::kind "

Get kind_. ";


// File: class_gyoto_1_1_screen_1_1_repeat_angle.xml
%feature("docstring") RepeatAngle "

1D specifier for an angle that is repeated.

C++ includes: GyotoScreen.h ";

%feature("docstring")  RepeatAngle::RepeatAngle "";

%feature("docstring")  RepeatAngle::begin "

Reset specifier to point to the first value. ";

%feature("docstring")  RepeatAngle::valid "

True if pointing to something, false if end has been reached. ";

%feature("docstring")  RepeatAngle::size "

Number of values in this container. ";

%feature("docstring")  RepeatAngle::angle "

Get double value currently pointed to. ";

%feature("docstring")  RepeatAngle::index "

Get index of value currently pointed to.

Starts at 0 and is implemented each time operator++ is called.
Depending on the implementation, this may be a real index or computed
on demand. ";


// File: class_gyoto_1_1_metric_1_1_rezzolla_zhidenko.xml
%feature("docstring") Gyoto::Metric::RezzollaZhidenko "";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::getProperties
"

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")
Gyoto::Metric::RezzollaZhidenko::RezzollaZhidenko "";

%feature("docstring")
Gyoto::Metric::RezzollaZhidenko::RezzollaZhidenko "";

%feature("docstring")
Gyoto::Metric::RezzollaZhidenko::~RezzollaZhidenko "";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::clone "

Virtual copy constructor. ";

%feature("docstring")
Gyoto::Metric::RezzollaZhidenko::GYOTO_OBJECT_ACCESSORS "";

%feature("docstring")
Gyoto::Metric::RezzollaZhidenko::GYOTO_OBJECT_ACCESSORS "";

%feature("docstring")
Gyoto::Metric::RezzollaZhidenko::GYOTO_OBJECT_ACCESSORS "";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::aparam "";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::aparam "";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::bparam "";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::bparam "";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::gmunu "

Metric coefficients.

The default implementation calls Metric:: gmunu(double g[4][4], const
double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::N2 "";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::B2 "";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::Nprime "";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::Bprime "";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3).

1 on error, 0 otherwise ";

%feature("docstring")
Gyoto::Metric::RezzollaZhidenko::isStopCondition "

Check whether integration should stop.

The integrating loop will ask this the Metric through this method
whether or not it is happy to continue the integration. Typically, the
Metric should answer 0 when everything is fine, 1 when too close to
the event horizon, inside the BH...

Parameters:
-----------

coord:  8-coordinate vector to check. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::getRmb "

Returns the marginally bound radius Should be implemented in derived
classes if useful If called on the base class, returns an error ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::getRms "

Returns the marginally stable (ISCO) radius Should be implemented in
derived classes if useful If called on the base class, returns an
error ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::getPotential "

Returns potential W=-ln(|u_t|) for a cst specific angular momentum
l_cst Should be implemented in derived classes if useful If called on
the base class, returns an error ";

%feature("docstring")
Gyoto::Metric::RezzollaZhidenko::getSpecificAngularMomentum "

Returns the specific angular momentum l=-u_phi/u_t Should be
implemented in derived classes if useful If called on the base class,
returns an error ";

%feature("docstring")
Gyoto::Metric::RezzollaZhidenko::circularVelocity "

Yield circular velocity at a given position.

Give the velocity of a massive particle in circular orbit at the given
position projected onto the equatorial plane. Such a velocity may not
exist everywhere (or anywhere) for a given metric. This method is
intended to be used by Astrobj classes such as Torus or ThinDisk.

If keplerian_ is set to true, this method should return the Keplerian
velcity instead (derived classes should ensure this, see
KerrBL::circularVelocity() for instance).

The default implementation throws an error if keplerian_ is set to
false.

Parameters:
-----------

pos:  input: position,

vel:  output: velocity,

dir:  1 for corotating, -1 for counterrotating. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::gmunu "

Metric coefficients.

The default implementation calls Metric:: gmunu(double g[4][4], const
double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::gmunu "

Metric coefficients.

The default implementation calls double gmunu(const double * x, int
mu, int nu) const.

Parameters:
-----------

ARGOUT_ARRAY2:  (g) 4x4 array to store the coeefficients

IN_ARRAY1:  (x) 4-position at which to compute the coefficients;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3). ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3).

1 on error, 0 otherwise ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::coordKind "

Get coordinate kind. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::getRefCount "";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::mass "

Set mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::mass "

Set mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::mass "

Get mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::mass "

Get mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::unitLength "

M * G / c^2, M is in kg, unitLength in meters.

Metrics implementations are free to express lengths and distances in
whatever unit they see fit (presumably most often geometrical units).
This function returns this unit in SI (meters). ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::unitLength "

unitLength expressed in specified unit ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::deltaMin "

Get delta_min_ ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::deltaMin "

Set delta_min_ ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::deltaMax "

Get delta_max_ ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::deltaMax "

Get delta max at a given position

Parameters:
-----------

pos:  4-position

[optional]:  delta_max_external external constraint on delta_max

the smallest value between delta_max_, delta_max_external, and
R*delta_max_over_r_ where R is pos[1] in spherical coordinates and
max(x1, x2, x3) in Cartesian coordinates. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::deltaMax "

Set delta_max_ ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::deltaMaxOverR
"

Get delta_max_over_r_. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::deltaMaxOverR
"

Set delta_max_over_r_. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::keplerian "

Get keplerian_. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::keplerian "

Set keplerian_. ";

%feature("docstring")
Gyoto::Metric::RezzollaZhidenko::cartesianVelocity "

Compute xprime, yprime and zprime from 8-coordinates. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::SysPrimeToTdot
"

Compute tdot as a function of dr/dt, dtheta/dt and dphi/dt. Everything
is in geometrical units.

Parameters:
-----------

coord:  4-position (geometrical units);

v:  3-velocity dx1/dx0, dx2/dx0, dx3/dx0;

tdot = dx0/dtau. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::zamoVelocity "

Yield ZAMO velocity at a given position.

Give the velocity of a zero angular momentul observer (whatever is
closest to \"at rest\"). The default implementation simply projects
(1, 0, 0, 0) othogonally along ephi and normalizes it, thus ensuring
that vel is orthogonal to ephi.

Parameters:
-----------

pos:  input: position,

vel:  output: velocity, ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::nullifyCoord "

Set tdot (coord[4]) such that coord is light-like. Everything is in
geometrical units.

Set coord[4] so that the 4-velocity coord[4:7] is lightlike, i.e. of
norm 0. There may be up to two solutions. coord[4] is set to the
hightest. The lowest can be retrieved using nullifyCoord(double
coord[8], double& tdot2) const. Everything is expressed in geometrical
units.

Parameters:
-----------

coord:  8-position, coord[4] will be set according to the other
elements; ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::nullifyCoord "

Set tdot (coord[4]) such that coord is light-like and return other
possible tdot.

Set coord[4] so that the 4-velocity coord[4:7] is lightlike, i.e. of
norm 0. There may be up to two solutions. coord[4] is set to the
hightest. The lowest can be retrieved in tdot2. Everything is
expressed in geometrical units.

Parameters:
-----------

coord:  8-position, coord[4] will be set according to the other
elements;

tdot2:  will be set to the smallest solution ";

%feature("docstring")
Gyoto::Metric::RezzollaZhidenko::normalizeFourVel "

Normalize fourvelvel to -1.

First computes threevel as xiprime=xidot/x0dot for i in {1, 2, 3},
then computes x0dot using SyPrimeToTdot, then computes again xidot as
xidot=xiprime*x0dot.

Parameters:
-----------

coord:  8-position, coord[4-7] will be set according to the other
elements; ";

%feature("docstring")
Gyoto::Metric::RezzollaZhidenko::normalizeFourVel "

Normalize fourvelvel to -1.

First computes threevel as xiprime=xidot/x0dot for i in {1, 2, 3},
then computes x0dot using SyPrimeToTdot, then computes again xidot as
xidot=xiprime*x0dot.

Parameters:
-----------

pos:  4-position;

fourvel:  4-velocity, will be renormalized. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::ScalarProd "

Scalar product.

Compute the scalarproduct of the two quadrivectors u1 and u2 in this
Metric, at point pos expressed in coordinate system sys.

Parameters:
-----------

pos:  4-position;

u1:  1st quadrivector;

u2:  2nd quadrivector;

u1*u2 ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::norm "

Scalar product.

Compute the norm of the quadrivector u1 in this Metric, at point pos
expressed in coordinate system sys.

Parameters:
-----------

pos:  4-position;

u1:  quadrivector;

||u1|| ";

%feature("docstring")
Gyoto::Metric::RezzollaZhidenko::multiplyFourVect "

multiply vector by scalar ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::addFourVect "

add second vector to first one ";

%feature("docstring")
Gyoto::Metric::RezzollaZhidenko::projectFourVect "

project u1 orthogonally to u2 at pos ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::dualOneForm "

Computes dual 1-form Compute the dual 1-form of 4-vector.

Parameters:
-----------

IN_ARRAY1_1:  4-position;

IN_ARRAY1_2:  quadrivector;

ARGOUT_ARRAY1:  output 1-form ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::observerTetrad
"

Computes the orthonormal local tetrad of the observer.

Parameters:
-----------

obskind:  input: kind of observer (eg:
\"ZAMO\",\"KeplerianObserver\"...)

pos:  input: position,

fourvel:  output: observer 4-velocity (norm -1)

screen1:  output: first vector in the screen plane

screen2:  output: second vector in the screen plane

screen3:  output: vector normal to the screen ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::observerTetrad
"

Computes the orthonormal local tetrad of the observer.

Parameters:
-----------

pos:  position,

fourvel:  observer 4-velocity (norm -1)

screen1:  first vector in the screen plane

screen2:  second vector in the screen plane

screen3:  vector normal to the screen ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::GramSchmidt "

Apply Gram-Schmidt orthonormalization to a basis.

On input, u0 to u3 must be four non-zero norm, independent 4-vectors.
On output, they will form an orthonormal basis.

Parameters:
-----------

pos:  position,

u0:  basis vector

u1:  basis vector

u2:  basis vector

u3:  basis vector ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::gmunu "

Metric coefficients.

The default implementation calls double gmunu(const double * x, int
mu, int nu) const.

Parameters:
-----------

ARGOUT_ARRAY2:  (g) 4x4 array to store the coeefficients

IN_ARRAY1:  (x) 4-position at which to compute the coefficients;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::gmunu_up "

Metric contravariant coefficients.

The default implementation calls Metric:: gmunu_up(double g[4][4],
const double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::gmunu_up "

Metric contravariant coefficients.

The default implementation inverts the covariant coefficients matrix.
";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::jacobian "

Derivatives of the metric covariant coefficients.

The default implementation evaluates them numerically. The gmunu
matrix is assumed to be symmetrical but no other assumptions are made
at the moment. ";

%feature("docstring")
Gyoto::Metric::RezzollaZhidenko::gmunu_up_and_jacobian "

gmunu_up() and jacobian() in one go ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::computeNBeta "

Computes lapse scalar and shift vector at coord. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3). ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::myrk4 "

RK4 integrator. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::myrk4 "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::myrk4_adaptive
"

RK4 integrator with adaptive step. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::myrk4_adaptive
"

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::diff "

F function such as dx/dt=F(x,cst) ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::diff "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::diff "";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::diff31 "

F function such as dx/dt=F(x,cst) for 3+1 case. ";

%feature("docstring")
Gyoto::Metric::RezzollaZhidenko::setParticleProperties "

Set Metric-specific constants of motion. Used e.g. in KerrBL. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::setParameters
"

Main loop for parsing Properties from XML description.

This function queries the FactoryMessenger for elements to parse, and
tries to matche each element to a Property to set it  accordingly. Any
class that tries to be buildable from XML must supply a subcontractor
(for base classes such as Metric, Astrobj, Spectrum  and Spectrometer,
it is done as a template that must be  specialized for each class).
This subcontractor typically looks somewhat like this: Although this
is discouraged, it is possible to override the following functions to
customize how XML entities are parsed:    - setParameters() if low-
level access to the      FactoryMessenger is required;    -
setParameter(std::string name, std::string content,
std::string unit)      to interpret an entity that does not match a
Property      (e.g. alternative name);    -
setParameter(Gyoto::Property const &p, std::string const &name,
std::string const &content, std::string const &unit)      to change
how a Property is interpreted. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")
Gyoto::Metric::RezzollaZhidenko::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::kind "

Get kind_. ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::hook "

Start listening.

Use from a Hook::Listener object method: where \"this\" is a Listener
and \"teller\" is a Teller.

Use unhook() later to stop listening to a given Teller.

Parameters:
-----------

listener:  pointer to the new listener ";

%feature("docstring")  Gyoto::Metric::RezzollaZhidenko::unhook "

Stop listening.

Use from a Hook::Listener object method:

where \"this\" is a Listener, \"teller\" is a Teller, and \"this\" has
called teller->hook(this) previously.

Parameters:
-----------

listener:  pointer to the listener ";


// File: class_gyoto_1_1_metric_1_1_rot_star3__1.xml
%feature("docstring") Gyoto::Metric::RotStar3_1 "

Numerical metric around a rotating star in 3+1 formalism.

C++ includes: GyotoRotStar3_1.h ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::RotStar3_1 "

Constructor. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::RotStar3_1 "

Copy constructor. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::~RotStar3_1 "

Destructor. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::clone "

Cloner (uses RotStar3_1(file, integ_kind)) ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::fileName "

Set filename_. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::fileName "

Get filename_. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::file "

Set filename_. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::file "

Get filename_. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::integKind "

Set integ_kind_. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::integKind "

Get integ_kind_. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::genericIntegrator "

Set !integ_kind_. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::genericIntegrator "

Get !integ_kind_. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::myrk4 "

RK4 integrator.

NB: we use the 6-coordinates, here, unlike the inherited function. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::myrk4_adaptive "

Adaptive RK4 integrator.

Dispatches between Generic::myrk4_adaptive() and myrk4_adaptive(const
double coor[6], double lastnorm, double normref, double coornew[6],
double cst[2], double& tdot_used, double h0, double& h1, double&
hused) const depending on RotStar3_1::integ_kind_ ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::myrk4_adaptive "

RK4 integrator (3+1)

NB: we use the 6-coordinates, here, unlike the inherited function. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::diff "

F function such as dy/dtau=F(y,cst) ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::diff "

Alternate version of diff(const double coord[8], double res[8]) const.

Using only 6 parameters. Last int is not used: it is only here to
distinguish the signature of the two methods. Could have been done
choosing another name, too, but hey... ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::Normalize4v "

Tweak coordinates to insure conservation of cst. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::gmunu "

Metric coefficients.

The default implementation calls Metric:: gmunu(double g[4][4], const
double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::christoffel "";

%feature("docstring")  Gyoto::Metric::RotStar3_1::ScalarProd "

Scalar product.

Compute the scalarproduct of the two quadrivectors u1 and u2 in this
Metric, at point pos expressed in coordinate system sys.

Parameters:
-----------

pos:  4-position;

u1:  1st quadrivector;

u2:  2nd quadrivector;

u1*u2 ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::gmunu "

Metric coefficients.

The default implementation calls Metric:: gmunu(double g[4][4], const
double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::gmunu "

Metric coefficients.

The default implementation calls double gmunu(const double * x, int
mu, int nu) const.

Parameters:
-----------

ARGOUT_ARRAY2:  (g) 4x4 array to store the coeefficients

IN_ARRAY1:  (x) 4-position at which to compute the coefficients;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3). ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3).

1 on error, 0 otherwise ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::coordKind "

Get coordinate kind. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::getRefCount "";

%feature("docstring")  Gyoto::Metric::RotStar3_1::mass "

Set mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::mass "

Set mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::mass "

Get mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::mass "

Get mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::unitLength "

M * G / c^2, M is in kg, unitLength in meters.

Metrics implementations are free to express lengths and distances in
whatever unit they see fit (presumably most often geometrical units).
This function returns this unit in SI (meters). ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::unitLength "

unitLength expressed in specified unit ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::getRmb "

Returns the marginally bound radius Should be implemented in derived
classes if useful If called on the base class, returns an error ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::getRms "

Returns the marginally stable (ISCO) radius Should be implemented in
derived classes if useful If called on the base class, returns an
error ";

%feature("docstring")
Gyoto::Metric::RotStar3_1::getSpecificAngularMomentum "

Returns the specific angular momentum l=-u_phi/u_t Should be
implemented in derived classes if useful If called on the base class,
returns an error ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::getPotential "

Returns potential W=-ln(|u_t|) for a cst specific angular momentum
l_cst Should be implemented in derived classes if useful If called on
the base class, returns an error ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::deltaMin "

Get delta_min_ ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::deltaMin "

Set delta_min_ ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::deltaMax "

Get delta_max_ ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::deltaMax "

Get delta max at a given position

Parameters:
-----------

pos:  4-position

[optional]:  delta_max_external external constraint on delta_max

the smallest value between delta_max_, delta_max_external, and
R*delta_max_over_r_ where R is pos[1] in spherical coordinates and
max(x1, x2, x3) in Cartesian coordinates. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::deltaMax "

Set delta_max_ ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::deltaMaxOverR "

Get delta_max_over_r_. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::deltaMaxOverR "

Set delta_max_over_r_. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::keplerian "

Get keplerian_. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::keplerian "

Set keplerian_. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::cartesianVelocity "

Compute xprime, yprime and zprime from 8-coordinates. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::SysPrimeToTdot "

Compute tdot as a function of dr/dt, dtheta/dt and dphi/dt. Everything
is in geometrical units.

Parameters:
-----------

coord:  4-position (geometrical units);

v:  3-velocity dx1/dx0, dx2/dx0, dx3/dx0;

tdot = dx0/dtau. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::circularVelocity "

Yield circular velocity at a given position.

Give the velocity of a massive particle in circular orbit at the given
position projected onto the equatorial plane. Such a velocity may not
exist everywhere (or anywhere) for a given metric. This method is
intended to be used by Astrobj classes such as Torus or ThinDisk.

If keplerian_ is set to true, this method should return the Keplerian
velcity instead (derived classes should ensure this, see
KerrBL::circularVelocity() for instance).

The default implementation throws an error if keplerian_ is set to
false.

Parameters:
-----------

pos:  input: position,

vel:  output: velocity,

dir:  1 for corotating, -1 for counterrotating. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::zamoVelocity "

Yield ZAMO velocity at a given position.

Give the velocity of a zero angular momentul observer (whatever is
closest to \"at rest\"). The default implementation simply projects
(1, 0, 0, 0) othogonally along ephi and normalizes it, thus ensuring
that vel is orthogonal to ephi.

Parameters:
-----------

pos:  input: position,

vel:  output: velocity, ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::nullifyCoord "

Set tdot (coord[4]) such that coord is light-like. Everything is in
geometrical units.

Set coord[4] so that the 4-velocity coord[4:7] is lightlike, i.e. of
norm 0. There may be up to two solutions. coord[4] is set to the
hightest. The lowest can be retrieved using nullifyCoord(double
coord[8], double& tdot2) const. Everything is expressed in geometrical
units.

Parameters:
-----------

coord:  8-position, coord[4] will be set according to the other
elements; ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::nullifyCoord "

Set tdot (coord[4]) such that coord is light-like and return other
possible tdot.

Set coord[4] so that the 4-velocity coord[4:7] is lightlike, i.e. of
norm 0. There may be up to two solutions. coord[4] is set to the
hightest. The lowest can be retrieved in tdot2. Everything is
expressed in geometrical units.

Parameters:
-----------

coord:  8-position, coord[4] will be set according to the other
elements;

tdot2:  will be set to the smallest solution ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::normalizeFourVel "

Normalize fourvelvel to -1.

First computes threevel as xiprime=xidot/x0dot for i in {1, 2, 3},
then computes x0dot using SyPrimeToTdot, then computes again xidot as
xidot=xiprime*x0dot.

Parameters:
-----------

coord:  8-position, coord[4-7] will be set according to the other
elements; ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::normalizeFourVel "

Normalize fourvelvel to -1.

First computes threevel as xiprime=xidot/x0dot for i in {1, 2, 3},
then computes x0dot using SyPrimeToTdot, then computes again xidot as
xidot=xiprime*x0dot.

Parameters:
-----------

pos:  4-position;

fourvel:  4-velocity, will be renormalized. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::norm "

Scalar product.

Compute the norm of the quadrivector u1 in this Metric, at point pos
expressed in coordinate system sys.

Parameters:
-----------

pos:  4-position;

u1:  quadrivector;

||u1|| ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::multiplyFourVect "

multiply vector by scalar ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::addFourVect "

add second vector to first one ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::projectFourVect "

project u1 orthogonally to u2 at pos ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::dualOneForm "

Computes dual 1-form Compute the dual 1-form of 4-vector.

Parameters:
-----------

IN_ARRAY1_1:  4-position;

IN_ARRAY1_2:  quadrivector;

ARGOUT_ARRAY1:  output 1-form ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::observerTetrad "

Computes the orthonormal local tetrad of the observer.

Parameters:
-----------

obskind:  input: kind of observer (eg:
\"ZAMO\",\"KeplerianObserver\"...)

pos:  input: position,

fourvel:  output: observer 4-velocity (norm -1)

screen1:  output: first vector in the screen plane

screen2:  output: second vector in the screen plane

screen3:  output: vector normal to the screen ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::observerTetrad "

Computes the orthonormal local tetrad of the observer.

Parameters:
-----------

pos:  position,

fourvel:  observer 4-velocity (norm -1)

screen1:  first vector in the screen plane

screen2:  second vector in the screen plane

screen3:  vector normal to the screen ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::GramSchmidt "

Apply Gram-Schmidt orthonormalization to a basis.

On input, u0 to u3 must be four non-zero norm, independent 4-vectors.
On output, they will form an orthonormal basis.

Parameters:
-----------

pos:  position,

u0:  basis vector

u1:  basis vector

u2:  basis vector

u3:  basis vector ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::gmunu "

Metric coefficients.

The default implementation calls double gmunu(const double * x, int
mu, int nu) const.

Parameters:
-----------

ARGOUT_ARRAY2:  (g) 4x4 array to store the coeefficients

IN_ARRAY1:  (x) 4-position at which to compute the coefficients;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::gmunu_up "

Metric contravariant coefficients.

The default implementation calls Metric:: gmunu_up(double g[4][4],
const double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::gmunu_up "

Metric contravariant coefficients.

The default implementation inverts the covariant coefficients matrix.
";

%feature("docstring")  Gyoto::Metric::RotStar3_1::jacobian "

Derivatives of the metric covariant coefficients.

The default implementation evaluates them numerically. The gmunu
matrix is assumed to be symmetrical but no other assumptions are made
at the moment. ";

%feature("docstring")
Gyoto::Metric::RotStar3_1::gmunu_up_and_jacobian "

gmunu_up() and jacobian() in one go ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::computeNBeta "

Computes lapse scalar and shift vector at coord. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3). ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3).

1 on error, 0 otherwise ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::myrk4 "

RK4 integrator. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::myrk4 "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::myrk4_adaptive "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::isStopCondition "

Check whether integration should stop.

The integrating loop will ask this the Metric through this method
whether or not it is happy to continue the integration. Typically, the
Metric should answer 0 when everything is fine, 1 when too close to
the event horizon, inside the BH...

Parameters:
-----------

coord:  8-coordinate vector to check. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::diff "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::diff "";

%feature("docstring")  Gyoto::Metric::RotStar3_1::diff31 "

F function such as dx/dt=F(x,cst) for 3+1 case. ";

%feature("docstring")
Gyoto::Metric::RotStar3_1::setParticleProperties "

Set Metric-specific constants of motion. Used e.g. in KerrBL. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Metric::RotStar3_1::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::setParameters "

Main loop for parsing Properties from XML description.

This function queries the FactoryMessenger for elements to parse, and
tries to matche each element to a Property to set it  accordingly. Any
class that tries to be buildable from XML must supply a subcontractor
(for base classes such as Metric, Astrobj, Spectrum  and Spectrometer,
it is done as a template that must be  specialized for each class).
This subcontractor typically looks somewhat like this: Although this
is discouraged, it is possible to override the following functions to
customize how XML entities are parsed:    - setParameters() if low-
level access to the      FactoryMessenger is required;    -
setParameter(std::string name, std::string content,
std::string unit)      to interpret an entity that does not match a
Property      (e.g. alternative name);    -
setParameter(Gyoto::Property const &p, std::string const &name,
std::string const &content, std::string const &unit)      to change
how a Property is interpreted. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::kind "

Get kind_. ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::hook "

Start listening.

Use from a Hook::Listener object method: where \"this\" is a Listener
and \"teller\" is a Teller.

Use unhook() later to stop listening to a given Teller.

Parameters:
-----------

listener:  pointer to the new listener ";

%feature("docstring")  Gyoto::Metric::RotStar3_1::unhook "

Stop listening.

Use from a Hook::Listener object method:

where \"this\" is a Listener, \"teller\" is a Teller, and \"this\" has
called teller->hook(this) previously.

Parameters:
-----------

listener:  pointer to the listener ";


// File: class_gyoto_1_1_scenery.xml
%feature("docstring") Gyoto::Scenery "

Ray-tracing scene.

An Scenery contains: a Metric: used in Astrobj, Screen and Photon;

a Screen: sets the field-of-view, the position of the camera, the
observation time, and the Spectrometer;

an Astrobj: light emitter.

In addition, Quantities may be specified (or the default Quantity will
be produced: generally Intensity). Not all Astrobj implement all
Quantities. The order in which Quantities are listed is not relevant
(it is not stored). Possible Quantities:

Intensity: the intensity that reaches the object, integrated over the
line-of-sight;

EmissionTime: date of emission;

MinDistance: minimum distance between the Photon reaching each pixel
and the Astrobj;

FirstDistMin: last closest approach between Photon and Astrobj;

Redshift;

ImpactCoords: 8-coordinates of the object and photon at impact;

Spectrum: I computed at various values frequencies, corresponding to
the Screen's Spectrometer.

BinSpectrum:12Id computed between various (1,2 pairs corresponding to
the Screen's Spectrometer. This is what a physical spectrometer
measures.

In addition, it is possible to ray-trace an image using several cores
on a single machine (if Gyoto has been compiled with POSIX threads
support). The number of threads can be specified using NThreads
entity. Setting NThreads to 0 is equivalent to setting it to 1. Beware
that setting NThreads to a number higher than the actual number of
cores available on the machine usually leads to a decrease in
performance.

Finally, Scenery accepts a number of numerical tuning parameters that
are passed directly to the underlying photons (actually, the Scenery
object holds a Photon instance which stores many parameters, including
the Metric and Astrobj): Adaptive/NonAdaptive, Delta, MinimumTime,
MaxIter, PrimaryOnly.

Thus a fully populated Scenery XML looks like that (the values are
examples, they are not necessary the default nor the best or even good
values):

C++ includes: GyotoScenery.h ";

%feature("docstring")  Gyoto::Scenery::mpiSpawn "

Spawn gyoto-mpi-worker processes.

If nbchildren is -1 set #mpi_team_ to MPI_COMM_WORLD else spawn
nbchildren processes and set nprocesses_ accordingly. If a different
number of workers are already running, terminate them first. If
nbchildren is 0, just terminate running workers.

The approach of Gyoto to MPI is that a manager process (of rank 0
within a given MPI communicator) will distribute ray-tracing tasks
across worker processes. Several scenarii are supported, including
spawning instances of the gyoto-mpi-worker.version executable, where
\"version\" matches the version component in the library name
(typically a number, possibly followed by \"unreleased\").

In all cases, the manager process needs to call this function, either
with -1 if the worker processes are already running or >1 if workers
need to be spawned.

Parameters:
-----------

nbchildren:  number of processes to spawn. ";

%feature("docstring")  Gyoto::Scenery::mpiTerminate "

Terminate worker processes. ";

%feature("docstring")  Gyoto::Scenery::mpiClone "

Send a copy of self to the mpi workers.

Always call mpiClone() before ray-tracing if workers are running. ";

%feature("docstring")  Gyoto::Scenery::mpiTask "

Send a tag to workers. ";

%feature("docstring")  Gyoto::Scenery::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Scenery::Scenery "

Set everything to defaults. ";

%feature("docstring")  Gyoto::Scenery::Scenery "

Copy constructor. ";

%feature("docstring")  Gyoto::Scenery::clone "

Cloner. ";

%feature("docstring")  Gyoto::Scenery::Scenery "

Constructor setting Scenery::gg_, Scenery::screen_, and Scenery::obj_.

To ensure consistency, the Metric will be forcibly attached to the
Screen and to the Astrobj (if they are not NULL). ";

%feature("docstring")  Gyoto::Scenery::~Scenery "";

%feature("docstring")  Gyoto::Scenery::metric "

Get ph_.Worldline::metric_. ";

%feature("docstring")  Gyoto::Scenery::metric "

Set Scenery::gg_.

The provided Metric will also be atached to the Screen and the
Astrobj. ";

%feature("docstring")  Gyoto::Scenery::screen "

Get Scenery::screen_. ";

%feature("docstring")  Gyoto::Scenery::screen "

Set Scenery::screen_.

The Metric attached to the Scenery will be attached to the Screen ";

%feature("docstring")  Gyoto::Scenery::astrobj "

Get ph_.obj_. ";

%feature("docstring")  Gyoto::Scenery::astrobj "

Set ph_.obj_.

The Metric attached to the Scenery will be attached to the Astrobj ";

%feature("docstring")  Gyoto::Scenery::clonePhoton "

Get clone of template Photon.

Clone the internal Photon ";

%feature("docstring")  Gyoto::Scenery::clonePhoton "

Get clone of template Photon, intitializing it to pixel. ";

%feature("docstring")  Gyoto::Scenery::clonePhoton "

Get clone of template Photon, intitializing it to direction. ";

%feature("docstring")  Gyoto::Scenery::updatePhoton "

Update values in cached Photon. ";

%feature("docstring")  Gyoto::Scenery::delta "

Get default step in geometrical units. ";

%feature("docstring")  Gyoto::Scenery::delta "

Get default step in specified units. ";

%feature("docstring")  Gyoto::Scenery::delta "

set default step in geometrical units ";

%feature("docstring")  Gyoto::Scenery::delta "

set default step in specified units ";

%feature("docstring")  Gyoto::Scenery::initCoord "";

%feature("docstring")  Gyoto::Scenery::initCoord "";

%feature("docstring")  Gyoto::Scenery::setRequestedQuantities "

Set Scenery::quantities_.

Parameters:
-----------

quant:  Bitwise OR of desired quantities, e.g. ";

%feature("docstring")  Gyoto::Scenery::requestedQuantitiesString "

Set Scenery::quantities_ from string.

Parameters:
-----------

squant:  Coma-separated list of quantities, e.g. \"Spectrum
MinDistance\". The order is not relevant. ";

%feature("docstring")  Gyoto::Scenery::getRequestedQuantities "

Get Scenery::quantities_. ";

%feature("docstring")  Gyoto::Scenery::requestedQuantitiesString "

Get a string representation of Scenery::quantities_. ";

%feature("docstring")  Gyoto::Scenery::getScalarQuantitiesCount "

Get number of requested quantities of scalar nature.

This is all quantities except Spectrum, BinSpectrum and ImpactCoords.
";

%feature("docstring")  Gyoto::Scenery::getSpectralQuantitiesCount "

Get number of requested quantities of spectral nature.

This is Spectrum, SpectrumStokesQ, SpectrumStokesU, SpectrumStokesV
and BinSpectrum. ";

%feature("docstring")  Gyoto::Scenery::tMin "

Get ph_.tmin_. ";

%feature("docstring")  Gyoto::Scenery::tMin "

Get ph_.tmin_ in specified unit. ";

%feature("docstring")  Gyoto::Scenery::tMin "

Set ph_.tmin_. ";

%feature("docstring")  Gyoto::Scenery::tMin "

Set ph_.tmin_ in specified unit. ";

%feature("docstring")  Gyoto::Scenery::adaptive "

Set ph_.adaptive_. ";

%feature("docstring")  Gyoto::Scenery::adaptive "

Get ph_.adaptive_. ";

%feature("docstring")  Gyoto::Scenery::integrator "

Passed to ph_. ";

%feature("docstring")  Gyoto::Scenery::integrator "

Passed to ph_. ";

%feature("docstring")  Gyoto::Scenery::deltaMin "

Passed to ph_. ";

%feature("docstring")  Gyoto::Scenery::deltaMin "

Passed to ph_. ";

%feature("docstring")  Gyoto::Scenery::deltaMax "

Passed to ph_. ";

%feature("docstring")  Gyoto::Scenery::deltaMax "

Passed to ph_. ";

%feature("docstring")  Gyoto::Scenery::deltaMaxOverR "

Passed to ph_. ";

%feature("docstring")  Gyoto::Scenery::deltaMaxOverR "

Passed to ph_. ";

%feature("docstring")  Gyoto::Scenery::absTol "

Passed to ph_. ";

%feature("docstring")  Gyoto::Scenery::absTol "

Passed to ph_. ";

%feature("docstring")  Gyoto::Scenery::relTol "

Passed to ph_. ";

%feature("docstring")  Gyoto::Scenery::relTol "

Passed to ph_. ";

%feature("docstring")  Gyoto::Scenery::maxCrossEqplane "

Passed to ph_. ";

%feature("docstring")  Gyoto::Scenery::maxCrossEqplane "

Passed to ph_. ";

%feature("docstring")  Gyoto::Scenery::secondary "

Set ph_.secondary_. ";

%feature("docstring")  Gyoto::Scenery::secondary "

Get ph_.secondary_. ";

%feature("docstring")  Gyoto::Scenery::integ31 "

Set WorldlinIntegState integ_31_. ";

%feature("docstring")  Gyoto::Scenery::integ31 "

Get WorldlinIntegState integ_31_. ";

%feature("docstring")  Gyoto::Scenery::parallelTransport "

Set ph_.parallel_transport_. ";

%feature("docstring")  Gyoto::Scenery::parallelTransport "

Get ph_.parallel_transport_. ";

%feature("docstring")  Gyoto::Scenery::maxiter "

Set ph_.maxiter_. ";

%feature("docstring")  Gyoto::Scenery::maxiter "

Get ph_.maxiter_. ";

%feature("docstring")  Gyoto::Scenery::nThreads "

Set nthreads_;. ";

%feature("docstring")  Gyoto::Scenery::nThreads "

Get nthreads_;. ";

%feature("docstring")  Gyoto::Scenery::nProcesses "

Set nprocesses_;. ";

%feature("docstring")  Gyoto::Scenery::nProcesses "

Get nprocesses_;. ";

%feature("docstring")  Gyoto::Scenery::intensityConverter "

Set Scenery::intensity_converter_. ";

%feature("docstring")  Gyoto::Scenery::spectrumConverter "

Set Scenery::spectrum_converter_. ";

%feature("docstring")  Gyoto::Scenery::binSpectrumConverter "

Set Scenery::binspectrum_converter_. ";

%feature("docstring")  Gyoto::Scenery::setPropertyConverters "

Copy converters to Astrobj::Properties instance.

Copy Scenery::intensity_converter_, Scenery::spectrum_converter_ and
Scenery::binspectrum_converter_ to there alter ego in *prop. ";

%feature("docstring")  Gyoto::Scenery::rayTrace "

Perform ray-tracing.

For each directions specified, launch a Photon back in time to compute
the various quantities.

At this time, the computed quantities depend on on the pointers in
*data which are not NULL.

rayTrace() uses  setPropertyConverters() to set the converters in
*data;

Astrobj::Properties::init() to initialize each cell in *data;

Astrobj::Properties::operator++() to step through the arrays in *data.

data must have been instantiated prior to calling rayTrace and the
various pointers in *data must be NULL or point to the first cell in
an array of size at least Screen::npix_ squared.

If MPI support is built-in, MPI_Init() has been called, and
nprocesses_ is1, then rayTrace() will use several processes, launching
them using mpiSpawn() if necessary.

Else, if Scenery::nthreads_ is2 and Gyoto has been compiled with
pthreads support, rayTrace() will use Scenery::nthreads_ threads and
launch photons in parallel. This works only if the
Astrobj::Generic::clone() and Metric::Generic::clone() methods have
been properly implemented for the specific astrobj and metric kind,
and if they are both thread-safe. At the moment, unfortunately, Lorene
metrics are known to not be thread-safe.

Parameters:
-----------

ij:   Screen::Coord2dSet specification of rays to trace. e.g.:

Parameters:
-----------

data:  Pointer to a preallocated Astrobj::Properties instance which
sets which quantities must be computed and where to store the output.

impactcoords:  Optional pointer to an array of pre-computed impact
coordinates. If impactcoords is provided, rayTracing is skipped and
the quantities in *data are fill assuming that the impact coordinates
are correct. This only makes sense in optically thick mode, when ray-
tracing several sceneries for which the shape of the object is
identical but their emission distributions are not. impactcoords can
be computed using the ImpactCoords quantity. ";

%feature("docstring")  Gyoto::Scenery::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Scenery::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Scenery::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Scenery::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Scenery::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Scenery::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Scenery::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Scenery::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Scenery::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Scenery::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Scenery::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Scenery::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Scenery::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Scenery::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Scenery::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Scenery::setParameters "

Main loop for parsing Properties from XML description.

This function queries the FactoryMessenger for elements to parse, and
tries to matche each element to a Property to set it  accordingly. Any
class that tries to be buildable from XML must supply a subcontractor
(for base classes such as Metric, Astrobj, Spectrum  and Spectrometer,
it is done as a template that must be  specialized for each class).
This subcontractor typically looks somewhat like this: Although this
is discouraged, it is possible to override the following functions to
customize how XML entities are parsed:    - setParameters() if low-
level access to the      FactoryMessenger is required;    -
setParameter(std::string name, std::string content,
std::string unit)      to interpret an entity that does not match a
Property      (e.g. alternative name);    -
setParameter(Gyoto::Property const &p, std::string const &name,
std::string const &content, std::string const &unit)      to change
how a Property is interpreted. ";

%feature("docstring")  Gyoto::Scenery::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Scenery::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Scenery::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Scenery::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Scenery::kind "

Get kind_. ";


// File: class_gyoto_1_1_metric_1_1_schwarzschild_harmonic.xml
%feature("docstring") Gyoto::Metric::SchwarzschildHarmonic "";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::SchwarzschildHarmonic "";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::SchwarzschildHarmonic "";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::~SchwarzschildHarmonic "";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::clone "

Virtual copy constructor. ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::gmunu "

Metric coefficients.

The default implementation calls Metric:: gmunu(double g[4][4], const
double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3).

1 on error, 0 otherwise ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::isStopCondition "

Check whether integration should stop.

The integrating loop will ask this the Metric through this method
whether or not it is happy to continue the integration. Typically, the
Metric should answer 0 when everything is fine, 1 when too close to
the event horizon, inside the BH...

Parameters:
-----------

coord:  8-coordinate vector to check. ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::circularVelocity "";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::gmunu "

Metric coefficients.

The default implementation calls Metric:: gmunu(double g[4][4], const
double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::gmunu "

Metric coefficients.

The default implementation calls double gmunu(const double * x, int
mu, int nu) const.

Parameters:
-----------

ARGOUT_ARRAY2:  (g) 4x4 array to store the coeefficients

IN_ARRAY1:  (x) 4-position at which to compute the coefficients;

Metric coefficient g, at point x ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3). ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3).

1 on error, 0 otherwise ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::coordKind
"

Get coordinate kind. ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::getRefCount "";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::mass "

Set mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::mass "

Set mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::mass "

Get mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::mass "

Get mass used in unitLength() ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::unitLength "

M * G / c^2, M is in kg, unitLength in meters.

Metrics implementations are free to express lengths and distances in
whatever unit they see fit (presumably most often geometrical units).
This function returns this unit in SI (meters). ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::unitLength "

unitLength expressed in specified unit ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::getRmb "

Returns the marginally bound radius Should be implemented in derived
classes if useful If called on the base class, returns an error ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::getRms "

Returns the marginally stable (ISCO) radius Should be implemented in
derived classes if useful If called on the base class, returns an
error ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::getSpecificAngularMomentum "

Returns the specific angular momentum l=-u_phi/u_t Should be
implemented in derived classes if useful If called on the base class,
returns an error ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::getPotential "

Returns potential W=-ln(|u_t|) for a cst specific angular momentum
l_cst Should be implemented in derived classes if useful If called on
the base class, returns an error ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::deltaMin
"

Get delta_min_ ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::deltaMin
"

Set delta_min_ ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::deltaMax
"

Get delta_max_ ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::deltaMax
"

Get delta max at a given position

Parameters:
-----------

pos:  4-position

[optional]:  delta_max_external external constraint on delta_max

the smallest value between delta_max_, delta_max_external, and
R*delta_max_over_r_ where R is pos[1] in spherical coordinates and
max(x1, x2, x3) in Cartesian coordinates. ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::deltaMax
"

Set delta_max_ ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::deltaMaxOverR "

Get delta_max_over_r_. ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::deltaMaxOverR "

Set delta_max_over_r_. ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::keplerian
"

Get keplerian_. ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::keplerian
"

Set keplerian_. ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::cartesianVelocity "

Compute xprime, yprime and zprime from 8-coordinates. ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::SysPrimeToTdot "

Compute tdot as a function of dr/dt, dtheta/dt and dphi/dt. Everything
is in geometrical units.

Parameters:
-----------

coord:  4-position (geometrical units);

v:  3-velocity dx1/dx0, dx2/dx0, dx3/dx0;

tdot = dx0/dtau. ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::circularVelocity "

Yield circular velocity at a given position.

Give the velocity of a massive particle in circular orbit at the given
position projected onto the equatorial plane. Such a velocity may not
exist everywhere (or anywhere) for a given metric. This method is
intended to be used by Astrobj classes such as Torus or ThinDisk.

If keplerian_ is set to true, this method should return the Keplerian
velcity instead (derived classes should ensure this, see
KerrBL::circularVelocity() for instance).

The default implementation throws an error if keplerian_ is set to
false.

Parameters:
-----------

pos:  input: position,

vel:  output: velocity,

dir:  1 for corotating, -1 for counterrotating. ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::zamoVelocity "

Yield ZAMO velocity at a given position.

Give the velocity of a zero angular momentul observer (whatever is
closest to \"at rest\"). The default implementation simply projects
(1, 0, 0, 0) othogonally along ephi and normalizes it, thus ensuring
that vel is orthogonal to ephi.

Parameters:
-----------

pos:  input: position,

vel:  output: velocity, ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::nullifyCoord "

Set tdot (coord[4]) such that coord is light-like. Everything is in
geometrical units.

Set coord[4] so that the 4-velocity coord[4:7] is lightlike, i.e. of
norm 0. There may be up to two solutions. coord[4] is set to the
hightest. The lowest can be retrieved using nullifyCoord(double
coord[8], double& tdot2) const. Everything is expressed in geometrical
units.

Parameters:
-----------

coord:  8-position, coord[4] will be set according to the other
elements; ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::nullifyCoord "

Set tdot (coord[4]) such that coord is light-like and return other
possible tdot.

Set coord[4] so that the 4-velocity coord[4:7] is lightlike, i.e. of
norm 0. There may be up to two solutions. coord[4] is set to the
hightest. The lowest can be retrieved in tdot2. Everything is
expressed in geometrical units.

Parameters:
-----------

coord:  8-position, coord[4] will be set according to the other
elements;

tdot2:  will be set to the smallest solution ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::normalizeFourVel "

Normalize fourvelvel to -1.

First computes threevel as xiprime=xidot/x0dot for i in {1, 2, 3},
then computes x0dot using SyPrimeToTdot, then computes again xidot as
xidot=xiprime*x0dot.

Parameters:
-----------

coord:  8-position, coord[4-7] will be set according to the other
elements; ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::normalizeFourVel "

Normalize fourvelvel to -1.

First computes threevel as xiprime=xidot/x0dot for i in {1, 2, 3},
then computes x0dot using SyPrimeToTdot, then computes again xidot as
xidot=xiprime*x0dot.

Parameters:
-----------

pos:  4-position;

fourvel:  4-velocity, will be renormalized. ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::ScalarProd "

Scalar product.

Compute the scalarproduct of the two quadrivectors u1 and u2 in this
Metric, at point pos expressed in coordinate system sys.

Parameters:
-----------

pos:  4-position;

u1:  1st quadrivector;

u2:  2nd quadrivector;

u1*u2 ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::norm "

Scalar product.

Compute the norm of the quadrivector u1 in this Metric, at point pos
expressed in coordinate system sys.

Parameters:
-----------

pos:  4-position;

u1:  quadrivector;

||u1|| ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::multiplyFourVect "

multiply vector by scalar ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::addFourVect "

add second vector to first one ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::projectFourVect "

project u1 orthogonally to u2 at pos ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::dualOneForm "

Computes dual 1-form Compute the dual 1-form of 4-vector.

Parameters:
-----------

IN_ARRAY1_1:  4-position;

IN_ARRAY1_2:  quadrivector;

ARGOUT_ARRAY1:  output 1-form ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::observerTetrad "

Computes the orthonormal local tetrad of the observer.

Parameters:
-----------

obskind:  input: kind of observer (eg:
\"ZAMO\",\"KeplerianObserver\"...)

pos:  input: position,

fourvel:  output: observer 4-velocity (norm -1)

screen1:  output: first vector in the screen plane

screen2:  output: second vector in the screen plane

screen3:  output: vector normal to the screen ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::observerTetrad "

Computes the orthonormal local tetrad of the observer.

Parameters:
-----------

pos:  position,

fourvel:  observer 4-velocity (norm -1)

screen1:  first vector in the screen plane

screen2:  second vector in the screen plane

screen3:  vector normal to the screen ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::GramSchmidt "

Apply Gram-Schmidt orthonormalization to a basis.

On input, u0 to u3 must be four non-zero norm, independent 4-vectors.
On output, they will form an orthonormal basis.

Parameters:
-----------

pos:  position,

u0:  basis vector

u1:  basis vector

u2:  basis vector

u3:  basis vector ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::gmunu "

Metric coefficients.

The default implementation calls double gmunu(const double * x, int
mu, int nu) const.

Parameters:
-----------

ARGOUT_ARRAY2:  (g) 4x4 array to store the coeefficients

IN_ARRAY1:  (x) 4-position at which to compute the coefficients;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::gmunu_up
"

Metric contravariant coefficients.

The default implementation calls Metric:: gmunu_up(double g[4][4],
const double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::gmunu_up
"

Metric contravariant coefficients.

The default implementation inverts the covariant coefficients matrix.
";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::jacobian
"

Derivatives of the metric covariant coefficients.

The default implementation evaluates them numerically. The gmunu
matrix is assumed to be symmetrical but no other assumptions are made
at the moment. ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::gmunu_up_and_jacobian "

gmunu_up() and jacobian() in one go ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::computeNBeta "

Computes lapse scalar and shift vector at coord. ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3). ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::myrk4 "

RK4 integrator. ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::myrk4 "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::myrk4_adaptive "

RK4 integrator with adaptive step. ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::myrk4_adaptive "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::diff "

F function such as dx/dt=F(x,cst) ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::diff "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::diff "";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::diff31 "

F function such as dx/dt=F(x,cst) for 3+1 case. ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::setParticleProperties "

Set Metric-specific constants of motion. Used e.g. in KerrBL. ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::property
"

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::setParameters "

Main loop for parsing Properties from XML description.

This function queries the FactoryMessenger for elements to parse, and
tries to matche each element to a Property to set it  accordingly. Any
class that tries to be buildable from XML must supply a subcontractor
(for base classes such as Metric, Astrobj, Spectrum  and Spectrometer,
it is done as a template that must be  specialized for each class).
This subcontractor typically looks somewhat like this: Although this
is discouraged, it is possible to override the following functions to
customize how XML entities are parsed:    - setParameters() if low-
level access to the      FactoryMessenger is required;    -
setParameter(std::string name, std::string content,
std::string unit)      to interpret an entity that does not match a
Property      (e.g. alternative name);    -
setParameter(Gyoto::Property const &p, std::string const &name,
std::string const &content, std::string const &unit)      to change
how a Property is interpreted. ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")
Gyoto::Metric::SchwarzschildHarmonic::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::kind "

Get kind_. ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::hook "

Start listening.

Use from a Hook::Listener object method: where \"this\" is a Listener
and \"teller\" is a Teller.

Use unhook() later to stop listening to a given Teller.

Parameters:
-----------

listener:  pointer to the new listener ";

%feature("docstring")  Gyoto::Metric::SchwarzschildHarmonic::unhook "

Stop listening.

Use from a Hook::Listener object method:

where \"this\" is a Listener, \"teller\" is a Teller, and \"this\" has
called teller->hook(this) previously.

Parameters:
-----------

listener:  pointer to the listener ";


// File: class_gyoto_1_1_screen.xml
%feature("docstring") Gyoto::Screen "

The camera with which the Astrobj is observed.

In the observer-centric point-of-view, the center of the Metric's
coordinate system is positioned relatively to the observing Screen
using three Euler angles and the distance (in meters). The three Euler
angles are: position angle of the line of nodes (North of East);

inclination (0 = face-on);

argument of the X axis of the Metric's coordinate system. We use the
z-x-z convention. Seehttp://en.wikipedia.org/wiki/Euler_angles

In addition, the Screen conveys: the observing date (in geometrical
units, but expect it to change to seconds in a future version);

the field-of-view of the image;

the resolution of the camera: number of pixels on each side (the
camera is square);

the observing frequency.

The scalar FreqObs defines the observing frequency for Scenery
quantity Intensity.

Likewise, a Gyoto::Spectrometer defines for which frequencies spectra
are computed (when the Quantity Spectrum is requested in the Scenery).

For the sake of theoreticians, there is an alternate way of specifying
the relative position of the Screen and Metric, by specifying the
4-coordinates of the Screen in the Metric's coordinate system (in that
case, eerything is specified in geometrical units).

So an XML stanza for a Screen may look like that:

or like that:

Units can be specified using the unit attribute in the XML file, for
instance:

Possible units are (with [] noting the default): distance: [m],
geometrical, cm, km, AU, ly, pc, kpc, Mpc;

PALN, inclination, argument: [rad], deg.

frequency: [Hz], µm, GeV...

When the distance is really large and most of the ray-tracing would
happen de facto in flat space, the camera is transported to a location
at a reasonable distance from the metric and the images are scaled
accordingly. The default value for this distance should be fine, but
it can be customized using the \"dmax\" attribute of the \"Distance\"
element. \"dmax\" is always expressed in geometrical units:

Symptoms when dmax is too large include pixelization of the image
(neighbouring photons are numerically identical) and other numerical
overflows. dmax is too small when it is apparent that changing it
yields projection effects. dmax must be large compared to rmax in the
Astrobj and ideally, changing it by an order of magnitude should not
yield significant changes in the ray-traced image.

A mask may be used to limit ray-tracing to only some portions of the
field. The Scenery checks whether a mask is to be used using
Screen::operator()(size_t i, size_t j). The mask can be loaded from a
FITS file as a square image of doubles: The mask needs to be have the
same size as the Screen itself, so loading a mask also sets the
resolution, and changing the resolution after setting a mask also
removes the mask. The content of the Mask entity is parsed by
Factory::fullPath(), so it can be an absolute path, a path relative to
where the XML file is stored, or relative to the current working
directory if prefixed with \"`pwd`/\".

C++ includes: GyotoScreen.h ";

%feature("docstring")  Gyoto::Screen::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Screen::Screen "

Default constructor. ";

%feature("docstring")  Gyoto::Screen::Screen "

Copy constructor. ";

%feature("docstring")  Gyoto::Screen::clone "

Cloner. ";

%feature("docstring")  Gyoto::Screen::~Screen "

Destructor. ";

%feature("docstring")  Gyoto::Screen::setProjection "

Set inclination etc. ";

%feature("docstring")  Gyoto::Screen::setProjection "

Set distance, inclination etc. ";

%feature("docstring")  Gyoto::Screen::distance "

Set distance from observer.

Parameters:
-----------

dist:  Distance in meters. ";

%feature("docstring")  Gyoto::Screen::dMax "

Set ray-tracing maximum distance.

Parameters:
-----------

dist:  Distance in geometrical units. ";

%feature("docstring")  Gyoto::Screen::distance "

Set distance from observer.

Parameters:
-----------

dist:  the distance expressed in the specified unit;

unit:  convertible to meters ";

%feature("docstring")  Gyoto::Screen::inclination "

Set inclination relative to line-of-sight.

Inclination of z-axis relative to line-of-sight, or inclination of
equatorial plane relative to plane of the sky, in radians ";

%feature("docstring")  Gyoto::Screen::inclination "

Set inclination relative to line-of-sight.

Inclination of z-axis relative to line-of-sight, or inclination of
equatorial plane relative to plane of the sky, in specified unit. ";

%feature("docstring")  Gyoto::Screen::PALN "

Set position angle of the line of nodes. ";

%feature("docstring")  Gyoto::Screen::PALN "

Set position angle of the line of nodes. ";

%feature("docstring")  Gyoto::Screen::argument "

Set angle beetwen line of nodes and X axis of object. ";

%feature("docstring")  Gyoto::Screen::argument "

Set angle beetwen line of nodes and X axis of object. ";

%feature("docstring")  Gyoto::Screen::spectrometer "

Set Screen::spectro_. ";

%feature("docstring")  Gyoto::Screen::spectrometer "

Get Screen::spectro_. ";

%feature("docstring")  Gyoto::Screen::freqObs "

Set freq_obs_.

Parameters:
-----------

fo:  double: observing frequency in Hz ";

%feature("docstring")  Gyoto::Screen::freqObs "

Set freq_obs_.

Parameters:
-----------

fo:  double: observing frequency (or wavelength) in \"unit\"

unit:  string: unit in which fo is expressed, convertible to Herz or
meters or energy. ";

%feature("docstring")  Gyoto::Screen::freqObs "

Get freq_obs_. ";

%feature("docstring")  Gyoto::Screen::freqObs "

Get freq_obs_.

Parameters:
-----------

unit:  string: unit in which freq_obs_ should be returned is
expressed, convertible to Herz or meters or energy. ";

%feature("docstring")  Gyoto::Screen::setObserverPos "

Alternative way to set projection.

Beware : paln can not be set this way, setting later other parameters
change the observer's coordinates. For observationnal ray-tracing
purposes, prefer setProjection().

Parameters:
-----------

pos:  position of observer in Screen's coordinate system. Content is
copied. ";

%feature("docstring")  Gyoto::Screen::observerKind "";

%feature("docstring")  Gyoto::Screen::observerKind "";

%feature("docstring")  Gyoto::Screen::setFourVel "

Sets the observer's 4-velocity. ";

%feature("docstring")  Gyoto::Screen::setScreen1 "

Sets the screen vector e1. ";

%feature("docstring")  Gyoto::Screen::setScreen2 "

Sets the screen vector e2. ";

%feature("docstring")  Gyoto::Screen::setScreen3 "

Sets the screen vector e3 (normal) ";

%feature("docstring")  Gyoto::Screen::coordKind "

Get coordinate kind.

From Screen::gg_. ";

%feature("docstring")  Gyoto::Screen::distance "

Get distance from observer.

In meters. ";

%feature("docstring")  Gyoto::Screen::distance "

Get distance from observer.

In specified unit. Get distance from observer ";

%feature("docstring")  Gyoto::Screen::dMax "

Get maximum ray-tracing distance.

In geometrical units. ";

%feature("docstring")  Gyoto::Screen::inclination "

Get inclination relative to line-of-sight.

Inclination of z-axis relative to line-of-sight, or inclination of
equatorial plane relative to plane of the sky, in radians. ";

%feature("docstring")  Gyoto::Screen::inclination "

Get inclination relative to line-of-sight.

Inclination of z-axis relative to line-of-sight, or inclination of
equatorial plane relative to plane of the sky, in specified unit. ";

%feature("docstring")  Gyoto::Screen::PALN "

Get position angle of the line of nodes. ";

%feature("docstring")  Gyoto::Screen::PALN "

Get position angle of the line of nodes. ";

%feature("docstring")  Gyoto::Screen::argument "

Get angle between line of nodes and X axis of object. ";

%feature("docstring")  Gyoto::Screen::argument "

Get angle between line of nodes and X axis of object. ";

%feature("docstring")  Gyoto::Screen::metric "

Get Screen::gg_. ";

%feature("docstring")  Gyoto::Screen::metric "

Set Screen::gg_. ";

%feature("docstring")  Gyoto::Screen::time "

Get observing date in seconds. ";

%feature("docstring")  Gyoto::Screen::time "

Get observing date in seconds. ";

%feature("docstring")  Gyoto::Screen::time "

Set observing date in specified unit. ";

%feature("docstring")  Gyoto::Screen::time "

Set observing date in seconds. ";

%feature("docstring")  Gyoto::Screen::fieldOfView "

Get Screen::fov_ in radians. ";

%feature("docstring")  Gyoto::Screen::fieldOfView "

Get Screen::fov_ in specified unit. ";

%feature("docstring")  Gyoto::Screen::fieldOfView "

Set Screen::fov_ in radians. ";

%feature("docstring")  Gyoto::Screen::fieldOfView "

Set Screen::fov_ in specified unit. ";

%feature("docstring")  Gyoto::Screen::azimuthalFieldOfView "

Get Screen::azimuthal_fov_. ";

%feature("docstring")  Gyoto::Screen::azimuthalFieldOfView "

Set Screen::azimuthal_fov_. ";

%feature("docstring")  Gyoto::Screen::dangle1 "

Set increment to first position angle. ";

%feature("docstring")  Gyoto::Screen::dangle1 "

Set increment to first position angle in specified unit. ";

%feature("docstring")  Gyoto::Screen::dangle1 "

Get increment to first position angle. ";

%feature("docstring")  Gyoto::Screen::dangle1 "

Get increment to first position angle in specified unit. ";

%feature("docstring")  Gyoto::Screen::dangle2 "

Set increment to second position angle. ";

%feature("docstring")  Gyoto::Screen::dangle2 "

Set increment to second position angle in specified unit. ";

%feature("docstring")  Gyoto::Screen::dangle2 "

Get increment to second position angle. ";

%feature("docstring")  Gyoto::Screen::dangle2 "

Get increment to second position angle in specified unit. ";

%feature("docstring")  Gyoto::Screen::anglekind "

Set Screen::anglekind_. ";

%feature("docstring")  Gyoto::Screen::anglekind "";

%feature("docstring")  Gyoto::Screen::anglekind "";

%feature("docstring")  Gyoto::Screen::resolution "

Get Screen::npix_. ";

%feature("docstring")  Gyoto::Screen::resolution "

Set Screen::npix_. ";

%feature("docstring")  Gyoto::Screen::mask "

Set mask_ from array.

mm will be copied. mm must be a square resolution x resolution array.
If mm==NULL, just deallocate mask_. ";

%feature("docstring")  Gyoto::Screen::mask "

Retrieve const pointer to mask_. ";

%feature("docstring")  Gyoto::Screen::maskFile "";

%feature("docstring")  Gyoto::Screen::maskFile "";

%feature("docstring")  Gyoto::Screen::getObserverPos "

4-Position of the observer relative to the metric

A Screen is positioned relative to the observer with four elements:
Screen::distance, Screen::inclination, Screen::paln and
Screen::argument.

This function returns the position of the observer relative to the
metric system in Screen::gg_, using these parameters. The output
parameter is coord.

Parameters:
-----------

coord:  position of the observer. Must be preallocated. ";

%feature("docstring")  Gyoto::Screen::getFourVel "

Get copy of Screen::fourvel_.

Parameters:
-----------

fourvel:  preallocated 4-element array ";

%feature("docstring")  Gyoto::Screen::fourVel "";

%feature("docstring")  Gyoto::Screen::fourVel "";

%feature("docstring")  Gyoto::Screen::screenVector1 "";

%feature("docstring")  Gyoto::Screen::screenVector1 "";

%feature("docstring")  Gyoto::Screen::screenVector2 "";

%feature("docstring")  Gyoto::Screen::screenVector2 "";

%feature("docstring")  Gyoto::Screen::screenVector3 "";

%feature("docstring")  Gyoto::Screen::screenVector3 "";

%feature("docstring")  Gyoto::Screen::getScreen1 "

Get copy of Screen::screen1_.

Parameters:
-----------

dest:  preallocated 4-element array ";

%feature("docstring")  Gyoto::Screen::getScreen2 "

Get copy of Screen::screen2_.

Parameters:
-----------

dest:  preallocated 4-element array ";

%feature("docstring")  Gyoto::Screen::getScreen3 "

Get copy of Screen::screen3_.

Parameters:
-----------

dest:  preallocated 4-element array ";

%feature("docstring")  Gyoto::Screen::getRayTriad "

Get 8-coordinate of Photon hitting screen from a given direction and
polarization basis if needed.

Similar to Screen::getObserverPos() but will return in addition the
4-velocity of a photon corresponding to the sky direction given by x
and y.

Parameters:
-----------

x:  RA (d_alpha*cos(delta)) offset in radians;

y:  Dec offset (d_delta) in radians;

dest:  position-velocity of the observer Photon. Preallocated.

compute_polar_basis:  True if polarization basis Ephi,Etheta is needed

Ephi:  first polarisation direction. Preallocated. Default: NULL.

Etheta:  second polarisation direction. Preallocated. Default: NULL.
";

%feature("docstring")  Gyoto::Screen::getRayTriad "

Get 8-coordinate of Photon hitting screen pixel and polarization basis
if needed.

Similar to Screen::getObserverPos() but will return in addition the
4-velocity of a photon corresponding to the sky direction given by x
and y.

Parameters:
-----------

i:  j:  pixel coordinates

dest:  position-velocity of the Photon. Preallocated.

compute_polar_basis:  True if polarization basis Ephi,Etheta is needed

Ephi:  first polarisation direction. Preallocated. Default: NULL.

Etheta:  second polarisation direction. Preallocated. Default: NULL.
";

%feature("docstring")  Gyoto::Screen::coordToSky "

Convert metric 4-position to sky 3-position.

Parameters:
-----------

pos:  4-position in metric coordinates.

dest:  3-position in plane of the sky: Cartesian East, North, front.

geometrical:  if true, #dest will be in geometrical units instead of
meters. ";

%feature("docstring")  Gyoto::Screen::skyToCoord "

Convert sky 3-position to metric 4-position.

Parameters:
-----------

sky:  3-position in plane of the sky.

dest:  4-position in metric coordinates (dest[0] is not modified).

geometrical:  set to true if #sky is in geometrical units instead of
meters. ";

%feature("docstring")  Gyoto::Screen::coordToXYZ "

Convert 4-position to 3-cartesian coordinates. ";

%feature("docstring")  Gyoto::Screen::computeBaseVectors "

Compute base vectors according to projection parameters. ";

%feature("docstring")  Gyoto::Screen::print "

Display.

Debug helper ";

%feature("docstring")  Gyoto::Screen::printBaseVectors "

Debug helper. ";

%feature("docstring")  Gyoto::Screen::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Screen::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Screen::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Screen::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Screen::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Screen::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Screen::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Screen::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Screen::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Screen::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Screen::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Screen::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Screen::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Screen::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Screen::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Screen::setParameters "

Main loop for parsing Properties from XML description.

This function queries the FactoryMessenger for elements to parse, and
tries to matche each element to a Property to set it  accordingly. Any
class that tries to be buildable from XML must supply a subcontractor
(for base classes such as Metric, Astrobj, Spectrum  and Spectrometer,
it is done as a template that must be  specialized for each class).
This subcontractor typically looks somewhat like this: Although this
is discouraged, it is possible to override the following functions to
customize how XML entities are parsed:    - setParameters() if low-
level access to the      FactoryMessenger is required;    -
setParameter(std::string name, std::string content,
std::string unit)      to interpret an entity that does not match a
Property      (e.g. alternative name);    -
setParameter(Gyoto::Property const &p, std::string const &name,
std::string const &content, std::string const &unit)      to change
how a Property is interpreted. ";

%feature("docstring")  Gyoto::Screen::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Screen::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Screen::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Screen::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Screen::kind "

Get kind_. ";


// File: union_gyoto_1_1_property_1_1setter__t.xml


// File: union_gyoto_1_1_property_1_1setter__unit__t.xml


// File: class_gyoto_1_1_metric_1_1_shift.xml
%feature("docstring") Gyoto::Metric::Shift "

The Shift flat-space metric.

Use <Cartesian> or </Spherical> to select the coordinate system kind.

C++ includes: GyotoShift.h ";

%feature("docstring")  Gyoto::Metric::Shift::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Metric::Shift::Shift "";

%feature("docstring")  Gyoto::Metric::Shift::~Shift "";

%feature("docstring")  Gyoto::Metric::Shift::clone "

Virtual copy constructor. ";

%feature("docstring")  Gyoto::Metric::Shift::subMetric "";

%feature("docstring")  Gyoto::Metric::Shift::subMetric "";

%feature("docstring")  Gyoto::Metric::Shift::offset "

Get vector copy of #pos_. ";

%feature("docstring")  Gyoto::Metric::Shift::offset "

Set #pos_ from vector. ";

%feature("docstring")  Gyoto::Metric::Shift::mass "

Set mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::Shift::gmunu "

Metric coefficients.

The default implementation calls double gmunu(const double * x, int
mu, int nu) const.

Parameters:
-----------

ARGOUT_ARRAY2:  (g) 4x4 array to store the coeefficients

IN_ARRAY1:  (x) 4-position at which to compute the coefficients;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::Shift::gmunu_up "

Metric contravariant coefficients.

The default implementation inverts the covariant coefficients matrix.
";

%feature("docstring")  Gyoto::Metric::Shift::jacobian "

Derivatives of the metric covariant coefficients.

The default implementation evaluates them numerically. The gmunu
matrix is assumed to be symmetrical but no other assumptions are made
at the moment. ";

%feature("docstring")  Gyoto::Metric::Shift::isStopCondition "

Check whether integration should stop.

The integrating loop will ask this the Metric through this method
whether or not it is happy to continue the integration. Typically, the
Metric should answer 0 when everything is fine, 1 when too close to
the event horizon, inside the BH...

Parameters:
-----------

coord:  8-coordinate vector to check. ";

%feature("docstring")  Gyoto::Metric::Shift::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Metric::Shift::setParameters "

Main loop for parsing Properties from XML description.

This function queries the FactoryMessenger for elements to parse, and
tries to matche each element to a Property to set it  accordingly. Any
class that tries to be buildable from XML must supply a subcontractor
(for base classes such as Metric, Astrobj, Spectrum  and Spectrometer,
it is done as a template that must be  specialized for each class).
This subcontractor typically looks somewhat like this: Although this
is discouraged, it is possible to override the following functions to
customize how XML entities are parsed:    - setParameters() if low-
level access to the      FactoryMessenger is required;    -
setParameter(std::string name, std::string content,
std::string unit)      to interpret an entity that does not match a
Property      (e.g. alternative name);    -
setParameter(Gyoto::Property const &p, std::string const &name,
std::string const &content, std::string const &unit)      to change
how a Property is interpreted. ";

%feature("docstring")  Gyoto::Metric::Shift::tell "

This is how a Teller tells.

A teller will basically call listener->tell(this).

Parameters:
-----------

msg:  Teller* the Teller who is telling... Useful if the Listener
listens to several Tellers. ";

%feature("docstring")  Gyoto::Metric::Shift::gmunu "

Metric coefficients.

The default implementation calls Metric:: gmunu(double g[4][4], const
double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::Shift::gmunu "

Metric coefficients.

The default implementation calls double gmunu(const double * x, int
mu, int nu) const.

Parameters:
-----------

ARGOUT_ARRAY2:  (g) 4x4 array to store the coeefficients

IN_ARRAY1:  (x) 4-position at which to compute the coefficients;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::Shift::gmunu_up "

Metric contravariant coefficients.

The default implementation calls Metric:: gmunu_up(double g[4][4],
const double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::Shift::gmunu_up "

Metric contravariant coefficients.

The default implementation inverts the covariant coefficients matrix.
";

%feature("docstring")  Gyoto::Metric::Shift::coordKind "

Get coordinate kind. ";

%feature("docstring")  Gyoto::Metric::Shift::getRefCount "";

%feature("docstring")  Gyoto::Metric::Shift::mass "

Set mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::Shift::mass "

Get mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::Shift::mass "

Get mass used in unitLength() ";

%feature("docstring")  Gyoto::Metric::Shift::unitLength "

M * G / c^2, M is in kg, unitLength in meters.

Metrics implementations are free to express lengths and distances in
whatever unit they see fit (presumably most often geometrical units).
This function returns this unit in SI (meters). ";

%feature("docstring")  Gyoto::Metric::Shift::unitLength "

unitLength expressed in specified unit ";

%feature("docstring")  Gyoto::Metric::Shift::getRmb "

Returns the marginally bound radius Should be implemented in derived
classes if useful If called on the base class, returns an error ";

%feature("docstring")  Gyoto::Metric::Shift::getRms "

Returns the marginally stable (ISCO) radius Should be implemented in
derived classes if useful If called on the base class, returns an
error ";

%feature("docstring")
Gyoto::Metric::Shift::getSpecificAngularMomentum "

Returns the specific angular momentum l=-u_phi/u_t Should be
implemented in derived classes if useful If called on the base class,
returns an error ";

%feature("docstring")  Gyoto::Metric::Shift::getPotential "

Returns potential W=-ln(|u_t|) for a cst specific angular momentum
l_cst Should be implemented in derived classes if useful If called on
the base class, returns an error ";

%feature("docstring")  Gyoto::Metric::Shift::deltaMin "

Get delta_min_ ";

%feature("docstring")  Gyoto::Metric::Shift::deltaMin "

Set delta_min_ ";

%feature("docstring")  Gyoto::Metric::Shift::deltaMax "

Get delta_max_ ";

%feature("docstring")  Gyoto::Metric::Shift::deltaMax "

Get delta max at a given position

Parameters:
-----------

pos:  4-position

[optional]:  delta_max_external external constraint on delta_max

the smallest value between delta_max_, delta_max_external, and
R*delta_max_over_r_ where R is pos[1] in spherical coordinates and
max(x1, x2, x3) in Cartesian coordinates. ";

%feature("docstring")  Gyoto::Metric::Shift::deltaMax "

Set delta_max_ ";

%feature("docstring")  Gyoto::Metric::Shift::deltaMaxOverR "

Get delta_max_over_r_. ";

%feature("docstring")  Gyoto::Metric::Shift::deltaMaxOverR "

Set delta_max_over_r_. ";

%feature("docstring")  Gyoto::Metric::Shift::keplerian "

Get keplerian_. ";

%feature("docstring")  Gyoto::Metric::Shift::keplerian "

Set keplerian_. ";

%feature("docstring")  Gyoto::Metric::Shift::cartesianVelocity "

Compute xprime, yprime and zprime from 8-coordinates. ";

%feature("docstring")  Gyoto::Metric::Shift::SysPrimeToTdot "

Compute tdot as a function of dr/dt, dtheta/dt and dphi/dt. Everything
is in geometrical units.

Parameters:
-----------

coord:  4-position (geometrical units);

v:  3-velocity dx1/dx0, dx2/dx0, dx3/dx0;

tdot = dx0/dtau. ";

%feature("docstring")  Gyoto::Metric::Shift::circularVelocity "

Yield circular velocity at a given position.

Give the velocity of a massive particle in circular orbit at the given
position projected onto the equatorial plane. Such a velocity may not
exist everywhere (or anywhere) for a given metric. This method is
intended to be used by Astrobj classes such as Torus or ThinDisk.

If keplerian_ is set to true, this method should return the Keplerian
velcity instead (derived classes should ensure this, see
KerrBL::circularVelocity() for instance).

The default implementation throws an error if keplerian_ is set to
false.

Parameters:
-----------

pos:  input: position,

vel:  output: velocity,

dir:  1 for corotating, -1 for counterrotating. ";

%feature("docstring")  Gyoto::Metric::Shift::zamoVelocity "

Yield ZAMO velocity at a given position.

Give the velocity of a zero angular momentul observer (whatever is
closest to \"at rest\"). The default implementation simply projects
(1, 0, 0, 0) othogonally along ephi and normalizes it, thus ensuring
that vel is orthogonal to ephi.

Parameters:
-----------

pos:  input: position,

vel:  output: velocity, ";

%feature("docstring")  Gyoto::Metric::Shift::nullifyCoord "

Set tdot (coord[4]) such that coord is light-like. Everything is in
geometrical units.

Set coord[4] so that the 4-velocity coord[4:7] is lightlike, i.e. of
norm 0. There may be up to two solutions. coord[4] is set to the
hightest. The lowest can be retrieved using nullifyCoord(double
coord[8], double& tdot2) const. Everything is expressed in geometrical
units.

Parameters:
-----------

coord:  8-position, coord[4] will be set according to the other
elements; ";

%feature("docstring")  Gyoto::Metric::Shift::nullifyCoord "

Set tdot (coord[4]) such that coord is light-like and return other
possible tdot.

Set coord[4] so that the 4-velocity coord[4:7] is lightlike, i.e. of
norm 0. There may be up to two solutions. coord[4] is set to the
hightest. The lowest can be retrieved in tdot2. Everything is
expressed in geometrical units.

Parameters:
-----------

coord:  8-position, coord[4] will be set according to the other
elements;

tdot2:  will be set to the smallest solution ";

%feature("docstring")  Gyoto::Metric::Shift::normalizeFourVel "

Normalize fourvelvel to -1.

First computes threevel as xiprime=xidot/x0dot for i in {1, 2, 3},
then computes x0dot using SyPrimeToTdot, then computes again xidot as
xidot=xiprime*x0dot.

Parameters:
-----------

coord:  8-position, coord[4-7] will be set according to the other
elements; ";

%feature("docstring")  Gyoto::Metric::Shift::normalizeFourVel "

Normalize fourvelvel to -1.

First computes threevel as xiprime=xidot/x0dot for i in {1, 2, 3},
then computes x0dot using SyPrimeToTdot, then computes again xidot as
xidot=xiprime*x0dot.

Parameters:
-----------

pos:  4-position;

fourvel:  4-velocity, will be renormalized. ";

%feature("docstring")  Gyoto::Metric::Shift::ScalarProd "

Scalar product.

Compute the scalarproduct of the two quadrivectors u1 and u2 in this
Metric, at point pos expressed in coordinate system sys.

Parameters:
-----------

pos:  4-position;

u1:  1st quadrivector;

u2:  2nd quadrivector;

u1*u2 ";

%feature("docstring")  Gyoto::Metric::Shift::norm "

Scalar product.

Compute the norm of the quadrivector u1 in this Metric, at point pos
expressed in coordinate system sys.

Parameters:
-----------

pos:  4-position;

u1:  quadrivector;

||u1|| ";

%feature("docstring")  Gyoto::Metric::Shift::multiplyFourVect "

multiply vector by scalar ";

%feature("docstring")  Gyoto::Metric::Shift::addFourVect "

add second vector to first one ";

%feature("docstring")  Gyoto::Metric::Shift::projectFourVect "

project u1 orthogonally to u2 at pos ";

%feature("docstring")  Gyoto::Metric::Shift::dualOneForm "

Computes dual 1-form Compute the dual 1-form of 4-vector.

Parameters:
-----------

IN_ARRAY1_1:  4-position;

IN_ARRAY1_2:  quadrivector;

ARGOUT_ARRAY1:  output 1-form ";

%feature("docstring")  Gyoto::Metric::Shift::observerTetrad "

Computes the orthonormal local tetrad of the observer.

Parameters:
-----------

obskind:  input: kind of observer (eg:
\"ZAMO\",\"KeplerianObserver\"...)

pos:  input: position,

fourvel:  output: observer 4-velocity (norm -1)

screen1:  output: first vector in the screen plane

screen2:  output: second vector in the screen plane

screen3:  output: vector normal to the screen ";

%feature("docstring")  Gyoto::Metric::Shift::observerTetrad "

Computes the orthonormal local tetrad of the observer.

Parameters:
-----------

pos:  position,

fourvel:  observer 4-velocity (norm -1)

screen1:  first vector in the screen plane

screen2:  second vector in the screen plane

screen3:  vector normal to the screen ";

%feature("docstring")  Gyoto::Metric::Shift::GramSchmidt "

Apply Gram-Schmidt orthonormalization to a basis.

On input, u0 to u3 must be four non-zero norm, independent 4-vectors.
On output, they will form an orthonormal basis.

Parameters:
-----------

pos:  position,

u0:  basis vector

u1:  basis vector

u2:  basis vector

u3:  basis vector ";

%feature("docstring")  Gyoto::Metric::Shift::gmunu "

Metric coefficients.

The default implementation calls Metric:: gmunu(double g[4][4], const
double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::Shift::gmunu_up "

Metric contravariant coefficients.

The default implementation calls Metric:: gmunu_up(double g[4][4],
const double * pos) const

Parameters:
-----------

x:  4-position at which to compute the coefficient;

mu:  1st index of coefficient, 03;

nu:  2nd index of coefficient, 03;

Metric coefficient g, at point x ";

%feature("docstring")  Gyoto::Metric::Shift::gmunu_up_and_jacobian "

gmunu_up() and jacobian() in one go ";

%feature("docstring")  Gyoto::Metric::Shift::computeNBeta "

Computes lapse scalar and shift vector at coord. ";

%feature("docstring")  Gyoto::Metric::Shift::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3). ";

%feature("docstring")  Gyoto::Metric::Shift::christoffel "

Chistoffel symbol.

Value of Christoffel symbol at point (x1, x2, x3).

1 on error, 0 otherwise ";

%feature("docstring")  Gyoto::Metric::Shift::myrk4 "

RK4 integrator. ";

%feature("docstring")  Gyoto::Metric::Shift::myrk4 "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::Shift::myrk4_adaptive "

RK4 integrator with adaptive step. ";

%feature("docstring")  Gyoto::Metric::Shift::myrk4_adaptive "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::Shift::diff "

F function such as dx/dt=F(x,cst) ";

%feature("docstring")  Gyoto::Metric::Shift::diff "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Metric::Shift::diff "";

%feature("docstring")  Gyoto::Metric::Shift::diff31 "

F function such as dx/dt=F(x,cst) for 3+1 case. ";

%feature("docstring")  Gyoto::Metric::Shift::setParticleProperties "

Set Metric-specific constants of motion. Used e.g. in KerrBL. ";

%feature("docstring")  Gyoto::Metric::Shift::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Metric::Shift::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Metric::Shift::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Metric::Shift::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Metric::Shift::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Metric::Shift::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Metric::Shift::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Metric::Shift::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Metric::Shift::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Metric::Shift::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Metric::Shift::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Metric::Shift::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Metric::Shift::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Metric::Shift::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Metric::Shift::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Metric::Shift::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Metric::Shift::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Metric::Shift::kind "

Get kind_. ";

%feature("docstring")  Gyoto::Metric::Shift::hook "

Start listening.

Use from a Hook::Listener object method: where \"this\" is a Listener
and \"teller\" is a Teller.

Use unhook() later to stop listening to a given Teller.

Parameters:
-----------

listener:  pointer to the new listener ";

%feature("docstring")  Gyoto::Metric::Shift::unhook "

Stop listening.

Use from a Hook::Listener object method:

where \"this\" is a Listener, \"teller\" is a Teller, and \"this\" has
called teller->hook(this) previously.

Parameters:
-----------

listener:  pointer to the listener ";


// File: class_gyoto_1_1_smart_pointee.xml
%feature("docstring") Gyoto::SmartPointee "

Can be pointed to by a SmartPointer.

A class can be pointed to by a SmartPointer when it inherits from
class SmartPointee.

The SmartPointee methods need to be public to be accessed by all the
SmartPointer < T > classes. However, it is a bad idea to manipulate
the counter directly. To protect these methods inside your derive
object, you can do as in the following example:

C++ includes: GyotoSmartPointer.h ";

%feature("docstring")  Gyoto::SmartPointee::SmartPointee "";

%feature("docstring")  Gyoto::SmartPointee::~SmartPointee "";

%feature("docstring")  Gyoto::SmartPointee::SmartPointee "

Copy constructor. ";

%feature("docstring")  Gyoto::SmartPointee::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::SmartPointee::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::SmartPointee::getRefCount "

Get the current number of references. ";


// File: class_gyoto_1_1_smart_pointer.xml
%feature("docstring") Gyoto::SmartPointer "

Pointers performing reference counting.

Pointee must inherit from class SmartPointee.

To create an object and a SmartPointer pointing to it:

templateparam:

T:  Sub-class of Gyoto::SmartPointee.

C++ includes: GyotoSmartPointer.h ";

%feature("docstring")  Gyoto::SmartPointer::SmartPointer "

Constructor from a standard pointer-to-class.

Parameters:
-----------

orig:  : a pointer to an instance of class T, created using new T().

Example: ";

%feature("docstring")  Gyoto::SmartPointer::SmartPointer "

Copy constructor from same type.

Parameters:
-----------

orig:  : a SmartPointer to an instance of class T

Example:

ObjPtr and ObjPtr2 point to the same instance of class T. Copying
increments the reference counter. ";

%feature("docstring")  Gyoto::SmartPointer::SmartPointer "

Copy constructor from compatible type (used for casting)

Parameters:
-----------

orig:  : a SmartPointer to an instance of another class U

Example: MetricPtr is a SmartPoiter<Metric>, but really points to an
instance of the child class Gyoto::Kerr:

MetricPtr and KerrPtr point to the same instance of class Kerr. The
methods specific to class Kerr are available only to KerrPtr. ";

%feature("docstring")  Gyoto::SmartPointer::~SmartPointer "";


// File: class_gyoto_1_1_astrobj_1_1_spherical_accretion.xml
%feature("docstring") Gyoto::Astrobj::SphericalAccretion "

A spherically-symmetric accretion flow radially falling onto the
central object.

Density is assumed to follow a r^{-2} law while temperature is a power
law with a specified slope.

This astrobj emits thermal synchrotron.

C++ includes: GyotoSphericalAccretion.h ";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::SphericalAccretion "

Standard constructor. ";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::SphericalAccretion "

Copy constructor. ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::clone "

Cloner. ";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::~SphericalAccretion "

Destructor. ";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::useSelfAbsorption "";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::useSelfAbsorption "";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::sphericalAccretionInnerRadius "";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::sphericalAccretionInnerRadius "";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::numberDensityAtInnerRadius "";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::numberDensityAtInnerRadius "";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::numberDensityAtInnerRadius "";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::numberDensityAtInnerRadius "";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::densitySlope "";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::densitySlope "";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::temperatureAtInnerRadius "";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::temperatureAtInnerRadius "";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::temperatureSlope "";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::temperatureSlope "";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::magnetizationParameter "";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::magnetizationParameter "";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::radiativeQ
"

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::getVelocity
"

Fluid velocity field.

Fill vel with the 4-vector velocity of the fluid at 4-position pos.

Parameters:
-----------

pos:  4-position at which to compute velocity;

vel:  4-velocity at pos. ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::safetyValue
"

Set Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::safetyValue
"

Get Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::deltaInObj
"

Get Generic::delta_inobj_.

Get the constant integration step inside the astrobj

delta_inobj_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::deltaInObj
"

Set Generic::delta_inobj_. ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::giveDelta "

Maximum inside object.

Gives the requested integration stept (in coordinate time t) between
two neighbooring points along a portion of geodesic inside an astrobj;
the current implementation only considers a constant delta, equal to
Standard::deltaInobj()

Parameters:
-----------

coord:  input coordinate at whicht is given ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::showshadow
"";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::showshadow
"";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::redshift "";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::redshift "";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::processHitQuantities "

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::processHitQuantities "";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::emission "

Specific intensity I

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem, in the emitter's frame. It should take self-absorption
along dsem into account.

Reminder : intensity = I [J m^-2 s^-1 ster^-1 Hz^-1];

invariant intensity = I/3, which has the same value in any frame;

emission coefficient = j [J m^-3 s^-1 ster^-1 Hz^-1] , defined by dI =
j*ds, where ds is the distance travelled by the photon inside the
object;

invariant emission coef = j/2, which has the same value in any frame.

The equation used for radiative transfer (without absorption) is:

d(I/3)/d = (j/2) [*]

where is the integration parameter along the null geodesic.

NB: Let us consider a particular observer, with being the frequency
measured by this observer, and ds being the proper distance (as
measured by the observer) that the photon travels as it moves from
to+d along its geodesic. Then it can be shown that:

d = ds/

This shows that Eq. [*] is homogeneous.

The default implementation returns 1. if optically thick and dsem if
optically thin. It allows for a quick implementation of your object
for visualization purposes.

Parameters:
-----------

nu_em:  Frequency at emission [Hz]

dsem:  length over which to integrate inside the object [geometrical
units]

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::radiativeQ
"";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::radiativeQ
"

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::transmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::computeB4vect_ipole "";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::interpolate
"

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::interpolate
"

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::incRefCount
"

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::decRefCount
"

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::getRefCount
"

Get the current number of references. ";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::fillElement
"

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")
Gyoto::Astrobj::SphericalAccretion::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::SphericalAccretion::kind "

Get kind_. ";


// File: class_gyoto_1_1_astrobj_1_1_python_1_1_standard.xml
%feature("docstring") Gyoto::Astrobj::Python::Standard "

Coding a Gyoto::Astrobj::Standard in Python.

Sample XML file: Sample Python module:

C++ includes: GyotoPython.h ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::getProperties
"

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::Standard "";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::Standard "";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::~Standard "

Destructor: does nothing. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::clone "

Cloner.

This method must be implemented by the various Astrobj::Generic
subclasses in order to support cloning:

Cloning is necessary for multi-threading, recommended for interaction
with the Yorick plug-in etc.

Implementing it is very straightforward, as long as the copy
constructor Generic(const Generic& ) has been implemented: ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::emission "

Specific intensity I

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem, in the emitter's frame. It should take self-absorption
along dsem into account.

Reminder : intensity = I [J m^-2 s^-1 ster^-1 Hz^-1];

invariant intensity = I/3, which has the same value in any frame;

emission coefficient = j [J m^-3 s^-1 ster^-1 Hz^-1] , defined by dI =
j*ds, where ds is the distance travelled by the photon inside the
object;

invariant emission coef = j/2, which has the same value in any frame.

The equation used for radiative transfer (without absorption) is:

d(I/3)/d = (j/2) [*]

where is the integration parameter along the null geodesic.

NB: Let us consider a particular observer, with being the frequency
measured by this observer, and ds being the proper distance (as
measured by the observer) that the photon travels as it moves from
to+d along its geodesic. Then it can be shown that:

d = ds/

This shows that Eq. [*] is homogeneous.

The default implementation returns 1. if optically thick and dsem if
optically thin. It allows for a quick implementation of your object
for visualization purposes.

Parameters:
-----------

nu_em:  Frequency at emission [Hz]

dsem:  length over which to integrate inside the object [geometrical
units]

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")
Gyoto::Astrobj::Python::Standard::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")
Gyoto::Astrobj::Python::Standard::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::transmission
"";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::getVelocity "

Fluid velocity field.

Fill vel with the 4-vector velocity of the fluid at 4-position pos.

Parameters:
-----------

pos:  4-position at which to compute velocity;

vel:  4-velocity at pos. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::giveDelta "

Maximum inside object.

Gives the requested integration stept (in coordinate time t) between
two neighbooring points along a portion of geodesic inside an astrobj;
the current implementation only considers a constant delta, equal to
Standard::deltaInobj()

Parameters:
-----------

coord:  input coordinate at whicht is given ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::module "

Return module_. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::module "

Set module_ and import the Python module.

Side effects: sets inline_module_ to \"\";

calls klass( class_) if class_ is already known, so module_ can be set
(or reset) after class_. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::inlineModule
"

Return inline_module_. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::inlineModule
"

Set inline_module_ and import the Python module.

Side effects: sets module_ to \"\";

calls klass( class_) if class_ is already known, so module_ can be set
(or reset) after class_. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::klass "

Retrieve class_. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::klass "

Set class_ and instantiate the Python class.

Sets pInstance_.

This generic implementation takes care of the common ground, but does
not set 'this' or call parameters( parameters_). Therefore, all the
derived classes should reimplement this method and at least call
Python::Base::klass(c) and parameters( parameters_). Between the two
is the right moment to check that the Python class implements the
required API and to cache PyObject* pointers to class methods. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::parameters "

Retrieve parameters_. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::parameters "

Set parameters_ and send them to pInstance_.

The parameters are sent to the class instance using the setitem method
with numerical keys. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::criticalValue
"";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::criticalValue
"";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::set "";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::set "";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::set "";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::get "";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::get "";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::get "";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::setParameter
"";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::setParameter
"

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::fillElement "";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::setParameters
"";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::safetyValue "

Set Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::safetyValue "

Get Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::deltaInObj "

Get Generic::delta_inobj_.

Get the constant integration step inside the astrobj

delta_inobj_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::deltaInObj "

Set Generic::delta_inobj_. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")
Gyoto::Astrobj::Python::Standard::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::opticallyThin
"

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::opticallyThin
"

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::showshadow "";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::showshadow "";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::redshift "";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::redshift "";

%feature("docstring")
Gyoto::Astrobj::Python::Standard::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")
Gyoto::Astrobj::Python::Standard::processHitQuantities "

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")
Gyoto::Astrobj::Python::Standard::processHitQuantities "";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::radiativeQ "

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")
Gyoto::Astrobj::Python::Standard::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::Python::Standard::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::transmission
"

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::transmission
"

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::transmission
"

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::getSinCos2Chi
"

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::computeB4vect
"

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")
Gyoto::Astrobj::Python::Standard::computeB4vect_ipole "";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::isThreadSafe
"

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::fillProperty
"

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")
Gyoto::Astrobj::Python::Standard::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::Python::Standard::kind "

Get kind_. ";

%feature("docstring")
Gyoto::Astrobj::Python::Standard::hasPythonProperty "";

%feature("docstring")
Gyoto::Astrobj::Python::Standard::setPythonProperty "";

%feature("docstring")
Gyoto::Astrobj::Python::Standard::getPythonProperty "";

%feature("docstring")
Gyoto::Astrobj::Python::Standard::pythonPropertyType "";


// File: class_gyoto_1_1_astrobj_1_1_standard.xml
%feature("docstring") Gyoto::Astrobj::Standard "

Astronomical objects defined bya a potential/distance.

Many geometrically thick objects can be defined by the value of a
function of the 4 coordinates, and their emission can often be defined
in terms of an emission law and of a transmission law.

This is a base class for this standard case which simplifies a lot
writting new Astrobjs.

It is either to implement a sub-class of Astrobj::Standard than a sub-
class of Astrobj::Generic. In particular, there is no need to
implement the Generic::Impact() function. Instead, one needs to
implement a few much simpler functions and most of the complex ray-
tracing algorithms and heuristics is implemented in
Standard::Impact(). It is recommended to read first the introduction
in the Gyoto::Astrobj namespace documentation.

The geometrical shape of a Gyoto::Astrobj::Standard object is yielded
by a function of the 4 position vector. This function is implemented
as operator()(). The velocity field of the fluid is implemented in the
getVelocity() method. The emission(), integrateEmission() and
transmission() methods implement the radiative transfer primitives for
this object. Finally, you may choose to reimplement
processHitQuantities() and Impact(), but this should not be necessary
(that is the all point of the Standard class).

Like any other Astrobj::Generic sub-classes, an Astrobj::Standard
subclass should register an Astrobj::Subcontractor_t function using
the Astrobj::Register() function. See also Writing plug-ins for Gyoto
.

C++ includes: GyotoStandardAstrobj.h ";

%feature("docstring")  Gyoto::Astrobj::Standard::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Astrobj::Standard::Standard "

Default constructor.

kind_ = \"Default\", rmax_ = 0., rmax_set_ = 0. ";

%feature("docstring")  Gyoto::Astrobj::Standard::Standard "

Set rmax in constructor.

kind_ = \"Default\", rmax_ = radmax, rmax_set_ = 1. ";

%feature("docstring")  Gyoto::Astrobj::Standard::Standard "

Set kind in constructor.

kind_ = kind, rmax_ = 0., rmax_set_ = 0. ";

%feature("docstring")  Gyoto::Astrobj::Standard::Standard "

Copy constructor.

Make a deep copy of an Astrobj::Standard instance ";

%feature("docstring")  Gyoto::Astrobj::Standard::~Standard "

Destructor: does nothing. ";

%feature("docstring")  Gyoto::Astrobj::Standard::safetyValue "

Set Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::Standard::safetyValue "

Get Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::Standard::deltaInObj "

Get Generic::delta_inobj_.

Get the constant integration step inside the astrobj

delta_inobj_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Standard::deltaInObj "

Set Generic::delta_inobj_. ";

%feature("docstring")  Gyoto::Astrobj::Standard::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::Standard::getVelocity "

Fluid velocity field.

Fill vel with the 4-vector velocity of the fluid at 4-position pos.

Parameters:
-----------

pos:  4-position at which to compute velocity;

vel:  4-velocity at pos. ";

%feature("docstring")  Gyoto::Astrobj::Standard::giveDelta "

Maximum inside object.

Gives the requested integration stept (in coordinate time t) between
two neighbooring points along a portion of geodesic inside an astrobj;
the current implementation only considers a constant delta, equal to
Standard::deltaInobj()

Parameters:
-----------

coord:  input coordinate at whicht is given ";

%feature("docstring")  Gyoto::Astrobj::Standard::clone "

Cloner.

This method must be implemented by the various Astrobj::Generic
subclasses in order to support cloning:

Cloning is necessary for multi-threading, recommended for interaction
with the Yorick plug-in etc.

Implementing it is very straightforward, as long as the copy
constructor Generic(const Generic& ) has been implemented: ";

%feature("docstring")  Gyoto::Astrobj::Standard::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::Standard::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::Standard::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Standard::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::Standard::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::Standard::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::Standard::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::Standard::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")  Gyoto::Astrobj::Standard::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")
Gyoto::Astrobj::Standard::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::Standard::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")  Gyoto::Astrobj::Standard::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::Standard::showshadow "";

%feature("docstring")  Gyoto::Astrobj::Standard::showshadow "";

%feature("docstring")  Gyoto::Astrobj::Standard::redshift "";

%feature("docstring")  Gyoto::Astrobj::Standard::redshift "";

%feature("docstring")  Gyoto::Astrobj::Standard::getDefaultQuantities
"

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")  Gyoto::Astrobj::Standard::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")  Gyoto::Astrobj::Standard::processHitQuantities
"

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")  Gyoto::Astrobj::Standard::processHitQuantities
"";

%feature("docstring")  Gyoto::Astrobj::Standard::emission "

Specific intensity I

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem, in the emitter's frame. It should take self-absorption
along dsem into account.

Reminder : intensity = I [J m^-2 s^-1 ster^-1 Hz^-1];

invariant intensity = I/3, which has the same value in any frame;

emission coefficient = j [J m^-3 s^-1 ster^-1 Hz^-1] , defined by dI =
j*ds, where ds is the distance travelled by the photon inside the
object;

invariant emission coef = j/2, which has the same value in any frame.

The equation used for radiative transfer (without absorption) is:

d(I/3)/d = (j/2) [*]

where is the integration parameter along the null geodesic.

NB: Let us consider a particular observer, with being the frequency
measured by this observer, and ds being the proper distance (as
measured by the observer) that the photon travels as it moves from
to+d along its geodesic. Then it can be shown that:

d = ds/

This shows that Eq. [*] is homogeneous.

The default implementation returns 1. if optically thick and dsem if
optically thin. It allows for a quick implementation of your object
for visualization purposes.

Parameters:
-----------

nu_em:  Frequency at emission [Hz]

dsem:  length over which to integrate inside the object [geometrical
units]

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position ";

%feature("docstring")  Gyoto::Astrobj::Standard::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::Standard::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::Standard::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Standard::radiativeQ "

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::Standard::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::Standard::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")  Gyoto::Astrobj::Standard::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")  Gyoto::Astrobj::Standard::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Standard::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")  Gyoto::Astrobj::Standard::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Standard::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Standard::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Standard::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Standard::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Standard::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Standard::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Standard::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Standard::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::Standard::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::Standard::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::Standard::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::Standard::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::Standard::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")  Gyoto::Astrobj::Standard::computeB4vect_ipole "";

%feature("docstring")  Gyoto::Astrobj::Standard::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::Standard::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::Standard::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::Standard::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::Standard::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::Standard::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::Standard::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Standard::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Standard::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Standard::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Standard::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Standard::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Standard::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::Standard::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::Standard::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::Standard::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Astrobj::Standard::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Astrobj::Standard::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Astrobj::Standard::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Astrobj::Standard::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::Standard::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::Standard::kind "

Get kind_. ";


// File: class_gyoto_1_1_astrobj_1_1_star.xml
%feature("docstring") Gyoto::Astrobj::Star "

Mass-less, spherical object following a timelike geodesic.

Gyoto can compute the Star's orbit in a Gyoto::Metric and perform ray-
tracing on this target. The XML description of a Star looks like:

Star supports exactly the union of the parameters supported by
Gyoto::Astrobj::UniformSphere and Gyoto::Worldline.

The Metric element can be of any kind. This Metric sets the coordinate
system.

The Star is a coordinate sphere of radius Radius in solid motion.

Position sets the initial 4-coordinate of the centre of the sphere.
Velocity contains its initial 3-velocity (the time derivatives of the
3 space coordinates).

Like many Astrobj::Generic impementations, a Star can be OpticallyThin
or OpticallyThick.

Spectrum and Opacity (if OpticallyThin) are the descriptions of two
Gyoto::Spectrum::Generic sub-classes.

C++ includes: GyotoStar.h ";

%feature("docstring")  Gyoto::Astrobj::Star::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Astrobj::Star::Star "

Create Star object and set initial condition.

Parameters:
-----------

gg:   Gyoto::SmartPointer to the Gyoto::Metric in this part of the
Universe

radius:  star radius

pos:  initial 4-position

v:  initial 3-velocity ";

%feature("docstring")  Gyoto::Astrobj::Star::Star "

Default constructor.

Create Star object with undefined initial conditions. One needs to set
the coordinate system, the metric, and the initial position and
velocity before integrating the orbit. setInititialCondition() can be
used for that. ";

%feature("docstring")  Gyoto::Astrobj::Star::Star "

Copy constructor. ";

%feature("docstring")  Gyoto::Astrobj::Star::clone "

Cloner.

This method must be implemented by the various Astrobj::Generic
subclasses in order to support cloning:

Cloning is necessary for multi-threading, recommended for interaction
with the Yorick plug-in etc.

Implementing it is very straightforward, as long as the copy
constructor Generic(const Generic& ) has been implemented: ";

%feature("docstring")  Gyoto::Astrobj::Star::~Star "

Destructor. ";

%feature("docstring")  Gyoto::Astrobj::Star::className "

\"Star\" ";

%feature("docstring")  Gyoto::Astrobj::Star::className_l "

\"star\" ";

%feature("docstring")  Gyoto::Astrobj::Star::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::Star::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::Star::getMass "

Return 1.

The mass of a Star is always 1. Stars do not perturb the metric. The
only relevant point is that Stars are massive particules, their exact
mass is of no importance. ";

%feature("docstring")  Gyoto::Astrobj::Star::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Star::setInitialCondition "

Same as Worldline::setInitialCondition(gg, coord, sys,1) ";

%feature("docstring")  Gyoto::Astrobj::Star::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Astrobj::Star::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")  Gyoto::Astrobj::Star::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Astrobj::Star::getCartesian "

Get the 6 Cartesian coordinates for specific dates.

This method is present in both the API of UniformSphere and Worldline.
It is pure virtual in UniformSphere. The Star reimplementation is a
trivial wrapper around Worldline::getCartesian(). ";

%feature("docstring")  Gyoto::Astrobj::Star::getVelocity "

Yield velocity of the center of the sphere. ";

%feature("docstring")  Gyoto::Astrobj::Star::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")  Gyoto::Astrobj::Star::spectrum "

Set spectrum_. ";

%feature("docstring")  Gyoto::Astrobj::Star::spectrum "

Get spectrum_. ";

%feature("docstring")  Gyoto::Astrobj::Star::opacity "

Set opacity_. ";

%feature("docstring")  Gyoto::Astrobj::Star::opacity "

Get opacity_. ";

%feature("docstring")  Gyoto::Astrobj::Star::radius "

Get radius_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::Star::radius "

Set radius_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::Star::radius "

Get radius_ in specified unit. ";

%feature("docstring")  Gyoto::Astrobj::Star::radius "

Set radius_ in specified unit. ";

%feature("docstring")  Gyoto::Astrobj::Star::deltaMaxOverRadius "

Get dltmor_. ";

%feature("docstring")  Gyoto::Astrobj::Star::deltaMaxOverRadius "

Set dltmor_. ";

%feature("docstring")  Gyoto::Astrobj::Star::deltaMaxOverDistance "

Get dltmod_. ";

%feature("docstring")  Gyoto::Astrobj::Star::deltaMaxOverDistance "

Set dltmod_. ";

%feature("docstring")  Gyoto::Astrobj::Star::isotropic "";

%feature("docstring")  Gyoto::Astrobj::Star::isotropic "";

%feature("docstring")  Gyoto::Astrobj::Star::alpha "";

%feature("docstring")  Gyoto::Astrobj::Star::alpha "";

%feature("docstring")  Gyoto::Astrobj::Star::deltaMax "

Parameters:

coord:  current photon position

max( dltmor_* radius_, dltmod_*operator()(double coord[]) ) ";

%feature("docstring")  Gyoto::Astrobj::Star::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")  Gyoto::Astrobj::Star::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::Star::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::Star::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Star::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")  Gyoto::Astrobj::Star::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Star::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")  Gyoto::Astrobj::Star::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Star::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Star::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Star::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Star::safetyValue "

Set Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::Star::safetyValue "

Get Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::Star::deltaInObj "

Get Generic::delta_inobj_.

Get the constant integration step inside the astrobj

delta_inobj_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Star::deltaInObj "

Set Generic::delta_inobj_. ";

%feature("docstring")  Gyoto::Astrobj::Star::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::Star::giveDelta "

Maximum inside object.

Gives the requested integration stept (in coordinate time t) between
two neighbooring points along a portion of geodesic inside an astrobj;
the current implementation only considers a constant delta, equal to
Standard::deltaInobj()

Parameters:
-----------

coord:  input coordinate at whicht is given ";

%feature("docstring")  Gyoto::Astrobj::Star::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::Star::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::Star::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::Star::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::Star::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")
Gyoto::Astrobj::Star::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::Star::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")  Gyoto::Astrobj::Star::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::Star::showshadow "";

%feature("docstring")  Gyoto::Astrobj::Star::showshadow "";

%feature("docstring")  Gyoto::Astrobj::Star::redshift "";

%feature("docstring")  Gyoto::Astrobj::Star::redshift "";

%feature("docstring")  Gyoto::Astrobj::Star::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")  Gyoto::Astrobj::Star::processHitQuantities "

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")  Gyoto::Astrobj::Star::processHitQuantities "";

%feature("docstring")  Gyoto::Astrobj::Star::radiativeQ "

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::Star::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::Star::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Star::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Star::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Star::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Star::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::Star::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::Star::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::Star::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::Star::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::Star::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")  Gyoto::Astrobj::Star::computeB4vect_ipole "";

%feature("docstring")  Gyoto::Astrobj::Star::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::Star::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::Star::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::Star::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::Star::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::Star::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::Star::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Star::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Star::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Star::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Star::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Star::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Star::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::Star::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::Star::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::Star::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Astrobj::Star::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Astrobj::Star::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::Star::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::Star::kind "

Get kind_. ";

%feature("docstring")  Gyoto::Astrobj::Star::getImin "

Get imin_. ";

%feature("docstring")  Gyoto::Astrobj::Star::getImax "

Get imax_. ";

%feature("docstring")  Gyoto::Astrobj::Star::getI0 "

Get i0_. ";

%feature("docstring")  Gyoto::Astrobj::Star::initCoord "";

%feature("docstring")  Gyoto::Astrobj::Star::initCoord "";

%feature("docstring")  Gyoto::Astrobj::Star::setInitCoord "

Set Initial coordinate.

Set imin_= imax_= i0_, and x  [i0]=coord[ ].

If dir==1, i0_ is set to 0. If dir==-1, i0_ is set to x_size_-1.

If dir==0 and the Worldine has never been computed ( i0_==0, imin_==1
and imax_==0), then dir defaults to 1 for a massive particle and -1
for a massless particle.

If dir==0 and the Worldine has already been computed, i0_ is not
changed.



Parameters:
-----------

coord:  new initial coordinates

dir:  direction of integration. 1 for forward integration, -1 for
backards integration, 0 for unknown or both

Ephi:  initial value of base vector to parallel-transport. Ignored if
parallel_transport_ is false.

Etheta:  initial value of base vector to parallel-transport. Ignored
if parallel_transport_ is false. ";

%feature("docstring")  Gyoto::Astrobj::Star::setInitCoord "

Set Initial coordinate.

Set imin_= imax_= i0_, and x  [i0]=coord[ ].

If dir==1, i0_ is set to 0. If dir==-1, i0_ is set to x_size_-1.

If dir==0 and the Worldine has never been computed ( i0_==0, imin_==1
and imax_==0), then dir defaults to 1 for a massive particle and -1
for a massless particle.

If dir==0 and the Worldine has already been computed, i0_ is not
changed.



Parameters:
-----------

coord:  new initial coordinates

dir:  direction of integration. 1 for forward integration, -1 for
backards integration, 0 for unknown or both ";

%feature("docstring")  Gyoto::Astrobj::Star::setInitCoord "

Set initial coordinate.

Parameters:
-----------

pos:  initial 4-position

vel:  initial 3-velocity

dir:  direction of integration ";

%feature("docstring")  Gyoto::Astrobj::Star::setPosition "

Set initial 4-position. ";

%feature("docstring")  Gyoto::Astrobj::Star::setVelocity "

Set initial 3-velocity. ";

%feature("docstring")  Gyoto::Astrobj::Star::reset "

Forget integration, keeping initial contition. ";

%feature("docstring")  Gyoto::Astrobj::Star::reInit "

Reset and recompute particle properties. ";

%feature("docstring")  Gyoto::Astrobj::Star::integrator "

Set the integrator.

Initialize state_ to use the required integrator.

Parameters:
-----------

type:  Either \"Legacy\" or (if GYOTO_HAVE_BOOST_INTEGRATORS) one of
\"runge_kutta_cash_karp54\", \"runge_kutta_fehlberg78\",
\"runge_kutta_dopri5\", \"runge_kutta_cash_karp54_classic\" ";

%feature("docstring")  Gyoto::Astrobj::Star::integrator "

Describe the integrator used by state_. ";

%feature("docstring")  Gyoto::Astrobj::Star::integ31 "

Set the integrator kind to 3+1 or 4D.

Initialize state_ to use the required geodesic equation. ";

%feature("docstring")  Gyoto::Astrobj::Star::integ31 "

Get the kind of geodesic equation integrated by state_. ";

%feature("docstring")  Gyoto::Astrobj::Star::deltaMin "

Get delta_min_. ";

%feature("docstring")  Gyoto::Astrobj::Star::deltaMin "

Set delta_min_. ";

%feature("docstring")  Gyoto::Astrobj::Star::deltaMax "

Get delta_max_. ";

%feature("docstring")  Gyoto::Astrobj::Star::deltaMax "

Get delta max at a given position

Parameters:
-----------

pos:  4-position

delta_max_external:  external constraint on delta_max

the smallest value between delta_max_, delta_max_external, and R*
delta_max_over_r_ where R is pos[1] in spherical coordinates and
max(x1, x2, x3) in Cartesian coordinates. ";

%feature("docstring")  Gyoto::Astrobj::Star::deltaMax "

Set delta_max_ ";

%feature("docstring")  Gyoto::Astrobj::Star::absTol "

Set abstol_. ";

%feature("docstring")  Gyoto::Astrobj::Star::absTol "

Get abstol_. ";

%feature("docstring")  Gyoto::Astrobj::Star::relTol "

Set reltol_. ";

%feature("docstring")  Gyoto::Astrobj::Star::relTol "

Get reltol_. ";

%feature("docstring")  Gyoto::Astrobj::Star::maxCrossEqplane "

Set #maxCrosEqplane_. ";

%feature("docstring")  Gyoto::Astrobj::Star::maxCrossEqplane "

Get maxCrossEqplane_. ";

%feature("docstring")  Gyoto::Astrobj::Star::deltaMaxOverR "

Get delta_max_over_r_. ";

%feature("docstring")  Gyoto::Astrobj::Star::deltaMaxOverR "

Set delta_max_over_r_. ";

%feature("docstring")  Gyoto::Astrobj::Star::delta "

Expand memory slots for polarization vectors.

Assignment to another Worldline Set delta_ ";

%feature("docstring")  Gyoto::Astrobj::Star::delta "

Set delta_ in specified units. ";

%feature("docstring")  Gyoto::Astrobj::Star::delta "

Get delta_. ";

%feature("docstring")  Gyoto::Astrobj::Star::delta "

Get delta_ in specified units. ";

%feature("docstring")  Gyoto::Astrobj::Star::tMin "

Get tmin_. ";

%feature("docstring")  Gyoto::Astrobj::Star::tMin "

Get tmin_ in specified unit. ";

%feature("docstring")  Gyoto::Astrobj::Star::tMin "

Set tmin_. ";

%feature("docstring")  Gyoto::Astrobj::Star::tMin "

Set tmin_ in specified unit. ";

%feature("docstring")  Gyoto::Astrobj::Star::adaptive "

Set adaptive_. ";

%feature("docstring")  Gyoto::Astrobj::Star::adaptive "

Get adaptive_. ";

%feature("docstring")  Gyoto::Astrobj::Star::secondary "

Set secondary_. ";

%feature("docstring")  Gyoto::Astrobj::Star::secondary "

Get secondary_. ";

%feature("docstring")  Gyoto::Astrobj::Star::parallelTransport "

Set parallel_transport_. ";

%feature("docstring")  Gyoto::Astrobj::Star::parallelTransport "

Get parallel_transport_. ";

%feature("docstring")  Gyoto::Astrobj::Star::maxiter "

Set maxiter_. ";

%feature("docstring")  Gyoto::Astrobj::Star::maxiter "

Get maxiter_. ";

%feature("docstring")  Gyoto::Astrobj::Star::getCst "

Returns the worldline's cst of motion (if any)

Return pointer to array holding the previously set Metric-specific
constants of motion.

This function returns a pointer to the actual storage location and
should be handled with care. std::vector<double> Worldline:
constantsOfMotion() constprovides a convenient way to retrieve a copy
of the content. ";

%feature("docstring")  Gyoto::Astrobj::Star::setCst "

Set Metric-specific constants of motion.

The will (re)allocate Worldline::cst_, copy cst into it, and set
Worldline::cst_n_.

This is the same as void Worldline:
constantsOfMotion(std::vector<double> const cstv) using a C-style
array instead of a vector. ";

%feature("docstring")  Gyoto::Astrobj::Star::constantsOfMotion "

Set Metric-specific constants of motion.

The will (re)allocate Worldline::cst_, copy cst into it, and set
Worldline::cst_n_.

This is the same as getCst using a vector instead of a C-style array.
";

%feature("docstring")  Gyoto::Astrobj::Star::constantsOfMotion "

Return a copy of the Metric-specific constants of motion.

This funtion return a copy of the constants of motion. getCst() can be
used to retrieve a pointer to the actual array used internally which
is slightly more efficient for read-only access. ";

%feature("docstring")  Gyoto::Astrobj::Star::setInitialCondition "

Set or re-set the initial condition prior to integration.

Parameters:
-----------

gg:   Gyoto::SmartPointer to the Gyoto::Metric in this universe;

coord:  8 element array containing the initial condition, i.e. the
4-position and the 4-velocity of the Photon at the receiving end;

dir:  direction: 1 for future, -1 for past.

Ephi:  initial value of base vector to parallel-transport. Ignored if
parallel_transport_ is false.

Etheta:  initial value of base vector to parallel-transport. Ignored
if parallel_transport_ is false. ";

%feature("docstring")  Gyoto::Astrobj::Star::setInitialCondition "

Set or re-set the initial condition prior to integration.

Parameters:
-----------

gg:   Gyoto::SmartPointer to the Gyoto::Metric in this universe;

coord:  8 element array containing the initial condition, i.e. the
4-position and the 4-velocity of the Photon at the receiving end;

dir:  direction: 1 for future, -1 for past. ";

%feature("docstring")  Gyoto::Astrobj::Star::getInitialCoord "

Get initial coordinates + base vectors.

Depending on the size of dest and on the value of parallel_transport_,
get position (xi_), velocity (xidot_) and possibly other triad vectors
(epi_ and eti_). ";

%feature("docstring")  Gyoto::Astrobj::Star::getCoord "

Get coordinates+base vectors corresponding to index.

Depending on the value of parallel_transport_, get position (xi_),
velocity (xidot_) and possibly other triad vectors (epi_ and eti_).
coord is resized to the right number of elements. ";

%feature("docstring")  Gyoto::Astrobj::Star::getCoord "

Get coordinates+base vectors corresponding to index.

We need this non-const implementation to allow the const, size_t and
the non-const, double implementations to coexist. ";

%feature("docstring")  Gyoto::Astrobj::Star::getCoord "

Get coordinates+base vectors corresponding to date dest[0].

Depending on the value of parallel_transport_, get position (xi_),
velocity (xidot_) and possibly other triad vectors (epi_ and eti_).
coord is resized to the right number of elements. ";

%feature("docstring")  Gyoto::Astrobj::Star::getCoord "

Get 8-coordinates for specific dates.

The coordinates will be computed using the integrator, so they will be
as accurate as possible. Some heuristics are used to speed up the
process and it is presumably faster to call this routine with a sorted
list of dates. The line will be integrated further as required. An
error will be thrown if it is not possible to reach a certain date.

Parameters:
-----------

dates:  the list of dates for which the coordinates are to be computed
in proper time or affine parameter if #proper is true or in coordinate
time if #proper is false (default);

n_dates:  the number of dates to compute ;

x1dest:  x2dest:  x3dest:  x0dot:  x1dot:  x2dot:  x3dot:  arrays in
which to store the result. These pointer may be set to NULL to
retrieve only part of the information. They must be pre-allocated.

ephi0:  ephi1:  ephi2:  ephi3:  etheta0:  etheta1:  etheta2:  etheta3:
arrays in which to store the ephi and etheta (parallel transport
case). These pointer may be set to NULL to retrieve only part of the
information. They must be pre-allocated.

otime:  array in which to store the other time: coordinate time if
#proper, else proper time or affine parameter.

proper:  bool: whether #dates is proper time (or affine parameter) or
coordinate time. ";

%feature("docstring")  Gyoto::Astrobj::Star::getCoord "

Get all computed positions.

Get all the pre-computed 8 coordinates (e.g. thanks to a prior call to
xFill()) of this worldline. ";

%feature("docstring")  Gyoto::Astrobj::Star::getCartesianPos "

Get Cartesian expression of 4-position at index. ";

%feature("docstring")  Gyoto::Astrobj::Star::xStore "

Store coord at index ind. ";

%feature("docstring")  Gyoto::Astrobj::Star::xStore "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Star::xStore "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Star::xFill "

Fill x0, x1... by integrating the Worldline from previously set
inittial condition to time tlim. ";

%feature("docstring")  Gyoto::Astrobj::Star::get_nelements "

Get number of computed dates. ";

%feature("docstring")  Gyoto::Astrobj::Star::get_t "

Get computed dates. ";

%feature("docstring")  Gyoto::Astrobj::Star::get_tau "

Get computed proper times or values of the affine parameter. ";

%feature("docstring")  Gyoto::Astrobj::Star::get_xyz "

Get 3-position in cartesian coordinates for computed dates. ";

%feature("docstring")  Gyoto::Astrobj::Star::checkPhiTheta "

Bring in [0,] and in [0,2].

checkPhiTheta() Modifies coord if the corrdinates are spherical-like
so that coord[2]=theta is in [0,pi] and coord[3]=phi is in [0,2pi].
Important to use in all astrobj in spherical coordinates to prevent
\"z-axis problems\". ";

%feature("docstring")  Gyoto::Astrobj::Star::getSkyPos "

Get computed positions in sky coordinates. ";

%feature("docstring")  Gyoto::Astrobj::Star::get_dot "

Get computed 4-velocities. ";

%feature("docstring")  Gyoto::Astrobj::Star::get_prime "

Get computed 3-velocities. ";

%feature("docstring")  Gyoto::Astrobj::Star::save_txyz "

Save in a file. ";

%feature("docstring")  Gyoto::Astrobj::Star::save_txyz "

Save, converted. ";


// File: class_gyoto_1_1_astrobj_1_1_star_trace.xml
%feature("docstring") Gyoto::Astrobj::StarTrace "

Like a Star that would be on all points of its orbit at all time.

StarTrace inherits all the members and methods from Star. It has two
additional members, tmin_ and tmax_, which specify the time interval
of the Star's orbit that is to be considerred illuminated.

A StarTrace is not (necessarily) continuous: the Star is considerred
to be present at all the locations computed by xFill(), meaning that
if the integration step is large compared to radius_, the object will
be a collection of discrete blobs. To ensure continuity, one should
use a non-adaptive step and specify a reasonable step. Computation is
also faster in optically thick mode.

C++ includes: GyotoStarTrace.h ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::StarTrace "

Create Star object and set initial condition.

Parameters:
-----------

gg:   Gyoto::SmartPointer to the Gyoto::Metric in this part of the
Universe

radius:  star radius

pos:  initial 4-position

v:  initial 3-velocity ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::StarTrace "

Default constructor.

Create Star object with undefined initial conditions. One needs to set
the coordinate system, the metric, and the initial position and
velocity before integrating the orbit. setInititialCondition() can be
used for that. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::StarTrace "

Copy constructor. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::StarTrace "

Build StarTrace from Star. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::clone "

Cloner.

This method must be implemented by the various Astrobj::Generic
subclasses in order to support cloning:

Cloning is necessary for multi-threading, recommended for interaction
with the Yorick plug-in etc.

Implementing it is very straightforward, as long as the copy
constructor Generic(const Generic& ) has been implemented: ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::~StarTrace "

Destructor. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::xAllocate "

Allocate x0, x1 etc. with a specified size.

Parameters:
-----------

size:  : number of cells in each array x0, x1 etc. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::xAllocateXYZ "

Allocate x_, y_, z_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::xExpand "

Expand x0, x1 etc... to hold more elements.

Double the size of arrays x0, x1 etc. and copy old version of the
array in the first half if dir =1 and in the second half if dir =-1.

Parameters:
-----------

dir:  : 1 to expand after last element, -1 to expand before first
element

ind : if dir=1, new index of old last element, if dir=-1, new index of
old first element ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::computeXYZ "

Compute (and cache) x_, y_ and z_ for one date. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::computeXYZ "

Compute (and cache) x_, y_ and z_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::setInitCoord "

Set Initial coordinate.

Set imin_= imax_= i0_, and x  [i0]=coord[ ].

If dir==1, i0_ is set to 0. If dir==-1, i0_ is set to x_size_-1.

If dir==0 and the Worldine has never been computed ( i0_==0, imin_==1
and imax_==0), then dir defaults to 1 for a massive particle and -1
for a massless particle.

If dir==0 and the Worldine has already been computed, i0_ is not
changed.



Parameters:
-----------

coord:  new initial coordinates

dir:  direction of integration. 1 for forward integration, -1 for
backards integration, 0 for unknown or both ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::xStore "

Store coord at index ind. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::className "

\"StarTrace\" ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::className_l "

\"startrace\" ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::TMin "

Get tmin_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::TMin "

Set tmin_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::TMax "

Get tmax_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::TMax "

Set tmax_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::setInitialCondition
"

Same as Worldline::setInitialCondition(gg, coord, sys,1) ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::setInitialCondition
"

Same as Worldline::setInitialCondition(gg, coord, sys,1) ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::getMass "

Return 1.

The mass of a Star is always 1. Stars do not perturb the metric. The
only relevant point is that Stars are massive particules, their exact
mass is of no importance. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::setInitialCondition
"

Set or re-set the initial condition prior to integration.

Parameters:
-----------

gg:   Gyoto::SmartPointer to the Gyoto::Metric in this universe;

coord:  8 element array containing the initial condition, i.e. the
4-position and the 4-velocity of the Photon at the receiving end;

dir:  direction: 1 for future, -1 for past.

Ephi:  initial value of base vector to parallel-transport. Ignored if
parallel_transport_ is false.

Etheta:  initial value of base vector to parallel-transport. Ignored
if parallel_transport_ is false. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::setInitialCondition
"

Set or re-set the initial condition prior to integration.

Parameters:
-----------

gg:   Gyoto::SmartPointer to the Gyoto::Metric in this universe;

coord:  8 element array containing the initial condition, i.e. the
4-position and the 4-velocity of the Photon at the receiving end;

dir:  direction: 1 for future, -1 for past. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::getCartesian "

Get the 6 Cartesian coordinates for specific dates.

This method is present in both the API of UniformSphere and Worldline.
It is pure virtual in UniformSphere. The Star reimplementation is a
trivial wrapper around Worldline::getCartesian(). ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::getVelocity "

Yield velocity of the center of the sphere. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::radiativeQ "

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::StarTrace::spectrum "

Set spectrum_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::spectrum "

Get spectrum_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::opacity "

Set opacity_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::opacity "

Get opacity_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::radius "

Get radius_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::radius "

Set radius_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::radius "

Get radius_ in specified unit. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::radius "

Set radius_ in specified unit. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::deltaMaxOverRadius "

Get dltmor_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::deltaMaxOverRadius "

Set dltmor_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::deltaMaxOverDistance
"

Get dltmod_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::deltaMaxOverDistance
"

Set dltmod_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::isotropic "";

%feature("docstring")  Gyoto::Astrobj::StarTrace::isotropic "";

%feature("docstring")  Gyoto::Astrobj::StarTrace::alpha "";

%feature("docstring")  Gyoto::Astrobj::StarTrace::alpha "";

%feature("docstring")  Gyoto::Astrobj::StarTrace::deltaMax "

Parameters:

coord:  current photon position

max( dltmor_* radius_, dltmod_*operator()(double coord[]) ) ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::deltaMax "

Get delta_max_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::deltaMax "

Get delta max at a given position

Parameters:
-----------

pos:  4-position

delta_max_external:  external constraint on delta_max

the smallest value between delta_max_, delta_max_external, and R*
delta_max_over_r_ where R is pos[1] in spherical coordinates and
max(x1, x2, x3) in Cartesian coordinates. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::deltaMax "

Set delta_max_ ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")  Gyoto::Astrobj::StarTrace::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::safetyValue "

Set Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::safetyValue "

Get Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::deltaInObj "

Get Generic::delta_inobj_.

Get the constant integration step inside the astrobj

delta_inobj_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::deltaInObj "

Set Generic::delta_inobj_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::giveDelta "

Maximum inside object.

Gives the requested integration stept (in coordinate time t) between
two neighbooring points along a portion of geodesic inside an astrobj;
the current implementation only considers a constant delta, equal to
Standard::deltaInobj()

Parameters:
-----------

coord:  input coordinate at whicht is given ";

%feature("docstring")
Gyoto::Astrobj::StarTrace::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::StarTrace::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::showshadow "";

%feature("docstring")  Gyoto::Astrobj::StarTrace::showshadow "";

%feature("docstring")  Gyoto::Astrobj::StarTrace::redshift "";

%feature("docstring")  Gyoto::Astrobj::StarTrace::redshift "";

%feature("docstring")  Gyoto::Astrobj::StarTrace::getDefaultQuantities
"

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::processHitQuantities
"

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::processHitQuantities
"";

%feature("docstring")  Gyoto::Astrobj::StarTrace::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::StarTrace::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::StarTrace::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::StarTrace::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::StarTrace::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::StarTrace::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::computeB4vect_ipole
"";

%feature("docstring")  Gyoto::Astrobj::StarTrace::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::StarTrace::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::kind "

Get kind_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::getImin "

Get imin_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::getImax "

Get imax_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::getI0 "

Get i0_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::initCoord "";

%feature("docstring")  Gyoto::Astrobj::StarTrace::initCoord "";

%feature("docstring")  Gyoto::Astrobj::StarTrace::setInitCoord "

Set Initial coordinate.

Set imin_= imax_= i0_, and x  [i0]=coord[ ].

If dir==1, i0_ is set to 0. If dir==-1, i0_ is set to x_size_-1.

If dir==0 and the Worldine has never been computed ( i0_==0, imin_==1
and imax_==0), then dir defaults to 1 for a massive particle and -1
for a massless particle.

If dir==0 and the Worldine has already been computed, i0_ is not
changed.



Parameters:
-----------

coord:  new initial coordinates

dir:  direction of integration. 1 for forward integration, -1 for
backards integration, 0 for unknown or both

Ephi:  initial value of base vector to parallel-transport. Ignored if
parallel_transport_ is false.

Etheta:  initial value of base vector to parallel-transport. Ignored
if parallel_transport_ is false. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::setInitCoord "

Set initial coordinate.

Parameters:
-----------

pos:  initial 4-position

vel:  initial 3-velocity

dir:  direction of integration ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::setPosition "

Set initial 4-position. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::setVelocity "

Set initial 3-velocity. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::reset "

Forget integration, keeping initial contition. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::reInit "

Reset and recompute particle properties. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::integrator "

Set the integrator.

Initialize state_ to use the required integrator.

Parameters:
-----------

type:  Either \"Legacy\" or (if GYOTO_HAVE_BOOST_INTEGRATORS) one of
\"runge_kutta_cash_karp54\", \"runge_kutta_fehlberg78\",
\"runge_kutta_dopri5\", \"runge_kutta_cash_karp54_classic\" ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::integrator "

Describe the integrator used by state_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::integ31 "

Set the integrator kind to 3+1 or 4D.

Initialize state_ to use the required geodesic equation. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::integ31 "

Get the kind of geodesic equation integrated by state_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::deltaMin "

Get delta_min_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::deltaMin "

Set delta_min_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::absTol "

Set abstol_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::absTol "

Get abstol_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::relTol "

Set reltol_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::relTol "

Get reltol_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::maxCrossEqplane "

Set #maxCrosEqplane_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::maxCrossEqplane "

Get maxCrossEqplane_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::deltaMaxOverR "

Get delta_max_over_r_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::deltaMaxOverR "

Set delta_max_over_r_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::delta "

Expand memory slots for polarization vectors.

Assignment to another Worldline Set delta_ ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::delta "

Set delta_ in specified units. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::delta "

Get delta_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::delta "

Get delta_ in specified units. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::tMin "

Get tmin_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::tMin "

Get tmin_ in specified unit. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::tMin "

Set tmin_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::tMin "

Set tmin_ in specified unit. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::adaptive "

Set adaptive_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::adaptive "

Get adaptive_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::secondary "

Set secondary_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::secondary "

Get secondary_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::parallelTransport "

Set parallel_transport_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::parallelTransport "

Get parallel_transport_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::maxiter "

Set maxiter_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::maxiter "

Get maxiter_. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::getCst "

Returns the worldline's cst of motion (if any)

Return pointer to array holding the previously set Metric-specific
constants of motion.

This function returns a pointer to the actual storage location and
should be handled with care. std::vector<double> Worldline:
constantsOfMotion() constprovides a convenient way to retrieve a copy
of the content. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::setCst "

Set Metric-specific constants of motion.

The will (re)allocate Worldline::cst_, copy cst into it, and set
Worldline::cst_n_.

This is the same as void Worldline:
constantsOfMotion(std::vector<double> const cstv) using a C-style
array instead of a vector. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::constantsOfMotion "

Set Metric-specific constants of motion.

The will (re)allocate Worldline::cst_, copy cst into it, and set
Worldline::cst_n_.

This is the same as getCst using a vector instead of a C-style array.
";

%feature("docstring")  Gyoto::Astrobj::StarTrace::constantsOfMotion "

Return a copy of the Metric-specific constants of motion.

This funtion return a copy of the constants of motion. getCst() can be
used to retrieve a pointer to the actual array used internally which
is slightly more efficient for read-only access. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::getInitialCoord "

Get initial coordinates + base vectors.

Depending on the size of dest and on the value of parallel_transport_,
get position (xi_), velocity (xidot_) and possibly other triad vectors
(epi_ and eti_). ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::getCoord "

Get coordinates+base vectors corresponding to index.

Depending on the value of parallel_transport_, get position (xi_),
velocity (xidot_) and possibly other triad vectors (epi_ and eti_).
coord is resized to the right number of elements. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::getCoord "

Get coordinates+base vectors corresponding to index.

We need this non-const implementation to allow the const, size_t and
the non-const, double implementations to coexist. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::getCoord "

Get coordinates+base vectors corresponding to date dest[0].

Depending on the value of parallel_transport_, get position (xi_),
velocity (xidot_) and possibly other triad vectors (epi_ and eti_).
coord is resized to the right number of elements. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::getCoord "

Get 8-coordinates for specific dates.

The coordinates will be computed using the integrator, so they will be
as accurate as possible. Some heuristics are used to speed up the
process and it is presumably faster to call this routine with a sorted
list of dates. The line will be integrated further as required. An
error will be thrown if it is not possible to reach a certain date.

Parameters:
-----------

dates:  the list of dates for which the coordinates are to be computed
in proper time or affine parameter if #proper is true or in coordinate
time if #proper is false (default);

n_dates:  the number of dates to compute ;

x1dest:  x2dest:  x3dest:  x0dot:  x1dot:  x2dot:  x3dot:  arrays in
which to store the result. These pointer may be set to NULL to
retrieve only part of the information. They must be pre-allocated.

ephi0:  ephi1:  ephi2:  ephi3:  etheta0:  etheta1:  etheta2:  etheta3:
arrays in which to store the ephi and etheta (parallel transport
case). These pointer may be set to NULL to retrieve only part of the
information. They must be pre-allocated.

otime:  array in which to store the other time: coordinate time if
#proper, else proper time or affine parameter.

proper:  bool: whether #dates is proper time (or affine parameter) or
coordinate time. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::getCoord "

Get all computed positions.

Get all the pre-computed 8 coordinates (e.g. thanks to a prior call to
xFill()) of this worldline. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::getCartesianPos "

Get Cartesian expression of 4-position at index. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::xStore "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::xStore "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::xFill "

Fill x0, x1... by integrating the Worldline from previously set
inittial condition to time tlim. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::get_nelements "

Get number of computed dates. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::get_t "

Get computed dates. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::get_tau "

Get computed proper times or values of the affine parameter. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::get_xyz "

Get 3-position in cartesian coordinates for computed dates. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::checkPhiTheta "

Bring in [0,] and in [0,2].

checkPhiTheta() Modifies coord if the corrdinates are spherical-like
so that coord[2]=theta is in [0,pi] and coord[3]=phi is in [0,2pi].
Important to use in all astrobj in spherical coordinates to prevent
\"z-axis problems\". ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::getSkyPos "

Get computed positions in sky coordinates. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::get_dot "

Get computed 4-velocities. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::get_prime "

Get computed 3-velocities. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::save_txyz "

Save in a file. ";

%feature("docstring")  Gyoto::Astrobj::StarTrace::save_txyz "

Save, converted. ";


// File: class_gyoto_1_1_hook_1_1_teller.xml
%feature("docstring") Gyoto::Hook::Teller "

Listen to me and I'll warn you when I change.

Listen to me by calling my hook() method.

C++ includes: GyotoHooks.h ";

%feature("docstring")  Gyoto::Hook::Teller::Teller "

Default constructor. ";

%feature("docstring")  Gyoto::Hook::Teller::Teller "

Copy constructor. ";

%feature("docstring")  Gyoto::Hook::Teller::~Teller "

Destructor. ";

%feature("docstring")  Gyoto::Hook::Teller::hook "

Start listening.

Use from a Hook::Listener object method: where \"this\" is a Listener
and \"teller\" is a Teller.

Use unhook() later to stop listening to a given Teller.

Parameters:
-----------

listener:  pointer to the new listener ";

%feature("docstring")  Gyoto::Hook::Teller::unhook "

Stop listening.

Use from a Hook::Listener object method:

where \"this\" is a Listener, \"teller\" is a Teller, and \"this\" has
called teller->hook(this) previously.

Parameters:
-----------

listener:  pointer to the listener ";


// File: class_gyoto_1_1_spectrum_1_1_thermal_bremsstrahlung.xml
%feature("docstring") Gyoto::Spectrum::ThermalBremsstrahlung "

Thermal brems spectrum.

Example XML entity:

C++ includes: GyotoThermalBremsstrahlungSpectrum.h ";

%feature("docstring")
Gyoto::Spectrum::ThermalBremsstrahlung::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")
Gyoto::Spectrum::ThermalBremsstrahlung::ThermalBremsstrahlung "";

%feature("docstring")
Gyoto::Spectrum::ThermalBremsstrahlung::ThermalBremsstrahlung "";

%feature("docstring")  Gyoto::Spectrum::ThermalBremsstrahlung::clone "

Cloner. ";

%feature("docstring")
Gyoto::Spectrum::ThermalBremsstrahlung::temperature "";

%feature("docstring")
Gyoto::Spectrum::ThermalBremsstrahlung::temperature "";

%feature("docstring")
Gyoto::Spectrum::ThermalBremsstrahlung::numberdensityCGS "";

%feature("docstring")
Gyoto::Spectrum::ThermalBremsstrahlung::numberdensityCGS "";

%feature("docstring")  Gyoto::Spectrum::ThermalBremsstrahlung::jnuCGS
"

Returns the emission coefficient j_nu in cgs units i.e. erg cm^-3 s^-1
ster^-1 Hz^-1

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")
Gyoto::Spectrum::ThermalBremsstrahlung::alphanuCGS "

Returns the absorption coefficient alpha_nu in cgs units [cm^-1]

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")
Gyoto::Spectrum::ThermalBremsstrahlung::radiativeQ "

Returns the emission and absorption coef jnu and alphanu in SI ";

%feature("docstring")
Gyoto::Spectrum::ThermalBremsstrahlung::integrate "

Integrate optically thick I_nu.

See operator()(double nu) const

Parameters:
-----------

nu1:  nu2:  boundaries for the integration

I, the integral of I_nu between nu1 and nu2 ";

%feature("docstring")
Gyoto::Spectrum::ThermalBremsstrahlung::integrate "

Integrate optically thin I_nu.

See operator()(double nu, double opacity, double ds) const

Parameters:
-----------

nu1:  nu2:  boundaries for the integration

opacity:  the frequency-dependent opacity law given as a pointer to a
Gyoto::Spectrum::Generic sub-class instance

ds:  the element length for spatial integration

I, the integral of I_nu between nu1 and nu2 ";

%feature("docstring")
Gyoto::Spectrum::ThermalBremsstrahlung::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")
Gyoto::Spectrum::ThermalBremsstrahlung::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")
Gyoto::Spectrum::ThermalBremsstrahlung::getRefCount "

Get the current number of references. ";

%feature("docstring")
Gyoto::Spectrum::ThermalBremsstrahlung::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Spectrum::ThermalBremsstrahlung::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Spectrum::ThermalBremsstrahlung::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Spectrum::ThermalBremsstrahlung::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Spectrum::ThermalBremsstrahlung::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Spectrum::ThermalBremsstrahlung::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Spectrum::ThermalBremsstrahlung::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Spectrum::ThermalBremsstrahlung::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Spectrum::ThermalBremsstrahlung::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")
Gyoto::Spectrum::ThermalBremsstrahlung::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")
Gyoto::Spectrum::ThermalBremsstrahlung::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")
Gyoto::Spectrum::ThermalBremsstrahlung::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")
Gyoto::Spectrum::ThermalBremsstrahlung::setParameters "

Main loop for parsing Properties from XML description.

This function queries the FactoryMessenger for elements to parse, and
tries to matche each element to a Property to set it  accordingly. Any
class that tries to be buildable from XML must supply a subcontractor
(for base classes such as Metric, Astrobj, Spectrum  and Spectrometer,
it is done as a template that must be  specialized for each class).
This subcontractor typically looks somewhat like this: Although this
is discouraged, it is possible to override the following functions to
customize how XML entities are parsed:    - setParameters() if low-
level access to the      FactoryMessenger is required;    -
setParameter(std::string name, std::string content,
std::string unit)      to interpret an entity that does not match a
Property      (e.g. alternative name);    -
setParameter(Gyoto::Property const &p, std::string const &name,
std::string const &content, std::string const &unit)      to change
how a Property is interpreted. ";

%feature("docstring")
Gyoto::Spectrum::ThermalBremsstrahlung::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")
Gyoto::Spectrum::ThermalBremsstrahlung::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")
Gyoto::Spectrum::ThermalBremsstrahlung::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Spectrum::ThermalBremsstrahlung::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Spectrum::ThermalBremsstrahlung::kind "

Get kind_. ";


// File: class_gyoto_1_1_spectrum_1_1_thermal_synchrotron.xml
%feature("docstring") Gyoto::Spectrum::ThermalSynchrotron "

Thermal synchrotron spectrum.

Example XML entity:

C++ includes: GyotoThermalSynchrotronSpectrum.h ";

%feature("docstring")
Gyoto::Spectrum::ThermalSynchrotron::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")
Gyoto::Spectrum::ThermalSynchrotron::ThermalSynchrotron "";

%feature("docstring")
Gyoto::Spectrum::ThermalSynchrotron::ThermalSynchrotron "";

%feature("docstring")  Gyoto::Spectrum::ThermalSynchrotron::clone "

Cloner. ";

%feature("docstring")
Gyoto::Spectrum::ThermalSynchrotron::temperature "";

%feature("docstring")
Gyoto::Spectrum::ThermalSynchrotron::temperature "";

%feature("docstring")
Gyoto::Spectrum::ThermalSynchrotron::numberdensityCGS "";

%feature("docstring")
Gyoto::Spectrum::ThermalSynchrotron::numberdensityCGS "";

%feature("docstring")
Gyoto::Spectrum::ThermalSynchrotron::angle_B_pem "";

%feature("docstring")
Gyoto::Spectrum::ThermalSynchrotron::angle_B_pem "";

%feature("docstring")
Gyoto::Spectrum::ThermalSynchrotron::cyclotron_freq "";

%feature("docstring")
Gyoto::Spectrum::ThermalSynchrotron::cyclotron_freq "";

%feature("docstring")
Gyoto::Spectrum::ThermalSynchrotron::angle_averaged "";

%feature("docstring")
Gyoto::Spectrum::ThermalSynchrotron::angle_averaged "";

%feature("docstring")  Gyoto::Spectrum::ThermalSynchrotron::besselK2 "";

%feature("docstring")  Gyoto::Spectrum::ThermalSynchrotron::besselK2 "";

%feature("docstring")  Gyoto::Spectrum::ThermalSynchrotron::jnuCGS "

Returns the emission coefficient j_nu in cgs units i.e. erg cm^-3 s^-1
ster^-1 Hz^-1

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")  Gyoto::Spectrum::ThermalSynchrotron::jQnuCGS "

Returns the Stokes Q emission coefficient j_nu in cgs units i.e. erg
cm^-3 s^-1 ster^-1 Hz^-1

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")  Gyoto::Spectrum::ThermalSynchrotron::jUnuCGS "

Returns the Stokes U emission coefficient j_nu in cgs units i.e. erg
cm^-3 s^-1 ster^-1 Hz^-1

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")  Gyoto::Spectrum::ThermalSynchrotron::jVnuCGS "

Returns the Stokes V emission coefficient j_nu in cgs units i.e. erg
cm^-3 s^-1 ster^-1 Hz^-1

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")  Gyoto::Spectrum::ThermalSynchrotron::alphanuCGS
"

Returns the absorption coefficient alpha_nu in cgs units [cm^-1]

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")
Gyoto::Spectrum::ThermalSynchrotron::alphaQnuCGS "

Returns the Stokes Q absorption coefficient alpha_nu in cgs units
[cm^-1]

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")
Gyoto::Spectrum::ThermalSynchrotron::alphaUnuCGS "

Returns the Stokes U absorption coefficient alpha_nu in cgs units
[cm^-1]

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")
Gyoto::Spectrum::ThermalSynchrotron::alphaVnuCGS "

Returns the Stokes V absorption coefficient alpha_nu in cgs units
[cm^-1]

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")  Gyoto::Spectrum::ThermalSynchrotron::rQnuCGS "

Returns the Stokes Q Faraday rotation coefficient in cgs units [cm^-1]

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")  Gyoto::Spectrum::ThermalSynchrotron::rUnuCGS "

Returns the Stokes U Faraday rotation coefficient in cgs units [cm^-1]

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")  Gyoto::Spectrum::ThermalSynchrotron::rVnuCGS "

Returns the Stokes V Faraday rotation coefficient in cgs units [cm^-1]

Parameters:
-----------

nu:  frequency in Hz ";

%feature("docstring")  Gyoto::Spectrum::ThermalSynchrotron::radiativeQ
"

Returns the emission and absorption coef in SI ";

%feature("docstring")  Gyoto::Spectrum::ThermalSynchrotron::radiativeQ
"

Returns the emission, absorption and Fraday rotation coef in SI for
the 4 Stokes parameters ";

%feature("docstring")  Gyoto::Spectrum::ThermalSynchrotron::integrate
"

Integrate optically thick I_nu.

See operator()(double nu) const

Parameters:
-----------

nu1:  nu2:  boundaries for the integration

I, the integral of I_nu between nu1 and nu2 ";

%feature("docstring")  Gyoto::Spectrum::ThermalSynchrotron::integrate
"

Integrate optically thin I_nu.

See operator()(double nu, double opacity, double ds) const

Parameters:
-----------

nu1:  nu2:  boundaries for the integration

opacity:  the frequency-dependent opacity law given as a pointer to a
Gyoto::Spectrum::Generic sub-class instance

ds:  the element length for spatial integration

I, the integral of I_nu between nu1 and nu2 ";

%feature("docstring")
Gyoto::Spectrum::ThermalSynchrotron::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")
Gyoto::Spectrum::ThermalSynchrotron::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")
Gyoto::Spectrum::ThermalSynchrotron::getRefCount "

Get the current number of references. ";

%feature("docstring")
Gyoto::Spectrum::ThermalSynchrotron::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Spectrum::ThermalSynchrotron::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Spectrum::ThermalSynchrotron::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Spectrum::ThermalSynchrotron::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Spectrum::ThermalSynchrotron::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Spectrum::ThermalSynchrotron::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Spectrum::ThermalSynchrotron::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Spectrum::ThermalSynchrotron::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Spectrum::ThermalSynchrotron::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Spectrum::ThermalSynchrotron::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")
Gyoto::Spectrum::ThermalSynchrotron::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")
Gyoto::Spectrum::ThermalSynchrotron::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")
Gyoto::Spectrum::ThermalSynchrotron::setParameters "

Main loop for parsing Properties from XML description.

This function queries the FactoryMessenger for elements to parse, and
tries to matche each element to a Property to set it  accordingly. Any
class that tries to be buildable from XML must supply a subcontractor
(for base classes such as Metric, Astrobj, Spectrum  and Spectrometer,
it is done as a template that must be  specialized for each class).
This subcontractor typically looks somewhat like this: Although this
is discouraged, it is possible to override the following functions to
customize how XML entities are parsed:    - setParameters() if low-
level access to the      FactoryMessenger is required;    -
setParameter(std::string name, std::string content,
std::string unit)      to interpret an entity that does not match a
Property      (e.g. alternative name);    -
setParameter(Gyoto::Property const &p, std::string const &name,
std::string const &content, std::string const &unit)      to change
how a Property is interpreted. ";

%feature("docstring")
Gyoto::Spectrum::ThermalSynchrotron::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")
Gyoto::Spectrum::ThermalSynchrotron::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")
Gyoto::Spectrum::ThermalSynchrotron::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Spectrum::ThermalSynchrotron::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Spectrum::ThermalSynchrotron::kind "

Get kind_. ";


// File: class_gyoto_1_1_astrobj_1_1_thick_disk.xml
%feature("docstring") Gyoto::Astrobj::ThickDisk "

A thick accretion disk described by its inner radius and the fwhm of
the Gaussian factor affecting the density out of the equatorial plane.

Density is assumed to follow a r^{-2} law while temperature is a power
law with a specified slope.

This astrobj emits thermal synchrotron.

C++ includes: GyotoThickDisk.h ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::ThickDisk "

Standard constructor. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::ThickDisk "

Copy constructor. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::clone "

Cloner. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::~ThickDisk "

Destructor. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::thickDiskInnerRadius
"";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::thickDiskInnerRadius
"";

%feature("docstring")
Gyoto::Astrobj::ThickDisk::thickDiskZGaussianSigma "";

%feature("docstring")
Gyoto::Astrobj::ThickDisk::thickDiskZGaussianSigma "";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::useSelfAbsorption "";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::useSelfAbsorption "";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::veloParam "";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::veloParam "";

%feature("docstring")
Gyoto::Astrobj::ThickDisk::numberDensityAtInnerRadius "";

%feature("docstring")
Gyoto::Astrobj::ThickDisk::numberDensityAtInnerRadius "";

%feature("docstring")
Gyoto::Astrobj::ThickDisk::numberDensityAtInnerRadius "";

%feature("docstring")
Gyoto::Astrobj::ThickDisk::numberDensityAtInnerRadius "";

%feature("docstring")
Gyoto::Astrobj::ThickDisk::temperatureAtInnerRadius "";

%feature("docstring")
Gyoto::Astrobj::ThickDisk::temperatureAtInnerRadius "";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::temperatureSlope "";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::temperatureSlope "";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::densitySlope "";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::densitySlope "";

%feature("docstring")
Gyoto::Astrobj::ThickDisk::magnetizationParameter "";

%feature("docstring")
Gyoto::Astrobj::ThickDisk::magnetizationParameter "";

%feature("docstring")
Gyoto::Astrobj::ThickDisk::magneticConfiguration "";

%feature("docstring")
Gyoto::Astrobj::ThickDisk::magneticConfiguration "";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::radiativeQ "

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::getVelocity "

Fluid velocity field.

Fill vel with the 4-vector velocity of the fluid at 4-position pos.

Parameters:
-----------

pos:  4-position at which to compute velocity;

vel:  4-velocity at pos. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::safetyValue "

Set Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::safetyValue "

Get Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::deltaInObj "

Get Generic::delta_inobj_.

Get the constant integration step inside the astrobj

delta_inobj_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::deltaInObj "

Set Generic::delta_inobj_. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::giveDelta "

Maximum inside object.

Gives the requested integration stept (in coordinate time t) between
two neighbooring points along a portion of geodesic inside an astrobj;
the current implementation only considers a constant delta, equal to
Standard::deltaInobj()

Parameters:
-----------

coord:  input coordinate at whicht is given ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")
Gyoto::Astrobj::ThickDisk::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::showshadow "";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::showshadow "";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::redshift "";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::redshift "";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::getDefaultQuantities
"

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::processHitQuantities
"

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::processHitQuantities
"";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::emission "

Specific intensity I

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem, in the emitter's frame. It should take self-absorption
along dsem into account.

Reminder : intensity = I [J m^-2 s^-1 ster^-1 Hz^-1];

invariant intensity = I/3, which has the same value in any frame;

emission coefficient = j [J m^-3 s^-1 ster^-1 Hz^-1] , defined by dI =
j*ds, where ds is the distance travelled by the photon inside the
object;

invariant emission coef = j/2, which has the same value in any frame.

The equation used for radiative transfer (without absorption) is:

d(I/3)/d = (j/2) [*]

where is the integration parameter along the null geodesic.

NB: Let us consider a particular observer, with being the frequency
measured by this observer, and ds being the proper distance (as
measured by the observer) that the photon travels as it moves from
to+d along its geodesic. Then it can be shown that:

d = ds/

This shows that Eq. [*] is homogeneous.

The default implementation returns 1. if optically thick and dsem if
optically thin. It allows for a quick implementation of your object
for visualization purposes.

Parameters:
-----------

nu_em:  Frequency at emission [Hz]

dsem:  length over which to integrate inside the object [geometrical
units]

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::computeB4vect_ipole
"";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::ThickDisk::kind "

Get kind_. ";


// File: class_gyoto_1_1_astrobj_1_1_python_1_1_thin_disk.xml
%feature("docstring") Gyoto::Astrobj::Python::ThinDisk "

Coding a Gyoto::Astrobj::ThinDisk in Python.

Sample XML file: Sample Python module:

C++ includes: GyotoPython.h ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::getProperties
"

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::ThinDisk "";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::ThinDisk "";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::~ThinDisk "

Destructor. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::clone "

Cloner.

This method must be implemented by the various Astrobj::Generic
subclasses in order to support cloning:

Cloning is necessary for multi-threading, recommended for interaction
with the Yorick plug-in etc.

Implementing it is very straightforward, as long as the copy
constructor Generic(const Generic& ) has been implemented: ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::emission "

Specific intensity I

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem, in the emitter's frame. It should take self-absorption
along dsem into account.

Reminder : intensity = I [J m^-2 s^-1 ster^-1 Hz^-1];

invariant intensity = I/3, which has the same value in any frame;

emission coefficient = j [J m^-3 s^-1 ster^-1 Hz^-1] , defined by dI =
j*ds, where ds is the distance travelled by the photon inside the
object;

invariant emission coef = j/2, which has the same value in any frame.

The equation used for radiative transfer (without absorption) is:

d(I/3)/d = (j/2) [*]

where is the integration parameter along the null geodesic.

NB: Let us consider a particular observer, with being the frequency
measured by this observer, and ds being the proper distance (as
measured by the observer) that the photon travels as it moves from
to+d along its geodesic. Then it can be shown that:

d = ds/

This shows that Eq. [*] is homogeneous.

The default implementation returns 1. if optically thick and dsem if
optically thin. It allows for a quick implementation of your object
for visualization purposes.

Parameters:
-----------

nu_em:  Frequency at emission [Hz]

dsem:  length over which to integrate inside the object [geometrical
units]

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")
Gyoto::Astrobj::Python::ThinDisk::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")
Gyoto::Astrobj::Python::ThinDisk::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::transmission
"";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::getVelocity "

Get fluid 4-velocity at point.

Fill vel with the 4-vector velocity of the fluid at 4-position pos.
getVelocity() should work at some distance from the equatorial plane.
The default implementation calls Metric::Generic::circularVelocity().

Parameters:
-----------

pos:  4-position at which to compute velocity;

vel:  4-velocity at pos. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::module "

Return module_. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::module "

Set module_ and import the Python module.

Side effects: sets inline_module_ to \"\";

calls klass( class_) if class_ is already known, so module_ can be set
(or reset) after class_. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::inlineModule
"

Return inline_module_. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::inlineModule
"

Set inline_module_ and import the Python module.

Side effects: sets module_ to \"\";

calls klass( class_) if class_ is already known, so module_ can be set
(or reset) after class_. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::klass "

Retrieve class_. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::klass "

Set class_ and instantiate the Python class.

Sets pInstance_.

This generic implementation takes care of the common ground, but does
not set 'this' or call parameters( parameters_). Therefore, all the
derived classes should reimplement this method and at least call
Python::Base::klass(c) and parameters( parameters_). Between the two
is the right moment to check that the Python class implements the
required API and to cache PyObject* pointers to class methods. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::parameters "

Retrieve parameters_. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::parameters "

Set parameters_ and send them to pInstance_.

The parameters are sent to the class instance using the setitem method
with numerical keys. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::set "";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::set "";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::set "";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::get "";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::get "";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::get "";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::setParameter
"";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::setParameter
"

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::fillElement "";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::setParameters
"";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::innerRadius "

Get rin_. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::innerRadius "

Get rin_. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::innerRadius "

Set rin_. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::innerRadius "

Set rin_. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::outerRadius "

Get rout_. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::outerRadius "

Get rout_. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::outerRadius "

Set rout_. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::outerRadius "

Set rout_. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::thickness "

Get thickness_. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::thickness "

Get thickness_. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::thickness "

Set thickness_. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::thickness "

Set thickness_. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::dir "

Get dir_. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::dir "

Set dir_. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::corotating "";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::corotating "

Get dir_==1. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::velocityKind
"

Set dir_=t?1:-1.

Get VelocityKind ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::velocityKind
"

Set VelocityKind. ";

%feature("docstring")
Gyoto::Astrobj::Python::ThinDisk::projectedRadius "

Projected radius of position coord on the equatorial plane. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::sphericalPhi
"

Longitude. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")
Gyoto::Astrobj::Python::ThinDisk::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::opticallyThin
"

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::opticallyThin
"

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::showshadow "";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::showshadow "";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::redshift "";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::redshift "";

%feature("docstring")
Gyoto::Astrobj::Python::ThinDisk::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")
Gyoto::Astrobj::Python::ThinDisk::processHitQuantities "

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")
Gyoto::Astrobj::Python::ThinDisk::processHitQuantities "";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::radiativeQ "

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")
Gyoto::Astrobj::Python::ThinDisk::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::Python::ThinDisk::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::transmission
"

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::transmission
"

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::transmission
"

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::getSinCos2Chi
"

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::computeB4vect
"

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")
Gyoto::Astrobj::Python::ThinDisk::computeB4vect_ipole "";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::isThreadSafe
"

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::fillProperty
"

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")
Gyoto::Astrobj::Python::ThinDisk::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::Python::ThinDisk::kind "

Get kind_. ";

%feature("docstring")
Gyoto::Astrobj::Python::ThinDisk::hasPythonProperty "";

%feature("docstring")
Gyoto::Astrobj::Python::ThinDisk::setPythonProperty "";

%feature("docstring")
Gyoto::Astrobj::Python::ThinDisk::getPythonProperty "";

%feature("docstring")
Gyoto::Astrobj::Python::ThinDisk::pythonPropertyType "";


// File: class_gyoto_1_1_astrobj_1_1_thin_disk.xml
%feature("docstring") Gyoto::Astrobj::ThinDisk "

Geometrically thin disks and rings.

ThinDisk::setParameter() also takes care of calling
Generic::setParameter().

C++ includes: GyotoThinDisk.h ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::ThinDisk "

Default constructor.

Create direct ThinDisk object. When initializing a derived class,
always set kind. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::ThinDisk "

Copy constructor. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::clone "

Cloner.

This method must be implemented by the various Astrobj::Generic
subclasses in order to support cloning:

Cloning is necessary for multi-threading, recommended for interaction
with the Yorick plug-in etc.

Implementing it is very straightforward, as long as the copy
constructor Generic(const Generic& ) has been implemented: ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::~ThinDisk "

Destructor. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::innerRadius "

Get rin_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::innerRadius "

Get rin_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::innerRadius "

Set rin_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::innerRadius "

Set rin_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::outerRadius "

Get rout_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::outerRadius "

Get rout_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::outerRadius "

Set rout_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::outerRadius "

Set rout_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::thickness "

Get thickness_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::thickness "

Get thickness_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::thickness "

Set thickness_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::thickness "

Set thickness_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::dir "

Get dir_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::dir "

Set dir_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::corotating "";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::corotating "

Get dir_==1. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::velocityKind "

Set dir_=t?1:-1.

Get VelocityKind ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::velocityKind "

Set VelocityKind. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::projectedRadius "

Projected radius of position coord on the equatorial plane. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::sphericalPhi "

Longitude. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::getVelocity "

Get fluid 4-velocity at point.

Fill vel with the 4-vector velocity of the fluid at 4-position pos.
getVelocity() should work at some distance from the equatorial plane.
The default implementation calls Metric::Generic::circularVelocity().

Parameters:
-----------

pos:  4-position at which to compute velocity;

vel:  4-velocity at pos. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")
Gyoto::Astrobj::ThinDisk::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::showshadow "";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::showshadow "";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::redshift "";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::redshift "";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::getDefaultQuantities
"

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::processHitQuantities
"

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::processHitQuantities
"";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::emission "

Specific intensity I

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem, in the emitter's frame. It should take self-absorption
along dsem into account.

Reminder : intensity = I [J m^-2 s^-1 ster^-1 Hz^-1];

invariant intensity = I/3, which has the same value in any frame;

emission coefficient = j [J m^-3 s^-1 ster^-1 Hz^-1] , defined by dI =
j*ds, where ds is the distance travelled by the photon inside the
object;

invariant emission coef = j/2, which has the same value in any frame.

The equation used for radiative transfer (without absorption) is:

d(I/3)/d = (j/2) [*]

where is the integration parameter along the null geodesic.

NB: Let us consider a particular observer, with being the frequency
measured by this observer, and ds being the proper distance (as
measured by the observer) that the photon travels as it moves from
to+d along its geodesic. Then it can be shown that:

d = ds/

This shows that Eq. [*] is homogeneous.

The default implementation returns 1. if optically thick and dsem if
optically thin. It allows for a quick implementation of your object
for visualization purposes.

Parameters:
-----------

nu_em:  Frequency at emission [Hz]

dsem:  length over which to integrate inside the object [geometrical
units]

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::radiativeQ "

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::computeB4vect_ipole "";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::ThinDisk::kind "

Get kind_. ";


// File: class_gyoto_1_1_astrobj_1_1_thin_disk_grid_intensity.xml
%feature("docstring") Gyoto::Astrobj::ThinDiskGridIntensity "";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::ThinDiskGridIntensity "

Standard constructor. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::ThinDiskGridIntensity "

Copy constructor. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::clone "

Cloner. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::~ThinDiskGridIntensity "

Destructor. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::file "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::file "";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::timeTranslation_inMunit "";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::timeTranslation_inMunit "";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::copyIntensity "";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::getIntensity "";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::copyTimeArray "";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::getTimeArray "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::fitsRead
"";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::emission
"

Specific intensity I

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem, in the emitter's frame. It should take self-absorption
along dsem into account.

Reminder : intensity = I [J m^-2 s^-1 ster^-1 Hz^-1];

invariant intensity = I/3, which has the same value in any frame;

emission coefficient = j [J m^-3 s^-1 ster^-1 Hz^-1] , defined by dI =
j*ds, where ds is the distance travelled by the photon inside the
object;

invariant emission coef = j/2, which has the same value in any frame.

The equation used for radiative transfer (without absorption) is:

d(I/3)/d = (j/2) [*]

where is the integration parameter along the null geodesic.

NB: Let us consider a particular observer, with being the frequency
measured by this observer, and ds being the proper distance (as
measured by the observer) that the photon travels as it moves from
to+d along its geodesic. Then it can be shown that:

d = ds/

This shows that Eq. [*] is homogeneous.

The default implementation returns 1. if optically thick and dsem if
optically thin. It allows for a quick implementation of your object
for visualization purposes.

Parameters:
-----------

nu_em:  Frequency at emission [Hz]

dsem:  length over which to integrate inside the object [geometrical
units]

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::getVelocity "

Get fluid 4-velocity at point.

Fill vel with the 4-vector velocity of the fluid at 4-position pos.
getVelocity() should work at some distance from the equatorial plane.
The default implementation calls Metric::Generic::circularVelocity().

Parameters:
-----------

pos:  4-position at which to compute velocity;

vel:  4-velocity at pos. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::metric "

Set the Metric gg_. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::innerRadius "

Get rin_. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::innerRadius "

Get rin_. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::innerRadius "

Set rin_. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::innerRadius "

Set rin_. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::outerRadius "

Get rout_. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::outerRadius "

Get rout_. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::outerRadius "

Set rout_. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::outerRadius "

Set rout_. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::thickness "

Get thickness_. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::thickness "

Get thickness_. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::thickness "

Set thickness_. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::thickness "

Set thickness_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::dir "

Get dir_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::dir "

Set dir_. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::corotating "";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::corotating "

Get dir_==1. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::velocityKind "

Set dir_=t?1:-1.

Get VelocityKind ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::velocityKind "

Set VelocityKind. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::projectedRadius "

Projected radius of position coord on the equatorial plane. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::sphericalPhi "

Longitude. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::deltaMax
"

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::showshadow "";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::showshadow "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::redshift
"";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::redshift
"";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::processHitQuantities "

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::processHitQuantities "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::emission
"

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::emission
"

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::emission
"

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::radiativeQ "

emission and transmission together ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::radiativeQ "";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::transmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::Omatrix
"

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::Omatrix
"";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::Omatrix
"";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::Omatrix
"";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::Pmatrix
"";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::rotateJs
"

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::rotateJs
"";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::computeB4vect_ipole "";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::getRefCount "

Get the current number of references. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::property
"

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::kind "

Get kind_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::rmin "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::rmin "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::rmax "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::rmax "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::nr "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::nr "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::dr "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::dr "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::phimin "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::phimin "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::phimax "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::phimax "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::dphi "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::dphi "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::tmin "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::tmin "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::tmax "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::tmax "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::nt "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::nt "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::nphi "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskGridIntensity::nphi "";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::getIndices "";

%feature("docstring")
Gyoto::Astrobj::ThinDiskGridIntensity::interpolate "";


// File: class_gyoto_1_1_astrobj_1_1_thin_disk_iron_line.xml
%feature("docstring") Gyoto::Astrobj::ThinDiskIronLine "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::getProperties
"

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskIronLine::ThinDiskIronLine "";

%feature("docstring")
Gyoto::Astrobj::ThinDiskIronLine::ThinDiskIronLine "";

%feature("docstring")
Gyoto::Astrobj::ThinDiskIronLine::~ThinDiskIronLine "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::clone "

Cloner.

This method must be implemented by the various Astrobj::Generic
subclasses in order to support cloning:

Cloning is necessary for multi-threading, recommended for interaction
with the Yorick plug-in etc.

Implementing it is very straightforward, as long as the copy
constructor Generic(const Generic& ) has been implemented: ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::emission "

Specific intensity I

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem, in the emitter's frame. It should take self-absorption
along dsem into account.

Reminder : intensity = I [J m^-2 s^-1 ster^-1 Hz^-1];

invariant intensity = I/3, which has the same value in any frame;

emission coefficient = j [J m^-3 s^-1 ster^-1 Hz^-1] , defined by dI =
j*ds, where ds is the distance travelled by the photon inside the
object;

invariant emission coef = j/2, which has the same value in any frame.

The equation used for radiative transfer (without absorption) is:

d(I/3)/d = (j/2) [*]

where is the integration parameter along the null geodesic.

NB: Let us consider a particular observer, with being the frequency
measured by this observer, and ds being the proper distance (as
measured by the observer) that the photon travels as it moves from
to+d along its geodesic. Then it can be shown that:

d = ds/

This shows that Eq. [*] is homogeneous.

The default implementation returns 1. if optically thick and dsem if
optically thin. It allows for a quick implementation of your object
for visualization purposes.

Parameters:
-----------

nu_em:  Frequency at emission [Hz]

dsem:  length over which to integrate inside the object [geometrical
units]

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::getVelocity "

Get fluid 4-velocity at point.

Fill vel with the 4-vector velocity of the fluid at 4-position pos.
getVelocity() should work at some distance from the equatorial plane.
The default implementation calls Metric::Generic::circularVelocity().

Parameters:
-----------

pos:  4-position at which to compute velocity;

vel:  4-velocity at pos. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskIronLine::GYOTO_OBJECT_ACCESSORS "";

%feature("docstring")
Gyoto::Astrobj::ThinDiskIronLine::GYOTO_OBJECT_ACCESSORS "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::LineFreq "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::LineFreq "";

%feature("docstring")
Gyoto::Astrobj::ThinDiskIronLine::GYOTO_OBJECT_ACCESSORS "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::CutRadius "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::CutRadius "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::innerRadius "

Get rin_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::innerRadius "

Get rin_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::innerRadius "

Set rin_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::innerRadius "

Set rin_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::outerRadius "

Get rout_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::outerRadius "

Get rout_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::outerRadius "

Set rout_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::outerRadius "

Set rout_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::thickness "

Get thickness_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::thickness "

Get thickness_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::thickness "

Set thickness_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::thickness "

Set thickness_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::dir "

Get dir_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::dir "

Set dir_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::corotating "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::corotating "

Get dir_==1. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::velocityKind
"

Set dir_=t?1:-1.

Get VelocityKind ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::velocityKind
"

Set VelocityKind. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskIronLine::projectedRadius "

Projected radius of position coord on the equatorial plane. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::sphericalPhi
"

Longitude. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskIronLine::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::opticallyThin
"

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::opticallyThin
"

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::showshadow "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::showshadow "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::redshift "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::redshift "";

%feature("docstring")
Gyoto::Astrobj::ThinDiskIronLine::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::setParameters
"

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskIronLine::processHitQuantities "

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskIronLine::processHitQuantities "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::radiativeQ "

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskIronLine::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskIronLine::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskIronLine::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")
Gyoto::Astrobj::ThinDiskIronLine::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::transmission
"

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::transmission
"

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::transmission
"

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::getSinCos2Chi
"

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::computeB4vect
"

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskIronLine::computeB4vect_ipole "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::isThreadSafe
"

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::fillProperty
"

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::setParameter
"

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::setParameter
"

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskIronLine::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskIronLine::kind "

Get kind_. ";


// File: class_gyoto_1_1_astrobj_1_1_thin_disk_p_l.xml
%feature("docstring") Gyoto::Astrobj::ThinDiskPL "

Geometrically thin disk with black-body emission.

Temperature varies with a power-law from the inner radius outwards:

=0 (rcur/rinner)

C++ includes: GyotoThinDiskPL.h ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::ThinDiskPL "

Standard constructor. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::ThinDiskPL "

Copy constructor. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::clone "

Cloner. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::~ThinDiskPL "

Destructor. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::Slope "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::Slope "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::Tinner "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::Tinner "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::emission "

Specific intensity I

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem, in the emitter's frame. It should take self-absorption
along dsem into account.

Reminder : intensity = I [J m^-2 s^-1 ster^-1 Hz^-1];

invariant intensity = I/3, which has the same value in any frame;

emission coefficient = j [J m^-3 s^-1 ster^-1 Hz^-1] , defined by dI =
j*ds, where ds is the distance travelled by the photon inside the
object;

invariant emission coef = j/2, which has the same value in any frame.

The equation used for radiative transfer (without absorption) is:

d(I/3)/d = (j/2) [*]

where is the integration parameter along the null geodesic.

NB: Let us consider a particular observer, with being the frequency
measured by this observer, and ds being the proper distance (as
measured by the observer) that the photon travels as it moves from
to+d along its geodesic. Then it can be shown that:

d = ds/

This shows that Eq. [*] is homogeneous.

The default implementation returns 1. if optically thick and dsem if
optically thin. It allows for a quick implementation of your object
for visualization purposes.

Parameters:
-----------

nu_em:  Frequency at emission [Hz]

dsem:  length over which to integrate inside the object [geometrical
units]

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::innerRadius "

Get rin_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::innerRadius "

Get rin_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::innerRadius "

Set rin_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::innerRadius "

Set rin_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::outerRadius "

Get rout_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::outerRadius "

Get rout_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::outerRadius "

Set rout_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::outerRadius "

Set rout_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::thickness "

Get thickness_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::thickness "

Get thickness_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::thickness "

Set thickness_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::thickness "

Set thickness_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::dir "

Get dir_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::dir "

Set dir_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::corotating "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::corotating "

Get dir_==1. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::velocityKind "

Set dir_=t?1:-1.

Get VelocityKind ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::velocityKind "

Set VelocityKind. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::projectedRadius "

Projected radius of position coord on the equatorial plane. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::sphericalPhi "

Longitude. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::getVelocity "

Get fluid 4-velocity at point.

Fill vel with the 4-vector velocity of the fluid at 4-position pos.
getVelocity() should work at some distance from the equatorial plane.
The default implementation calls Metric::Generic::circularVelocity().

Parameters:
-----------

pos:  4-position at which to compute velocity;

vel:  4-velocity at pos. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskPL::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::showshadow "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::showshadow "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::redshift "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::redshift "";

%feature("docstring")
Gyoto::Astrobj::ThinDiskPL::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskPL::processHitQuantities "

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskPL::processHitQuantities "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::radiativeQ "

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::computeB4vect_ipole
"";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskPL::kind "

Get kind_. ";


// File: class_gyoto_1_1_astrobj_1_1_thin_disk_profile.xml
%feature("docstring") Gyoto::Astrobj::ThinDiskProfile "

A subclass of ThinDisk emitting according to some specified profile
that should be hardcoded in emission()

C++ includes: GyotoThinDiskProfile.h ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::getProperties
"

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskProfile::ThinDiskProfile "

Standard constructor. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskProfile::ThinDiskProfile "

Copy constructor. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::clone "

Cloner. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskProfile::~ThinDiskProfile "

Destructor. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::circularMotion
"";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::circularMotion
"";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::model_param "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::model_param "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::emission "

Specific intensity I

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem, in the emitter's frame. It should take self-absorption
along dsem into account.

Reminder : intensity = I [J m^-2 s^-1 ster^-1 Hz^-1];

invariant intensity = I/3, which has the same value in any frame;

emission coefficient = j [J m^-3 s^-1 ster^-1 Hz^-1] , defined by dI =
j*ds, where ds is the distance travelled by the photon inside the
object;

invariant emission coef = j/2, which has the same value in any frame.

The equation used for radiative transfer (without absorption) is:

d(I/3)/d = (j/2) [*]

where is the integration parameter along the null geodesic.

NB: Let us consider a particular observer, with being the frequency
measured by this observer, and ds being the proper distance (as
measured by the observer) that the photon travels as it moves from
to+d along its geodesic. Then it can be shown that:

d = ds/

This shows that Eq. [*] is homogeneous.

The default implementation returns 1. if optically thick and dsem if
optically thin. It allows for a quick implementation of your object
for visualization purposes.

Parameters:
-----------

nu_em:  Frequency at emission [Hz]

dsem:  length over which to integrate inside the object [geometrical
units]

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::getVelocity "

Get fluid 4-velocity at point.

Fill vel with the 4-vector velocity of the fluid at 4-position pos.
getVelocity() should work at some distance from the equatorial plane.
The default implementation calls Metric::Generic::circularVelocity().

Parameters:
-----------

pos:  4-position at which to compute velocity;

vel:  4-velocity at pos. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskProfile::processHitQuantities "

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::innerRadius "

Get rin_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::innerRadius "

Get rin_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::innerRadius "

Set rin_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::innerRadius "

Set rin_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::outerRadius "

Get rout_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::outerRadius "

Get rout_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::outerRadius "

Set rout_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::outerRadius "

Set rout_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::thickness "

Get thickness_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::thickness "

Get thickness_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::thickness "

Set thickness_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::thickness "

Set thickness_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::dir "

Get dir_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::dir "

Set dir_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::corotating "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::corotating "

Get dir_==1. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::velocityKind "

Set dir_=t?1:-1.

Get VelocityKind ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::velocityKind "

Set VelocityKind. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskProfile::projectedRadius "

Projected radius of position coord on the equatorial plane. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::sphericalPhi "

Longitude. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskProfile::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::opticallyThin
"

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::opticallyThin
"

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::showshadow "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::showshadow "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::redshift "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::redshift "";

%feature("docstring")
Gyoto::Astrobj::ThinDiskProfile::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::setParameters
"

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskProfile::processHitQuantities "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::radiativeQ "

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskProfile::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskProfile::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskProfile::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")
Gyoto::Astrobj::ThinDiskProfile::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::getSinCos2Chi
"

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::computeB4vect
"

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskProfile::computeB4vect_ipole "";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")
Gyoto::Astrobj::ThinDiskProfile::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::ThinDiskProfile::kind "

Get kind_. ";


// File: class_gyoto_1_1_astrobj_1_1_torus.xml
%feature("docstring") Gyoto::Astrobj::Torus "

Optically thin or thick torus in circular rotation.

Any Metric::Generic is acceptable as long as it implements
Metric::Generic::circularVelocity().

C++ includes: GyotoTorus.h ";

%feature("docstring")  Gyoto::Astrobj::Torus::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Astrobj::Torus::Torus "

Default constructor.

kind_ = \"Torus\", c_ = 3.5, a_=0.5 ";

%feature("docstring")  Gyoto::Astrobj::Torus::Torus "

Copy constructor. ";

%feature("docstring")  Gyoto::Astrobj::Torus::clone "

\"Virtual\" copy constructor ";

%feature("docstring")  Gyoto::Astrobj::Torus::~Torus "

Destructor: does nothing. ";

%feature("docstring")  Gyoto::Astrobj::Torus::largeRadius "

Get large radius Torus::c_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Torus::largeRadius "

Get large radius Torus::c_ in specified unit ";

%feature("docstring")  Gyoto::Astrobj::Torus::smallRadius "

Get small radius in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Torus::smallRadius "

Get small radius in specified unit ";

%feature("docstring")  Gyoto::Astrobj::Torus::largeRadius "

Set large radius Torus::c_. ";

%feature("docstring")  Gyoto::Astrobj::Torus::smallRadius "

Set small radius. ";

%feature("docstring")  Gyoto::Astrobj::Torus::largeRadius "

Set large radius Torus::c_ in specified unit. ";

%feature("docstring")  Gyoto::Astrobj::Torus::smallRadius "

Set small radius in specified unit. ";

%feature("docstring")  Gyoto::Astrobj::Torus::spectrum "

Set Torus::spectrum_. ";

%feature("docstring")  Gyoto::Astrobj::Torus::spectrum "

Get Torus::spectrum_. ";

%feature("docstring")  Gyoto::Astrobj::Torus::opacity "

Set Torus::opacity_. ";

%feature("docstring")  Gyoto::Astrobj::Torus::opacity "

Get Torus::opacity_. ";

%feature("docstring")  Gyoto::Astrobj::Torus::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Torus::deltaMax "";

%feature("docstring")  Gyoto::Astrobj::Torus::safetyValue "

Set Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::Torus::safetyValue "

Get Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::Torus::deltaInObj "

Get Generic::delta_inobj_.

Get the constant integration step inside the astrobj

delta_inobj_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Torus::deltaInObj "

Set Generic::delta_inobj_. ";

%feature("docstring")  Gyoto::Astrobj::Torus::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::Torus::giveDelta "

Maximum inside object.

Gives the requested integration stept (in coordinate time t) between
two neighbooring points along a portion of geodesic inside an astrobj;
the current implementation only considers a constant delta, equal to
Standard::deltaInobj()

Parameters:
-----------

coord:  input coordinate at whicht is given ";

%feature("docstring")  Gyoto::Astrobj::Torus::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::Torus::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::Torus::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::Torus::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::Torus::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::Torus::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::Torus::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")  Gyoto::Astrobj::Torus::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")
Gyoto::Astrobj::Torus::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::Torus::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")  Gyoto::Astrobj::Torus::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::Torus::showshadow "";

%feature("docstring")  Gyoto::Astrobj::Torus::showshadow "";

%feature("docstring")  Gyoto::Astrobj::Torus::redshift "";

%feature("docstring")  Gyoto::Astrobj::Torus::redshift "";

%feature("docstring")  Gyoto::Astrobj::Torus::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")  Gyoto::Astrobj::Torus::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")  Gyoto::Astrobj::Torus::processHitQuantities "

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")  Gyoto::Astrobj::Torus::processHitQuantities "";

%feature("docstring")  Gyoto::Astrobj::Torus::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::Torus::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::Torus::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Torus::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::Torus::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")  Gyoto::Astrobj::Torus::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Torus::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")  Gyoto::Astrobj::Torus::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Torus::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Torus::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Torus::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::Torus::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::Torus::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Torus::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Torus::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::Torus::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::Torus::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::Torus::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::Torus::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::Torus::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::Torus::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")  Gyoto::Astrobj::Torus::computeB4vect_ipole "";

%feature("docstring")  Gyoto::Astrobj::Torus::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::Torus::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::Torus::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::Torus::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::Torus::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::Torus::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::Torus::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Torus::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Torus::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Torus::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Torus::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Torus::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::Torus::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::Torus::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::Torus::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::Torus::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Astrobj::Torus::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Astrobj::Torus::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Astrobj::Torus::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Astrobj::Torus::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::Torus::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::Torus::kind "

Get kind_. ";


// File: class_gyoto_1_1_spectrometer_1_1_uniform.xml
%feature("docstring") Gyoto::Spectrometer::Uniform "

Uniformly spaced spectrometers.

Spectral channels are contiguous and uniformly spaced in either
wavelength, frequency or log10 of either. Gyoto::Spectrometer::Uniform
is registered four times in the factory: as kind=\"wave\",
\"wavelog\", \"freq\" and \"freqlog\". Example XML entity:

The content of the entity yields the band pass expressed in \"unit\"
or in log10(unit).

C++ includes: GyotoUniformSpectrometer.h ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::Uniform "

Default constructor. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::Uniform "

Constructor setting everything. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::Uniform "

Copy constructor. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::clone "

Cloner. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::~Uniform "

Destructor. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::kindid "

Set Generic::kindid_.

This should rarely be used as the Generic::kindid_ attribute usually
is set in the constructor and doesn't change after that.

Always set to the address of a static variable, not to a temporary.
Usually your class should have a static member for that purpose: ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::kind "

Set Generic::kind_ from a std::string.

Generic::kind_ will actually be set to one of Uniform::WaveKind,
Uniform::WaveLogKind, Uniform::FreqKind or Uniform::FreqLogKind.

Parameters:
-----------

name:  std::string, one of \"wave\", \"wavelog\", \"freq\" or
\"freqlog\" ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::kind "

Get kind_. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::nSamples "

Set Generic::nsamples_. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::band "";

%feature("docstring")  Gyoto::Spectrometer::Uniform::band "";

%feature("docstring")  Gyoto::Spectrometer::Uniform::band "";

%feature("docstring")  Gyoto::Spectrometer::Uniform::band "";

%feature("docstring")  Gyoto::Spectrometer::Uniform::band "

Set Uniform::band_.

Parameters:
-----------

nu:  2-element vector, in Hz, m, log10(Hz) or log10(m) depending on
Generic::kind_ ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::band "

Set the spectral band boundaries in specified unit.

If kind is not specified, member kind_ is used. Else kind_ is updated.

unit is actually the unit for 10^nu for freqlog and wavelog. Defaults:
kind==freq: nu in Hz

kind==freqlog: 10^nu in Hz

kind==wave: nu in meters

kind==wavelog: 10^nu in meters ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::band "";

%feature("docstring")  Gyoto::Spectrometer::Uniform::getBand "

Get Uniform::band_. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::setParameters "

Main loop for parsing Properties from XML description.

This function queries the FactoryMessenger for elements to parse, and
tries to matche each element to a Property to set it  accordingly. Any
class that tries to be buildable from XML must supply a subcontractor
(for base classes such as Metric, Astrobj, Spectrum  and Spectrometer,
it is done as a template that must be  specialized for each class).
This subcontractor typically looks somewhat like this: Although this
is discouraged, it is possible to override the following functions to
customize how XML entities are parsed:    - setParameters() if low-
level access to the      FactoryMessenger is required;    -
setParameter(std::string name, std::string content,
std::string unit)      to interpret an entity that does not match a
Property      (e.g. alternative name);    -
setParameter(Gyoto::Property const &p, std::string const &name,
std::string const &content, std::string const &unit)      to change
how a Property is interpreted. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::kindid "

Get kindid_.

You can check whether the Spectrometer sp is of a given kind MyKind
with something like:

See Uniform::WaveKind, Uniform::WaveLogKind, Uniform::FreqKind,
Uniform::FreqLogKind and Complex::Kind. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::kindid "

Set Generic::kindid_.

This should rarely be used as the Generic::kindid_ attribute usually
is set in the constructor and doesn't change after that.

Always set to the address of a static variable, not to a temporary.
Usually your class should have a static member for that purpose: ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::nSamples "

Get Generic::nsamples_. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::kindid "

Get kindid_.

You can check whether the Spectrometer sp is of a given kind MyKind
with something like:

See Uniform::WaveKind, Uniform::WaveLogKind, Uniform::FreqKind,
Uniform::FreqLogKind and Complex::Kind. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::nSamples "

Get Generic::nsamples_. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::getNBoundaries "

Get Generic::nboundaries_. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::getMidpoints "

Get Generic::midpoints_. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::getMidpoints "

Copy Generic::midpoints_, converting to unit.

Parameters:
-----------

data:  an array of Generic::nsamples_ doubles to fill with result

unit:  a string ";

%feature("docstring")
Gyoto::Spectrometer::Uniform::getChannelBoundaries "

Copy Generic::boundaries_, converting to unit.

Parameters:
-----------

data:  an array of Generic::nboundaries_ doubles to fill with result

unit:  a string ";

%feature("docstring")
Gyoto::Spectrometer::Uniform::getChannelBoundaries "

Get Generic::boundaries_. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::getChannelIndices
"

Get Generic::chanind_. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::getWidths "

Get Generic::widths_. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::getWidths "

Copy Generic::widths_, converting to unit.

Think carefully before using: widths are often used to convert
spectral flux density to flux. If flux density is per Herz, you don't
need to convert widths.

Parameters:
-----------

data:  an array of Generic::nboundaries_ doubles to fill with result

unit:  a string ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Spectrometer::Uniform::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::describeProperty
"

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::hook "

Start listening.

Use from a Hook::Listener object method: where \"this\" is a Listener
and \"teller\" is a Teller.

Use unhook() later to stop listening to a given Teller.

Parameters:
-----------

listener:  pointer to the new listener ";

%feature("docstring")  Gyoto::Spectrometer::Uniform::unhook "

Stop listening.

Use from a Hook::Listener object method:

where \"this\" is a Listener, \"teller\" is a Teller, and \"this\" has
called teller->hook(this) previously.

Parameters:
-----------

listener:  pointer to the listener ";


// File: class_gyoto_1_1_astrobj_1_1_uniform_sphere.xml
%feature("docstring") Gyoto::Astrobj::UniformSphere "

Optically thick or thin, spherical objects.

Gyoto::Astrobj::UniformSphere is an abstract type from which uniform,
spherical objects inherit (in particular, the Gyoto::Astrobj::Star and
Gyoto::Astrobj::FixedStar classes).

These objects are coordinate-spherical: they comprise all the points
within a given radius from a centre. The distance is the usual
Euclidian distance in a Cartesian coordinate system which is trivially
determined by the coordinate system in which the Metric is expressed.

The sphere is in solid motion: all the points have the same
4-velocity. The centre of the sphere may move. This motion and the
velocity are provided by the derived classes through the
getCartesian() and getVelocity() methods.

The spheres can be optically thick or optically thin. In the optically
thin case, the opacity law provided as a Gyoto::Spectrum also sets
both the emissivity. Another Gyoto::Spectrum provides the emission law
of the source, which is uniform.

Gyoto::Astrobj::UniformSphere::setParameters() take care of
interpreting the XML elements describing the parameters of the sphere:
setGenericParameters() also takes care of calling setParameter().

C++ includes: GyotoUniformSphere.h ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::UniformSphere "

Standard constructor.

Create UniformSphere object.

Parameters:
-----------

kind:  specifi kind (e.g. \"Star\" or \"FixedStar\")

gg:   Gyoto::SmartPointer to the Gyoto::Metric in this part of the
Universe

radius:  sphere radius ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::UniformSphere "

Default constructor.

Create UniformSphere object. Use metric(), radius(), spectrum() and
opacity() to set the members.

Parameters:
-----------

kind:  specify kind (e.g. \"Star\" or \"FixedStar\") ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::UniformSphere "

Copy constructor. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::~UniformSphere "

Destructor. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::className "

\"UniformSphere\" ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::className_l "

\"uniformsphere\" ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::spectrum "

Set spectrum_. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::spectrum "

Get spectrum_. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::opacity "

Set opacity_. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::opacity "

Get opacity_. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::radius "

Get radius_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::radius "

Set radius_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::radius "

Get radius_ in specified unit. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::radius "

Set radius_ in specified unit. ";

%feature("docstring")
Gyoto::Astrobj::UniformSphere::deltaMaxOverRadius "

Get dltmor_. ";

%feature("docstring")
Gyoto::Astrobj::UniformSphere::deltaMaxOverRadius "

Set dltmor_. ";

%feature("docstring")
Gyoto::Astrobj::UniformSphere::deltaMaxOverDistance "

Get dltmod_. ";

%feature("docstring")
Gyoto::Astrobj::UniformSphere::deltaMaxOverDistance "

Set dltmod_. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::isotropic "";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::isotropic "";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::alpha "";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::alpha "";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::deltaMax "

Parameters:

coord:  current photon position

max( dltmor_* radius_, dltmod_*operator()(double coord[]) ) ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::safetyValue "

Set Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::safetyValue "

Get Standard::safety_value_. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::deltaInObj "

Get Generic::delta_inobj_.

Get the constant integration step inside the astrobj

delta_inobj_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::deltaInObj "

Set Generic::delta_inobj_. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::giveDelta "

Maximum inside object.

Gives the requested integration stept (in coordinate time t) between
two neighbooring points along a portion of geodesic inside an astrobj;
the current implementation only considers a constant delta, equal to
Standard::deltaInobj()

Parameters:
-----------

coord:  input coordinate at whicht is given ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::clone "

Cloner.

This method must be implemented by the various Astrobj::Generic
subclasses in order to support cloning:

Cloning is necessary for multi-threading, recommended for interaction
with the Yorick plug-in etc.

Implementing it is very straightforward, as long as the copy
constructor Generic(const Generic& ) has been implemented: ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")
Gyoto::Astrobj::UniformSphere::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::showshadow "";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::showshadow "";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::redshift "";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::redshift "";

%feature("docstring")
Gyoto::Astrobj::UniformSphere::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")
Gyoto::Astrobj::UniformSphere::processHitQuantities "

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")
Gyoto::Astrobj::UniformSphere::processHitQuantities "";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::radiativeQ "

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")
Gyoto::Astrobj::UniformSphere::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")
Gyoto::Astrobj::UniformSphere::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::UniformSphere::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")
Gyoto::Astrobj::UniformSphere::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::transmission "

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::transmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")
Gyoto::Astrobj::UniformSphere::computeB4vect_ipole "";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::interpolate "

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::incRefCount "

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::decRefCount "

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::getRefCount "

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::isThreadSafe "

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::fillProperty "

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::fillElement "

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::setParameter "

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::setParameter "

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::describeProperty
"

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::UniformSphere::kind "

Get kind_. ";


// File: class_gyoto_1_1_value.xml
%feature("docstring") Gyoto::Value "

Container for the value of a Property.

The Value class is very similar to the C union type (although not as
memory efficient): it can hold several type of values, but only one at
a time. Care must be taken to ensure only the member that was set is
retrieved. The purpose of the Value class is to be used together with
the Property class: code determines dynamicaly the type of a Property,
reads the corresponding value appropriateley (e.g. from XML or from
the Yorick prompt), stores the value in a Value instance, and sets the
Property using the Object::set() method. Likewise, the Object::get()
method returns a Gyoto::Value. Property::type must be used to
determine which member of the Value is meaningful.

Casting between Value and the various data type it can hold is
normally automatic, but the members can also be accessed explicitly
make code more easy to read and less ambiguous.

C++ includes: GyotoValue.h ";

%feature("docstring")  Gyoto::Value::Value "

Constructor. ";

%feature("docstring")  Gyoto::Value::~Value "

Destructor. ";

%feature("docstring")  Gyoto::Value::Value "

Construct/cast from double. ";

%feature("docstring")  Gyoto::Value::Value "

Construct/cast from boolean. ";

%feature("docstring")  Gyoto::Value::Value "

Construct/cast from long. ";

%feature("docstring")  Gyoto::Value::Value "

Construct/cast from unsigned long. ";

%feature("docstring")  Gyoto::Value::Value "

Construct/cast from string. ";

%feature("docstring")  Gyoto::Value::Value "

Construct/cast from vector of doubles. ";

%feature("docstring")  Gyoto::Value::Value "

Construct/cast from vector of unsigned long values. ";

%feature("docstring")  Gyoto::Value::Value "

Cast from Metric object. ";

%feature("docstring")  Gyoto::Value::Value "

Cast from Astrobj. ";

%feature("docstring")  Gyoto::Value::Value "

Cast from Spectrum. ";

%feature("docstring")  Gyoto::Value::Value "

Cast from Spectrometer. ";

%feature("docstring")  Gyoto::Value::Value "

Cast from Screen. ";


// File: class_gyoto_1_1_w_i_p.xml
%feature("docstring") Gyoto::WIP "

Base class for work in progress.

The constructors of this class simply issue a warning that the
(derived) class is work in progress.

C++ includes: GyotoWIP.h ";

%feature("docstring")  Gyoto::WIP::WIP "

Issue a warning. ";

%feature("docstring")  Gyoto::WIP::WIP "

Issue a warning specifying the name of the derived class.

If classname is the empty string (\"\"), the warning is not issued.
Use this to mark that a class is no more work in progress without
breaking the ABI (i.e. in the Gyoto stable branch). ";


// File: class_gyoto_1_1_worldline.xml
%feature("docstring") Gyoto::Worldline "

Timelike or null geodesics.

Their are two derived classes: Photon and Star. A Worldline can be
integrated from an initial condition either backward or forward in
time using xFill() ( Photon::hit() also integrates the Worldline).
Member state_ holds the integration state as well as an integrator.
There are several kinds of integration states, that derive from
IntegState::Generic.

The coordinates of the Worldline are stored in x0_, x1_, x2_, x3_,
x0dot_, x1dot_, x2dot_ ans x3dot_. Those arrays are extended as needed
using xExpand(). These coordinates can be retrieved using get_t(),
get_xyz(), getCartesian(), getCoord() etc.

Worldline does not derive from Object, and does not instantiate a
Property list. This is because this would lead to multiple inheritance
of the Object base in derived classes. Instead, #GyotoWorldline.h
provides a few macros that can be used to include the Worldline
properties in a derived classe's Property list:  GYOTO_WORLDLINE is to
be used in a public section of the derived class declaration (.h
file); it declares wrappers around the Worldline property accessors;

GYOTO_WORLDLINE_ACCESSORS is to be used with the class definition (.C
file; it defines the accessors declared by GYOTO_WORLDLINE;

GYOTO_WORLDLINE_PROPERTIES declares the Properties that use these
accessors. It must be used like e.g. GYOTO_PROPERTY_DOUBLE, between
GYOTO_PROPERTY_START andf GYOTO_PROPERTY_END.

Finally, GYOTO_WORLDLINE_PROPERTY_END is a drop-in replacement for
GYOTO_PROPERTY_END that calls GYOTO_WORLDLINE_PROPERTIES and
GYOTO_WORLDLINE_ACCESSORS.

C++ includes: GyotoWorldline.h ";

%feature("docstring")  Gyoto::Worldline::Worldline "

Default constructor. ";

%feature("docstring")  Gyoto::Worldline::Worldline "

Copy constructor. ";

%feature("docstring")  Gyoto::Worldline::Worldline "

Refine constructor.

Meant to instantiate a copy of orig with a smaller step to refine
integration, for instance for more accurate radiative transfer
integration.

See Photon::Photon(Photon* orig, size_t i0, int dir, double step_max)
and Photon::Refined.

Parameters:
-----------

orig:   Worldline to refine

i0:  Index of coordinate in orig to take as initial condition

dir:  Direction of integration

step_max:  Maximum integration step ";

%feature("docstring")  Gyoto::Worldline::~Worldline "

Destructor. ";

%feature("docstring")  Gyoto::Worldline::getImin "

Get imin_. ";

%feature("docstring")  Gyoto::Worldline::getImax "

Get imax_. ";

%feature("docstring")  Gyoto::Worldline::getI0 "

Get i0_. ";

%feature("docstring")  Gyoto::Worldline::getMass "

Get mass of particule. ";

%feature("docstring")  Gyoto::Worldline::metric "

Set metric Smartpointer. ";

%feature("docstring")  Gyoto::Worldline::metric "

Get metric. ";

%feature("docstring")  Gyoto::Worldline::initCoord "";

%feature("docstring")  Gyoto::Worldline::initCoord "";

%feature("docstring")  Gyoto::Worldline::setInitCoord "

Set Initial coordinate.

Set imin_= imax_= i0_, and x  [i0]=coord[ ].

If dir==1, i0_ is set to 0. If dir==-1, i0_ is set to x_size_-1.

If dir==0 and the Worldine has never been computed ( i0_==0, imin_==1
and imax_==0), then dir defaults to 1 for a massive particle and -1
for a massless particle.

If dir==0 and the Worldine has already been computed, i0_ is not
changed.



Parameters:
-----------

coord:  new initial coordinates

dir:  direction of integration. 1 for forward integration, -1 for
backards integration, 0 for unknown or both

Ephi:  initial value of base vector to parallel-transport. Ignored if
parallel_transport_ is false.

Etheta:  initial value of base vector to parallel-transport. Ignored
if parallel_transport_ is false. ";

%feature("docstring")  Gyoto::Worldline::setInitCoord "

Set Initial coordinate.

Set imin_= imax_= i0_, and x  [i0]=coord[ ].

If dir==1, i0_ is set to 0. If dir==-1, i0_ is set to x_size_-1.

If dir==0 and the Worldine has never been computed ( i0_==0, imin_==1
and imax_==0), then dir defaults to 1 for a massive particle and -1
for a massless particle.

If dir==0 and the Worldine has already been computed, i0_ is not
changed.



Parameters:
-----------

coord:  new initial coordinates

dir:  direction of integration. 1 for forward integration, -1 for
backards integration, 0 for unknown or both ";

%feature("docstring")  Gyoto::Worldline::setInitCoord "

Set initial coordinate.

Parameters:
-----------

pos:  initial 4-position

vel:  initial 3-velocity

dir:  direction of integration ";

%feature("docstring")  Gyoto::Worldline::setPosition "

Set initial 4-position. ";

%feature("docstring")  Gyoto::Worldline::setVelocity "

Set initial 3-velocity. ";

%feature("docstring")  Gyoto::Worldline::reset "

Forget integration, keeping initial contition. ";

%feature("docstring")  Gyoto::Worldline::reInit "

Reset and recompute particle properties. ";

%feature("docstring")  Gyoto::Worldline::className "

\"Worldline\" ";

%feature("docstring")  Gyoto::Worldline::className_l "

\"worldline\" ";

%feature("docstring")  Gyoto::Worldline::integrator "

Set the integrator.

Initialize state_ to use the required integrator.

Parameters:
-----------

type:  Either \"Legacy\" or (if GYOTO_HAVE_BOOST_INTEGRATORS) one of
\"runge_kutta_cash_karp54\", \"runge_kutta_fehlberg78\",
\"runge_kutta_dopri5\", \"runge_kutta_cash_karp54_classic\" ";

%feature("docstring")  Gyoto::Worldline::integrator "

Describe the integrator used by state_. ";

%feature("docstring")  Gyoto::Worldline::integ31 "

Set the integrator kind to 3+1 or 4D.

Initialize state_ to use the required geodesic equation. ";

%feature("docstring")  Gyoto::Worldline::integ31 "

Get the kind of geodesic equation integrated by state_. ";

%feature("docstring")  Gyoto::Worldline::deltaMin "

Get delta_min_. ";

%feature("docstring")  Gyoto::Worldline::deltaMin "

Set delta_min_. ";

%feature("docstring")  Gyoto::Worldline::deltaMax "

Get delta_max_. ";

%feature("docstring")  Gyoto::Worldline::absTol "

Set abstol_. ";

%feature("docstring")  Gyoto::Worldline::absTol "

Get abstol_. ";

%feature("docstring")  Gyoto::Worldline::relTol "

Set reltol_. ";

%feature("docstring")  Gyoto::Worldline::relTol "

Get reltol_. ";

%feature("docstring")  Gyoto::Worldline::maxCrossEqplane "

Set #maxCrosEqplane_. ";

%feature("docstring")  Gyoto::Worldline::maxCrossEqplane "

Get maxCrossEqplane_. ";

%feature("docstring")  Gyoto::Worldline::deltaMax "

Get delta max at a given position

Parameters:
-----------

pos:  4-position

delta_max_external:  external constraint on delta_max

the smallest value between delta_max_, delta_max_external, and R*
delta_max_over_r_ where R is pos[1] in spherical coordinates and
max(x1, x2, x3) in Cartesian coordinates. ";

%feature("docstring")  Gyoto::Worldline::deltaMax "

Set delta_max_ ";

%feature("docstring")  Gyoto::Worldline::deltaMaxOverR "

Get delta_max_over_r_. ";

%feature("docstring")  Gyoto::Worldline::deltaMaxOverR "

Set delta_max_over_r_. ";

%feature("docstring")  Gyoto::Worldline::delta "

Expand memory slots for polarization vectors.

Assignment to another Worldline Set delta_ ";

%feature("docstring")  Gyoto::Worldline::delta "

Set delta_ in specified units. ";

%feature("docstring")  Gyoto::Worldline::delta "

Get delta_. ";

%feature("docstring")  Gyoto::Worldline::delta "

Get delta_ in specified units. ";

%feature("docstring")  Gyoto::Worldline::tMin "

Get tmin_. ";

%feature("docstring")  Gyoto::Worldline::tMin "

Get tmin_ in specified unit. ";

%feature("docstring")  Gyoto::Worldline::tMin "

Set tmin_. ";

%feature("docstring")  Gyoto::Worldline::tMin "

Set tmin_ in specified unit. ";

%feature("docstring")  Gyoto::Worldline::adaptive "

Set adaptive_. ";

%feature("docstring")  Gyoto::Worldline::adaptive "

Get adaptive_. ";

%feature("docstring")  Gyoto::Worldline::secondary "

Set secondary_. ";

%feature("docstring")  Gyoto::Worldline::secondary "

Get secondary_. ";

%feature("docstring")  Gyoto::Worldline::parallelTransport "

Set parallel_transport_. ";

%feature("docstring")  Gyoto::Worldline::parallelTransport "

Get parallel_transport_. ";

%feature("docstring")  Gyoto::Worldline::maxiter "

Set maxiter_. ";

%feature("docstring")  Gyoto::Worldline::maxiter "

Get maxiter_. ";

%feature("docstring")  Gyoto::Worldline::getCst "

Returns the worldline's cst of motion (if any)

Return pointer to array holding the previously set Metric-specific
constants of motion.

This function returns a pointer to the actual storage location and
should be handled with care. std::vector<double> Worldline:
constantsOfMotion() constprovides a convenient way to retrieve a copy
of the content. ";

%feature("docstring")  Gyoto::Worldline::setCst "

Set Metric-specific constants of motion.

The will (re)allocate Worldline::cst_, copy cst into it, and set
Worldline::cst_n_.

This is the same as void Worldline:
constantsOfMotion(std::vector<double> const cstv) using a C-style
array instead of a vector. ";

%feature("docstring")  Gyoto::Worldline::constantsOfMotion "

Set Metric-specific constants of motion.

The will (re)allocate Worldline::cst_, copy cst into it, and set
Worldline::cst_n_.

This is the same as getCst using a vector instead of a C-style array.
";

%feature("docstring")  Gyoto::Worldline::constantsOfMotion "

Return a copy of the Metric-specific constants of motion.

This funtion return a copy of the constants of motion. getCst() can be
used to retrieve a pointer to the actual array used internally which
is slightly more efficient for read-only access. ";

%feature("docstring")  Gyoto::Worldline::setInitialCondition "

Set or re-set the initial condition prior to integration.

Parameters:
-----------

gg:   Gyoto::SmartPointer to the Gyoto::Metric in this universe;

coord:  8 element array containing the initial condition, i.e. the
4-position and the 4-velocity of the Photon at the receiving end;

dir:  direction: 1 for future, -1 for past.

Ephi:  initial value of base vector to parallel-transport. Ignored if
parallel_transport_ is false.

Etheta:  initial value of base vector to parallel-transport. Ignored
if parallel_transport_ is false. ";

%feature("docstring")  Gyoto::Worldline::setInitialCondition "

Set or re-set the initial condition prior to integration.

Parameters:
-----------

gg:   Gyoto::SmartPointer to the Gyoto::Metric in this universe;

coord:  8 element array containing the initial condition, i.e. the
4-position and the 4-velocity of the Photon at the receiving end;

dir:  direction: 1 for future, -1 for past. ";

%feature("docstring")  Gyoto::Worldline::getInitialCoord "

Get initial coordinates + base vectors.

Depending on the size of dest and on the value of parallel_transport_,
get position (xi_), velocity (xidot_) and possibly other triad vectors
(epi_ and eti_). ";

%feature("docstring")  Gyoto::Worldline::getCoord "

Get coordinates+base vectors corresponding to index.

Depending on the value of parallel_transport_, get position (xi_),
velocity (xidot_) and possibly other triad vectors (epi_ and eti_).
coord is resized to the right number of elements. ";

%feature("docstring")  Gyoto::Worldline::getCoord "

Get coordinates+base vectors corresponding to index.

We need this non-const implementation to allow the const, size_t and
the non-const, double implementations to coexist. ";

%feature("docstring")  Gyoto::Worldline::getCoord "

Get coordinates+base vectors corresponding to date dest[0].

Depending on the value of parallel_transport_, get position (xi_),
velocity (xidot_) and possibly other triad vectors (epi_ and eti_).
coord is resized to the right number of elements. ";

%feature("docstring")  Gyoto::Worldline::getCartesianPos "

Get Cartesian expression of 4-position at index. ";

%feature("docstring")  Gyoto::Worldline::xStore "

Store coord at index ind. ";

%feature("docstring")  Gyoto::Worldline::xStore "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Worldline::xStore "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Worldline::xFill "

Fill x0, x1... by integrating the Worldline from previously set
inittial condition to time tlim. ";

%feature("docstring")  Gyoto::Worldline::get_nelements "

Get number of computed dates. ";

%feature("docstring")  Gyoto::Worldline::get_t "

Get computed dates. ";

%feature("docstring")  Gyoto::Worldline::get_tau "

Get computed proper times or values of the affine parameter. ";

%feature("docstring")  Gyoto::Worldline::getCartesian "

Get the 6 Cartesian coordinates for specific dates.

The 6 coordinates (x, y, z, dx/dt, dy/dt, dz/dt) will be computed
using the integrator and interpolated if necessary, so they will be as
accurate as possible. Transforming to Cartesian coordinates is not
necessarily meaningful.

Parameters:
-----------

dates:  List of dates for which the coordinates are to be computed;

n_dates:  Number of dates to compute ;

x:  y:  z:  xprime:  yprime:  zprime:  Arrays in which to store the
result. These pointer may be set to NULL to retrieve only part of the
information. Else, they must be pre- allocated. ";

%feature("docstring")  Gyoto::Worldline::get_xyz "

Get 3-position in cartesian coordinates for computed dates. ";

%feature("docstring")  Gyoto::Worldline::getCoord "

Get 8-coordinates for specific dates.

The coordinates will be computed using the integrator, so they will be
as accurate as possible. Some heuristics are used to speed up the
process and it is presumably faster to call this routine with a sorted
list of dates. The line will be integrated further as required. An
error will be thrown if it is not possible to reach a certain date.

Parameters:
-----------

dates:  the list of dates for which the coordinates are to be computed
in proper time or affine parameter if #proper is true or in coordinate
time if #proper is false (default);

n_dates:  the number of dates to compute ;

x1dest:  x2dest:  x3dest:  x0dot:  x1dot:  x2dot:  x3dot:  arrays in
which to store the result. These pointer may be set to NULL to
retrieve only part of the information. They must be pre-allocated.

ephi0:  ephi1:  ephi2:  ephi3:  etheta0:  etheta1:  etheta2:  etheta3:
arrays in which to store the ephi and etheta (parallel transport
case). These pointer may be set to NULL to retrieve only part of the
information. They must be pre-allocated.

otime:  array in which to store the other time: coordinate time if
#proper, else proper time or affine parameter.

proper:  bool: whether #dates is proper time (or affine parameter) or
coordinate time. ";

%feature("docstring")  Gyoto::Worldline::getCoord "

Get all computed positions.

Get all the pre-computed 8 coordinates (e.g. thanks to a prior call to
xFill()) of this worldline. ";

%feature("docstring")  Gyoto::Worldline::checkPhiTheta "

Bring in [0,] and in [0,2].

checkPhiTheta() Modifies coord if the corrdinates are spherical-like
so that coord[2]=theta is in [0,pi] and coord[3]=phi is in [0,2pi].
Important to use in all astrobj in spherical coordinates to prevent
\"z-axis problems\". ";

%feature("docstring")  Gyoto::Worldline::getSkyPos "

Get computed positions in sky coordinates. ";

%feature("docstring")  Gyoto::Worldline::get_dot "

Get computed 4-velocities. ";

%feature("docstring")  Gyoto::Worldline::get_prime "

Get computed 3-velocities. ";

%feature("docstring")  Gyoto::Worldline::save_txyz "

Save in a file. ";

%feature("docstring")  Gyoto::Worldline::save_txyz "

Save, converted. ";


// File: class_gyoto_1_1_astrobj_1_1_xillver_reflection.xml
%feature("docstring") Gyoto::Astrobj::XillverReflection "

The illumination table specifies how the thin disk is illuminated
while the reflection table deduces from that the reflected spectrum as
computed by Javier Garcia's XILLVER code.

C++ includes: GyotoXillverReflection.h ";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::getProperties "

Get list of properties.

This method is declared automatically by the GYOTO_OBJECT macro and
defined automatically by the GYOTO_PROPERTY_END macro. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::fillProperty
"

Output a single Property to XML.

The base implementation decides what to do based on the p.type. The
format matches how setParameters() an setParameter() would interpret
the XML descition.

Overriding this method should be avoided, but makes sense in some
cases (for instance Screen::fillProperty() selects a different unit
for Distance based on its magnitude, so that stellar sizes are
expressed in solar radii while smaller sizes can be expressed in
meters and larger sizes in parsecs).

Overriding implementation should fall-back on calling the
implementation in the direct parent class: ";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::XillverReflection "

Standard constructor. ";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::XillverReflection "

Copy constructor. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::clone "

Cloner. ";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::~XillverReflection "

Destructor. ";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::timelampphizero "";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::timelampphizero "";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::lampradius "";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::lampradius "";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::fileillumination "";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::fileillumination "";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::filereflection "";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::filereflection "";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::averageOverAngle "";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::averageOverAngle "";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::setIllumination "

The pointer is copied directly, not the array content.

This is a low-level function. Beware that: previously allocated array
will not be freed automatically;

array attached when the destructor is called will be freed. ";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::setReflection "";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::copyIllumination "

XillverReflection::emission_ is freed if not NULL, reallocated, and
pattern is copied into emission_.

Finally, XillverReflection::nnu_, XillverReflection::ni_, and
XillverReflection::nsg_ are set according to naxes.

Parameters:
-----------

pattern:  Array to copy as emission_. May be NULL in which case
emission_ is simply deallocated and set to NULL.

naxes:  { nnu_, ni_, nsg_ }. ";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::getIllumination "";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::getIlluminationNaxes "

Get XillverReflection::nr_, XillverReflection::nphi_. ";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::copyReflection "";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::getReflection "";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::getReflectionNaxes "

Get XillverReflection::nnu_, XillverReflection::ni_,
XillverReflection::nxi_. ";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::copyGridReflLogxi "";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::getGridReflLogxi "

Get XillverReflection::logxi_. ";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::copyGridReflIncl "";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::getGridReflIncl "

Get XillverReflection::incl_. ";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::copyGridReflFreq "";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::getGridReflFreq "

Get XillverReflection::freq_. ";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::copyGridIllumRadius "";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::getGridIllumRadius "

Get XillverReflection::radius_. ";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::copyGridIllumPhi "";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::getGridIllumPhi "

Get XillverReflection::phi_. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::emission "

Specific intensity I

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem, in the emitter's frame. It should take self-absorption
along dsem into account.

Reminder : intensity = I [J m^-2 s^-1 ster^-1 Hz^-1];

invariant intensity = I/3, which has the same value in any frame;

emission coefficient = j [J m^-3 s^-1 ster^-1 Hz^-1] , defined by dI =
j*ds, where ds is the distance travelled by the photon inside the
object;

invariant emission coef = j/2, which has the same value in any frame.

The equation used for radiative transfer (without absorption) is:

d(I/3)/d = (j/2) [*]

where is the integration parameter along the null geodesic.

NB: Let us consider a particular observer, with being the frequency
measured by this observer, and ds being the proper distance (as
measured by the observer) that the photon travels as it moves from
to+d along its geodesic. Then it can be shown that:

d = ds/

This shows that Eq. [*] is homogeneous.

The default implementation returns 1. if optically thick and dsem if
optically thin. It allows for a quick implementation of your object
for visualization purposes.

Parameters:
-----------

nu_em:  Frequency at emission [Hz]

dsem:  length over which to integrate inside the object [geometrical
units]

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::updateSpin "";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::tell "

This is how a Teller tells.

A teller will basically call listener->tell(this).

Parameters:
-----------

msg:  Teller* the Teller who is telling... Useful if the Listener
listens to several Tellers. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::metric "

Set the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::innerRadius
"

Get rin_. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::innerRadius
"

Get rin_. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::innerRadius
"

Set rin_. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::innerRadius
"

Set rin_. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::outerRadius
"

Get rout_. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::outerRadius
"

Get rout_. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::outerRadius
"

Set rout_. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::outerRadius
"

Set rout_. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::thickness "

Get thickness_. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::thickness "

Get thickness_. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::thickness "

Set thickness_. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::thickness "

Set thickness_. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::dir "

Get dir_. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::dir "

Set dir_. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::corotating "";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::corotating "

Get dir_==1. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::velocityKind
"

Set dir_=t?1:-1.

Get VelocityKind ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::velocityKind
"

Set VelocityKind. ";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::projectedRadius "

Projected radius of position coord on the equatorial plane. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::sphericalPhi
"

Longitude. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::getVelocity
"

Get fluid 4-velocity at point.

Fill vel with the 4-vector velocity of the fluid at 4-position pos.
getVelocity() should work at some distance from the equatorial plane.
The default implementation calls Metric::Generic::circularVelocity().

Parameters:
-----------

pos:  4-position at which to compute velocity;

vel:  4-velocity at pos. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::Impact "

Does a photon at these coordinates impact the object?

Impact() checks whether a Photon impacts the object between two
integration steps of the photon's trajectory (those two steps are
photon->getCoord(index, coord1) and photon->getCoord(index+1,
coord2)). Impact returns 1 if the photon impacts the object between
these two steps, else 0. In many cases of geometrically thick obects,
the implementation Astrobj::Standard::Impact() will be fine.

Impact will call Generic::processHitQuantities() (which is virtual and
may be re-implemented) to compute observable properties on demand: if
the data pointer is non-NULL, the object will look in it for pointers
to properties which apply to its kind. If a pointer to a property
known to this object is present, then the property is computed and
store at the pointed-to address. For instance, all objects know the
\"intensity\" property. If data->intensity != NULL, the instensity is
computed and stored in *data->intensity.

If data is non-NULL and only in this case, processHitQuantities() will
also call ph->transmit() to update the transmissions of the Photon
(see Photon::transmit(size_t, double)). This must not be done if data
is NULL (see Astrobj::Complex::Impact() for an explanation).

Impact() may not extend the ph Worldline. The only two dates that are
guaranteed to be defined are at indices index and index+1.

Parameters:
-----------

ph:   Gyoto::Photon aimed at the object;

index:  Index of the last photon step;

data:  Pointer to a structure to hold the observables at impact.

1 if impact, 0 if not. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::metric "

Get the Metric gg_. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::rMax "

Get maximal distance from center of coordinate system.

Get maximal distance from center of coordinate system at which a
Photon may hit the object.

Child classes may use the rmax_ member to cache this value, if its
current value is DBL_MAX.

It can also be set using rMax().

rmax_ in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::rMax "

Get maximal distance from center of coordinate system. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::rMax "

Get rmax_ is specified unit.

Call rMax() and convert result to unit.

Parameters:
-----------

unit:  string

double rmax converted to unit ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::rMax "

Get rmax_ is specified unit. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::rMax "

Set maximal distance from center of coordinate system.

Set maximal distance from center of coordinate system at which a
Photon may hit the object.

Parameters:
-----------

val:  new rmax_ in geometrical units. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::rMax "

Set maximal distance from center of coordinate system.

Call Generic::rMax(double val) after converting val from unit to
geometrical units.

Parameters:
-----------

val:   rmax_ expressed in unit \"unit\";

unit:  string... ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::deltaMax "

Get max step constraint for adaptive integration.

Parameters:
-----------

coord:  position

max step to find this object reliably ";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::GYOTO_OBJECT_ACCESSORS_UNIT "";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::opticallyThin "

Set whether the object is optically thin.

Set flag indicating that radiative transfer should be integrated, i.e.
the object is to be considered optically thin.

Parameters:
-----------

flag:  1 if optically thin, 0 if optically thick. ";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::opticallyThin "

Query whether object is optically thin.

See opticallyThin(bool flag). ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::showshadow "";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::showshadow "";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::redshift "";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::redshift "";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::getDefaultQuantities "

Which quantities to compute if know was requested.

Return a Gyoto::Quantity_t suitable as input to
Gyoto::Scenery::setRequestedQuantities() to set de default quantities
to compute for this object. The default of these defaults
GYOTO_QUANTITY_INTENSITY. ";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::setParameters "

Main loop in Subcontractor_t function.

The Subcontractor_t function for each Astrobj kind should look
somewhat like this (templated as
Gyoto::Astrobj::Subcontractor<MyKind>):

Each object kind should implement setParameter(string name, string
content, string unit) to interpret the individual XML elements.
setParameters() can be overloaded in case the specific Astrobj class
needs low level access to the FactoryMessenger. See
UniformSphere::setParameters(). ";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::processHitQuantities "

Fills Astrobj::Properties.

processHitQuantities fills the requested data in Impact. To use it,
you need to call it in the Impact() method for your object in case of
hit. It will fill Redshift, Intensity, Spectrum, BinSpectrum and
update the Photon's transmission by calling Photon::transmit(), only
if data==NULL.

You can overload it for your Astrobj. The generic implementation calls
emission(), integrateEmission() and transmission() below. ";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::processHitQuantities "";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::emission "

Obsolete, update your code;. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::emission "

Specific intensity I for several values ofem

Called by the default implementation for processHitQuantities().

emission() computes the intensity I emitted by the small volume of
length dsem. It should take self- absorption along dsem into account.

Same as emission(double nu_em, double dsem, double coord_ph[8], double
coord_obj[8]=NULL) const looping on several values of nu_em.

Parameters:
-----------

Inu[nbnu]:  Output (must be set to a previously allocated array of
doubles)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of Inu[] and nu_em[]

dsem:  Length over which to integrate inside the object

coord_ph:   Photon coordinate

coord_obj:  Emitter coordinate at current photon position

I or dI [W m-2 sr-2] ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::emission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::radiativeQ "

emission and transmission together ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::radiativeQ "";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::radiativeQ "

Compute the increment of Stokes parameters and transmission matrix.
Polarised version of RadiaveQ.

First function to be called for radiative quantities. If exist, i.e.
implemented in an Astrobj, return the Stokes parameters emitted by the
small volume of length dsem.

Warning : The basis used to determine the Stokes coefficients is
different from the observer parallel transported polarisation basis.
One should use getChi function to compute the angle between these two
basis.

The non polarized case must also be implemented in this function to
avoid error.

See exemple in SimplePolarStar.C.

Parameters:
-----------

Inu[nbnu]:  Output increment of intensity (must be set to a previously
allocated array of doubles)

Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
previously allocated array of doubles)

Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
previously allocated array of doubles)

Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
previously allocated array of doubles)

Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
previously allocated array of Matrix4d)

nu_em[nbnu]:  Frequencies at emission

nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

dsem:  Length over which to integrate inside the object

cph:   Photon coordinate

co:  Emitter coordinate at current photon position

Increment of the Stokes parameters (I,Q,U,V) and local Transmission
matrix (O). ";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::integrateEmission "

12 I d (or j)

Compute the integral of emission() from1 to2. The default
implementation is a numerical integrator which works well enough and
is reasonably fast if emission() is a smooth function (i.e. no
emission or absorption lines). If possible, it is wise to implement an
analytical solution. It is used by processHitQuantities to compute the
\"BinSpectrum\" quantity which is the most physical: it is the only
quantity that can be actually measured directly by a real-life
instrument. ";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::integrateEmission "

12 I d (or j)

Like double integrateEmission(double nu1, double nu2, double dsem,
double c_ph[8], double c_obj[8]) const for each Spectrometer channel.
";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::integrateEmission "

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::transmission
"

Transmission: exp( * dsem )

transmission() computes the transmission of this fluid element or 0 if
optically thick. The default implementation returns 1. (no
attenuation) if optically thin, 0. if optically thick.

Parameters:
-----------

nuem:  frequency in the fluid's frame

coord:   Photon coordinate

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::transmission
"

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::transmission
"

Obsolete, update your code. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::Omatrix "

Omatrix() computes the exponential of the Mueller matrix which
contains the absorption and Faraday coefficients and is used in the
polarized radiative transfer equation.

Parameters:
-----------

Onu:  output matrix (must be allocated previously)

alphanu[4]:  array containing the 4 absorption coefficients in the
Stokes basis (I,Q,U,V)

rnu[3]:  array containing the 3 Faraday coefficients in the Stokes
basis (Q,U,V)

Chi:  angle of rotation between the parallel transported observer
polarization basis and the Stokes basis

dsem:  geometrical length in geometrical units ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::Omatrix "";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::Pmatrix "";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::rotateJs "

Apply the rotation matrix with angle Chi to the emission Stokes vector
constructed in the fonction from the individual coefficients ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::rotateJs "";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::getChi "

Get Chi angle. Return the angle between the parallel transported
observer polarization basis (Ephi,Etheta) and the Stokes basis in the
rest frame of the emitter defined by the 4-vector magnetic/electric
field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::getSinCos2Chi "

Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
the parallel transported observer polarization basis (Ephi,Etheta) and
the Stokes basis in the rest frame of the emitter defined by the
4-vector magnetic/electric field.

Parameters:
-----------

fourvect:  4-vector magnetic/electric field depending on elec
(false/true)

cph:   Photon coordinate, must contain the Ephi and Etheta vectors
i.e. size(cph)==16

vel:  Fluid velocity at the photon coordinate ";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::computeB4vect "

Compute the magnetic field 4-vector at a given position and a given
configuration

Parameters:
-----------

B4vect:  the output 4-vector magnetic field

magneticConfig:  string which determine the wanted configuration
('Radial', 'Azimuthal', 'Vertical')

co:  coordinate of the object which also contain its velocity

cph:  coordinate of the photon ";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::computeB4vect_ipole "";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::interpolate
"

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X:  2D array containing the range of all the axes (for exemple :
radius, \\\\theta, \\\\varphi) at which the array is knwon. Should be
built as a pointer of pointers.

X_params:  1D array that contain the length of each axes.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::interpolate
"

N-dimensional linear interpolation function

Parameters:
-----------

N:  number of dimensions

array:  array that should be interpolated. This array has to be a 1D
array with the first dimension evolving the slowest

Xq:  query position at which the interpolation should be done. 1D
array with N elements.

X_params[N][3]:  2D array that contain the minimum value, the maximum
value and the length of each axes. The axes will be assumed to be
linearly spaced.

cond_limits:  1D array of strings that set the boundary conditions
that will be applied to each axes. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::incRefCount
"

Increment the reference counter. Warning: Don't mess with the counter.
";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::decRefCount
"

Decrement the reference counter and return current value. Warning:
Don't mess with the counter. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::getRefCount
"

Get the current number of references. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::isThreadSafe
"

Whether this class is thread-safe.

Return True if this object is thread-safe, i.e. if an instance and its
clone can be used in parallel threads (in the context of
Scenery::raytrace()). Known objects which are not thread-safe include
Lorene metrics and everything from the Python plug-in.

The default implementation considers that the class itself is thread
safe and recurses into the declared properties to check whether they
are safe too. Classes that abide to the Object/Property paradigm and
are themselves thread-safe have nothing special to do.

Objects that clone children in their copy constructor that are not
declared as properties must take these children into account.

Classes that are never thread-safe must declare it. It acn be easily
done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::set "

Set Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::set "

Set Value (expressed in unit) of a Property. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::get "

Get Value of a Property. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::get "

Get Value of a Property, converted to unit. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::property "

Find property by name.

Look into the Property list for a Property whose name (or name_false,
for a boolean Property) is pname. Return a const pointer to the first
such property found, or NULL if none is found. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::fillElement
"

Fill the XML element for this Object.

The base implementation simply calls fillProperty() for each Property
defined for the Object.

Derived classes should avoid overriding fillElement(). It may make
sense occasionally, e.g. to make sure that the metric is output first.

To customize how a given Property is rendered, it is better to
override fillProperty().

If this method is overridden, the implementation should in general
call fillElement() on the direct base. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::setParameter
"

Set parameter by name.

This function is used when parsing an XML description, if no Property
of this name is found. Overriding implementation should fall-back on
calling the direct's parent implementation:

Parameters:
-----------

name:  XML name of the parameter (XML entity). This may have a path
component, e.g. \"Astrobj::Radius\", in which case a property named
\"Astrobj\" will be sought in the current object, and setParameter
will be called recusrively on this Astrobj with Radius as name.

content:  string representation of the value

unit:  string representation of the unit

0 if this parameter is known, 1 if it is not. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::setParameter
"

Set parameter by Property (and name)

This function is used when parsing an XML description, if Property (
p) of this name is found (i.e. either p.name or p.name_false is equal
to name). Implementation should fall-back on calling the direct's
parent implementation:

Parameters:
-----------

p:   Property that matches name ( p.name == name or p.name_false ==
name)

name:  XML name of the parameter (XML entity)

content:  string representation of the value

unit:  string representation of the unit ";

%feature("docstring")
Gyoto::Astrobj::XillverReflection::describeProperty "

Format desrciption for a property.

Returns a string containing the name(s) and type of the property, as
well as whether it supports unit. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::help "

Print (to stdout) some help on this class.

Describe all properties that this instance supports. ";

%feature("docstring")  Gyoto::Astrobj::XillverReflection::kind "

Get kind_. ";


// File: namespace_gyoto.xml
/*  Observable quantities  */

/* Individual quantities are represented as a variable of this type. A
combination of quantities is an ored list of Quantity_t, e.g.

To check wheter a given quantity is listed in a Quantity_t variable
quant:

List of all possible Quantity_t individual values and the
corresponding string (see Gyoto::Scenery) with corresponding XML name:

*/

/*  Gyoto messages  */

/* Controling which messages are shown to the user

The user should be able to choose which messages are shown to her. In
Gyoto, this is determined by a user-settable verbosity level (see
Gyoto::verbose()) and a user-settable debug mode (see Goyto::debug()).

The following macros define various debug and verbosity level and
provide short-cuts to display formatted messages only at a given
verbosity level or in debug mode.

*/

/*  Coordinate system kind  */

/* GYOTO_COORDKIND_CARTESIAN or GYOTO_COORDKIND_SPHERICAL

Every Gyoto::Metric has a coordinate system kind. It can be used by
functions which need to express coordinates always in spherical or
always in Cartesian form, with trivial conversion between the two.

*/

%feature("docstring")  Gyoto::Astrobj::throwError "

Throw a Gyoto::Error.

Most code should use the GYOTO_ERROR macro instead ";

%feature("docstring")  Gyoto::Astrobj::loadPlugin "

Load a plugin by name.

Uses dlopen to load the file libgyoto-<plugname>.so, looks for the
function __Gyoto<plugname>Init inside it and run it. Plug-ins must be
located in the runtime link search path, or in GYOTO_PKGLIBDIR, or in
GYOTO_PKGLIBDIR/GYOTO_SOVERS/.

Parameters:
-----------

plugname:  C string Plug-in name.

nofail:  int Unless nofail evals to true, the inability to find a
plug-in or to run the initialization function inside it throws an
Gyoto::Error. If nofail is 2 or more, such conditions are silently
ignored. If nofail is one, those conditions trigger a warning.

void* handle to the dlopen'ed plug-in. ";

%feature("docstring")  Gyoto::Astrobj::havePlugin "

Check whether a given plug-in has already been loaded.

Parameters:
-----------

plugname:  std::string Plug-in name. ";

%feature("docstring")  Gyoto::Astrobj::requirePlugin "

Load a plugin by name, only if not loaded yet.

Parameters:
-----------

plugname:  std::string Plug-in name.

nofail:  int Unless nofail evals to true, the inability to find a
plug-in or to run the initialization function inside it throws an
Gyoto::Error. If nofail is 2 or more, such conditions are silently
ignored. If nofail is one, those conditions trigger a warning. ";

%feature("docstring")  Gyoto::Astrobj::debug "

Set debug mode.

Parameters:
-----------

mode:  1 to turn on debug mode, 0 to turn it off. ";

%feature("docstring")  Gyoto::Astrobj::debug "

Get debug mode.

>=1 if debug mode is on, else 0. ";

%feature("docstring")  Gyoto::Astrobj::verbose "

Set verbosity level.

See standard verbosity levels defined in GyotoDefs.h:

GYOTO_DEFAULT_DEBUG_MODE

GYOTO_QUIET_VERBOSITY

GYOTO_SEVERE_VERBOSITY

GYOTO_WARNING_VERBOSITY

GYOTO_DEFAULT_VERBOSITY

GYOTO_INFO_VERBOSITY

GYOTO_DEBUG_VERBOSITY ";

%feature("docstring")  Gyoto::Astrobj::verbose "

Get verbosity level.

See verbose(int mode). ";

%feature("docstring")  Gyoto::Astrobj::convert "

Convert lengths (deprecated)

Deprecated Will be removed once it is not used anymore in Gyoto per
se. Prefer Gyoto::Units framework.

Parameters:
-----------

x:  Lengths to convert, in geometrical units on input, in specified
unit on output.

nelem:  Size of x array.

mass_sun:  Black-hole mass in Solar masses.

distance_kpc:  Distance from observer in kiloparsecs.

unit:  One of \"geometrical\", \"m\", \"km\", \"sun radius\", \"rad\",
\"degree\", \"arcmin\", \"arcsec\", \"mas\", \"uas\". ";

%feature("docstring")  Gyoto::Astrobj::atof "

Interpret C string as double.

Wrapper around std::atof() that also interprets DBL_MIN, DBL_MAX,
-DBL_MIN and -DBL_MAX.

If str starts with \"(-)DBL_M\" and is not one of the four special
values, then an error is thrown.

Parameters:
-----------

str:  C string to interpret

double valu represented by str. ";

%feature("docstring")  Gyoto::Astrobj::help "

Print help on class.

Parameters:
-----------

class_name:  e.g. \"Gyoto::Screen\", \"Gyoto::Astrobj::Torus\". ";

%feature("docstring")  Gyoto::Astrobj::split "

Split string. ";

%feature("docstring")  Gyoto::Astrobj::bessi0 "

Bessel function computation.

Modified Bessel function I0 ";

%feature("docstring")  Gyoto::Astrobj::bessi1 "

Modified Bessel function I1 ";

%feature("docstring")  Gyoto::Astrobj::bessk0 "

Modified Bessel function K0 ";

%feature("docstring")  Gyoto::Astrobj::bessk1 "

Modified Bessel function K1 ";

%feature("docstring")  Gyoto::Astrobj::bessk "

Modified Bessel function. ";

%feature("docstring")  Gyoto::Astrobj::hypergeom "

Gauss hypergeometric 2F1 term for kappa-distribution synchrotron. ";

%feature("docstring")  Gyoto::Astrobj::cartesianToSpherical "

Tranform from Cartesian 3-position to spherical 3-position. ";

%feature("docstring")  Gyoto::Astrobj::sphericalToCartesian "

Tranform from spherical 3-position to Cartesian 3-position. ";

%feature("docstring")  Gyoto::Astrobj::matrix4Invert "

Invert 4x4 matrix.

Parameters:
-----------

IN_ARRAY2:  the 4×4 matrix to invert

ARGOUT_ARRAY2:  the invert matrix of IN_ARRAY2 ";

%feature("docstring")  Gyoto::Astrobj::matrix4CircularInvert "

Invert 4x4 circular spacetime metric.

A circular spacetime metric (in the right coordinate system) is
symmetrical (like all metric matrices);

has only 6 non-zero element: the diagonal and the corners.

Parameters:
-----------

IN_ARRAY2:  the 4×4 matrix to invert

ARGOUT_ARRAY2:  the invert matrix of IN_ARRAY2 ";


// File: namespace_gyoto_1_1_astrobj.xml
%feature("docstring")  Gyoto::Astrobj::Python::Subcontractor "

A template for Subcontractor_t functions.

Instead of reimplementing the wheel, your subcontractor can simply be
Gyoto::Astrobj::Subcontractor<MyKind>.

If MyKind accepts any XML parameters, it should re-implement
Astrobj::Generic::setParameter() or, if low-level access to the
FactoryMessenger is needed, Generic::setParameters().

templateparam:

T:   Gyoto::Astrobj::Generic sub-class ";

%feature("docstring")  Gyoto::Astrobj::Python::getSubcontractor "

Query the Astrobj register.

Query the Astrobj register to get the Astrobj::Subcontractor_t
corresponding to a given kind name. This function is normally called
only from the Factory. If plugin is specified, only a subcontractor
matching both name and plugin will be returned, loading the plug-in if
necessary. If plugin is the empty string, then the first subcontractor
matching name will be returned, and the name of the plug-in it belongs
to will be returned in plugin upon output.

Parameters:
-----------

name:  e.g. \"Star\"

plugin:  e.g. \"stdplug\".

errmode:  1 to return NULL in case of failure instead of throwing an
Error.

pointer to the corresponding subcontractor. ";

%feature("docstring")  Gyoto::Astrobj::Python::initRegister "

Empty the Astrobj register.

This must be called once. ";

%feature("docstring")  Gyoto::Astrobj::Python::Register "

Make an Astrobj kind known to the Factory.

Register a new Astrobj::Generic sub-class so that the Gyoto::Factory
knows it.

Parameters:
-----------

name:  The kind name which identifies this object type in an XML file,
as in < Astrobj kind=\"name\">

scp:  A pointer to the subcontractor, which will communicate with the
Gyoto::Factory to build an instance of the class from its XML
description ";


// File: namespace_gyoto_1_1_astrobj_1_1_python.xml


// File: namespace_gyoto_1_1_functor.xml


// File: namespace_gyoto_1_1_hook.xml


// File: namespace_gyoto_1_1_metric.xml
%feature("docstring")  Gyoto::Metric::Subcontractor "

Subcontractor template.

Instead of reimplementing the wheel, your subcontractor can simply be
Gyoto::Metric::Subcontractor<MyKind>

templateparam:

T:  Sub-class of Metric::Generic ";

%feature("docstring")  Gyoto::Metric::getSubcontractor "

Query the Metric register.

Query the Metric register to get the Metric::Subcontractor_t
correspondig to a given kind name. This function is normally called
only from the Factory. If plugin is specified, only a subcontractor
matching both name and plugin will be returned, loading the plug-in if
necessary. If plugin is the empty string, then the first subcontractor
matching name will be returned, and the name of the plug-in it belongs
to will be returned in plugin upon output.

Parameters:
-----------

name:  e.g. \"KerrBL\"

plugin:  e.g. \"stdplug\".

errmode:  int=0. If errmode==0, failure to find a registered Metric by
that name is an error. Else, simply return NULL pointer in that case.

pointer to the corresponding subcontractor. ";

%feature("docstring")  Gyoto::Metric::Register "

Make a Metric kind known to the Factory.

Register a new Metric::Generic sub-class so that the Gyoto::Factory
knows it.

Parameters:
-----------

kind:  The kind name which identifies this object type in an XML file,
as in < Metric kind=\"name\">

scp:  A pointer to the subcontractor, which will communicate with the
Gyoto::Factory to build an instance of the class from its XML
description ";

%feature("docstring")  Gyoto::Metric::initRegister "

Empty the Metric register.

This must be called once. It is called by Gyoto::Register::init(). ";


// File: namespace_gyoto_1_1_python.xml
%feature("docstring")  Gyoto::Python::PyObject_FromGyotoValue "

Convert Gyoto Value to Python Object. ";

%feature("docstring")  Gyoto::Python::PyInstance_GetMethod "

Return new reference to method, or NULL if method not found. ";

%feature("docstring")  Gyoto::Python::PyImport_Gyoto "

Return refernce to the gyoto module, or NULL. ";

%feature("docstring")  Gyoto::Python::PyInstance_SetThis "

Set \"this\" attribute in instance. ";

%feature("docstring")  Gyoto::Python::PyCallable_HasVarArg "

Check whether method accepts the varargs argument. ";

%feature("docstring")  Gyoto::Python::PyModule_NewFromPythonCode "

Create module from Python source code in a C string. ";

%feature("docstring")  Gyoto::Python::pGyotoSpectrum "

Get reference to the Spectrum constructor in the gyoto Python
extension. ";

%feature("docstring")  Gyoto::Python::pGyotoMetric "

Get reference to the Metric constructor in the gyoto Python extension.
";

%feature("docstring")  Gyoto::Python::pGyotoStandardAstrobj "

Get reference to the StandardAstrobj constructor in the gyoto Python
extension. ";

%feature("docstring")  Gyoto::Python::pGyotoThinDisk "

Get reference to the ThinDisk constructor in the gyoto Python
extension. ";


// File: namespace_gyoto_1_1_register.xml
%feature("docstring")  Gyoto::Register::init "

Initialise the various registers.

Normally called once at application start-up, Register::init()
initiaizes the registers, loads the plug-ins, and fills the registers
as appropriate.

Parameters:
-----------

pluglist:  Coma-separated list of plug-ins to load. If NULL, default
to the environment variable GYOTO_PLUGINS, if it exists. Else use
GYOTO_DEFAULT_PLUGINS. Failing to load a plug-in prepended with
\"nofail:\" is not fatal. ";

%feature("docstring")  Gyoto::Register::list "

List the various registers. ";


// File: namespace_gyoto_1_1_spectrometer.xml
%feature("docstring")  Gyoto::Spectrometer::getSubcontractor "

Query the Spectrometer register.

Get the Spectrometer::Subcontractor_t correspondig to a given kind
name. This function is normally called only from the Gyoto::Factory.
If plugin is specified, only a subcontractor matching both name and
plugin will be returned, loading the plug-in if necessary. If plugin
is the empty string, then the first subcontractor matching name will
be returned, and the name of the plug-in it belongs to will be
returned in plugin upon output.

Parameters:
-----------

name:  Name of the subclass to build, e.g. \"Complex\" or \"wave\".

plugin:  e.g. \"stdplug\".

errmode[in]:  If name is not registered, getSubcontractor() return
NULL errmode==1, throws a Gyoto::Error if errmode==0.

pointer to the corresponding subcontractor. ";

%feature("docstring")  Gyoto::Spectrometer::Subcontractor "

A template for Subcontractor_t functions.

Instead of reimplementing the wheel, your subcontractor can simply be
Gyoto::Spectrometer::Subcontractor<MyKind>. It must however implement
setParameters().

templateparam:

T:  A Spectrometer::Generic sub-class. ";

%feature("docstring")  Gyoto::Spectrometer::initRegister "

Initialize the Spectrometer register This must be called once. It
initializes Register_ and registers the standard kinds ( Uniform and
Complex). ";

%feature("docstring")  Gyoto::Spectrometer::Register "

Register a new Spectrometer kind.

Register a new Spectrometer::Generic sub-class so that the
Gyoto::Factory knows it.

Parameters:
-----------

name:  The kind name which identifies this object type in an XML file,
as in < Spectrometer kind=\"name\">. For clarity, this should be the
same as the value of kindid_ for this object, but it is not mandatory.

scp:  A pointer to the subcontractor, which will communicate with the
Gyoto::Factory to build an instance of the class from its XML
description. If all parameters can be set using setParameter(), this
can be: ";


// File: namespace_gyoto_1_1_spectrum.xml
%feature("docstring")  Gyoto::Spectrum::Subcontractor "

Subcontractor template.

Instead of reimplementing the wheel, your subcontractor can simply be
Gyoto::Spectrum::Subcontractor<MyKind>

templateparam:

T:  Sub-class of Spectrum::Generic ";

%feature("docstring")  Gyoto::Spectrum::Register "

Make a Spectrum kind known to the Factory.

Register a new Spectrum::Generic sub-class so that the Gyoto::Factory
knows it.

Parameters:
-----------

kind:  The kind name which identifies this object type in an XML file,
as in < Spectrum kind=\"name\">

scp:  A pointer to the subcontractor, which will communicate with the
Gyoto::Factory to build an instance of the class from its XML
description ";

%feature("docstring")  Gyoto::Spectrum::getSubcontractor "

Query the Spectrum register.

Query the Spectrum register to get the Metric::Subcontractor_t
correspondig to a given kind name. This function is normally called
only from the Factory. If plugin is specified, only a subcontractor
matching both name and plugin will be returned, loading the plug-in if
necessary. If plugin is the empty string, then the first subcontractor
matching name will be returned, and the name of the plug-in it belongs
to will be returned in plugin upon output.

Parameters:
-----------

name:  e.g. \"PowerLaw\"

plugin:  e.g. \"stdplug\".

errmode:  int=0. If errmode==0, failure to find a registered Spectrum
by that name is an error. Else, simply return NULL pointer in that
case.

pointer to the corresponding subcontractor. ";

%feature("docstring")  Gyoto::Spectrum::initRegister "

Empty the Spectrum register.

This must be called once. It is called by Gyoto::Register::init(). ";


// File: namespace_gyoto_1_1_units.xml
%feature("docstring")  Gyoto::Units::Init "

Load and initialize all (non-context-sensitive) units.

If udunits is used (preprocessor macro HAVE_UDUNITS), Init()
initializes the ut_system used throughout Gyoto and maps a few
additional units to the unit system. ";

%feature("docstring")  Gyoto::Units::ToMeters "

Convert from arbitrary length unit to meters.

Convert value from unit represented by \"unit\" to meters.

If gg is provided (and not NULL), use it to interpret the string
\"geometrical\" as representing gg->
Gyoto::Metric::Generic::unitLength().

ToMeters() will also convert time, frequency and energy units to
meters (as in frequency -> wavelength).

Parameters:
-----------

value:  (double) the value to convert, expressed according to \"unit\"

unit:  (std::string) the \"unit\" from which to convert, e.g. \"km\",
\"sunradius\" or \"geometrical\". More units are supported if Gyoto
was compiled with udunits support.

gg:  (const Gyoto::SmartPointer<Gyoto::Metric::Generic> &, NULL if not
specified) optional metric to interpret \"geometrical\".

value, expressed in meters. ";

%feature("docstring")  Gyoto::Units::FromMeters "

Convert to arbitrary length unit from meters.

Convert value to unit represented by \"unit\" from meters.

If gg is provided (and not NULL), use it to interpret the string
\"geometrical\" as representing gg->
Gyoto::Metric::Generic::unitLength().

ToMeters() will also convert to time, frequency and energy units (as
in wavelength -> frequency).

Parameters:
-----------

value:  (double) the value to convert, expressed in meters.

unit:  (std::string) the \"unit\" to which to convert, e.g. \"km\",
\"sunradius\" or \"geometrical\". More units are supported if Gyoto
was compiled with udunits support.

gg:  (const Gyoto::SmartPointer<Gyoto::Metric::Generic> &, NULL if not
specified) optional metric to interpret \"geometrical\".

value, expressed in \"unit\". ";

%feature("docstring")  Gyoto::Units::ToSeconds "

Convert from arbitrary time unit to seconds.

Convert value from unit represented by \"unit\" to seconds.

If gg is provided (and not NULL), use it to interpret the string
\"geometrical_time\" as representing gg->
Gyoto::Metric::Generic::unitLength()/GYOTO_C.

Parameters:
-----------

value:  (double) the value to convert, expressed according to \"unit\"

unit:  (std::string) the \"unit\" from which to convert, e.g. \"s\",
\"yr\" or \"geometrical_time\". More units are supported if Gyoto was
compiled with udunits support.

gg:  (const Gyoto::SmartPointer<Gyoto::Metric::Generic> &, NULL if not
specified) optional metric to interpret \"geometrical\".

value, expressed in seconds. ";

%feature("docstring")  Gyoto::Units::FromSeconds "

Convert to arbitrary time unit from seconds.

Convert value to unit represented by \"unit\" from seconds.

If gg is provided (and not NULL), use it to interpret the string
\"geometrical_time\" as representing gg->
Gyoto::Metric::Generic::unitLength()/GYOTO_C.

Parameters:
-----------

value:  (double) the value to convert, expressed in seconds.

unit:  (std::string) the \"unit\" to which to convert, e.g. \"s\",
\"yr\" or \"geometrical_time\". More units are supported if Gyoto was
compiled with udunits support.

gg:  (const Gyoto::SmartPointer<Gyoto::Metric::Generic> &, NULL if not
specified) optional metric to interpret \"geometrical\".

value, expressed in \"unit\". ";

%feature("docstring")  Gyoto::Units::ToKilograms "

Convert from arbitrary mass unit to kilograms.

Convert value from unit represented by \"unit\" to kilograms.

Parameters:
-----------

value:  (double) the value to convert, expressed according to \"unit\"

unit:  (std::string) the \"unit\" from which to convert, e.g. \"g\",
\"kg\" or \"sunmass\". More units are supported if Gyoto was compiled
with udunits support.

value, expressed in kilograms. ";

%feature("docstring")  Gyoto::Units::FromKilograms "

Convert to arbitrary mass unit from kilograms.

Convert value from unit represented by \"unit\" from kilograms.

Parameters:
-----------

value:  (double) the value to convert, expressed inkilograms.

unit:  (std::string) the \"unit\" to which to convert, e.g. \"g\",
\"kg\" or \"sunmass\". More units are supported if Gyoto was compiled
with udunits support.

value, expressed in \"unit\". ";

%feature("docstring")  Gyoto::Units::ToGeometrical "

Convert from arbitrary length unit to geometrical units.

Convert value from unit represented by \"unit\" to geometrical units.

Parameters:
-----------

value:  (double) the value to convert, expressed according to
\"unit\".

unit:  (std::string) the \"unit\" from which to convert, e.g. \"km\",
\"sunradius\" or \"geometrical\". More units are supported if Gyoto
was compiled with udunits support.

gg:  (const Gyoto::SmartPointer<Gyoto::Metric::Generic> &) metric to
interpret \"geometrical\".

value, expressed in geometrical units. ";

%feature("docstring")  Gyoto::Units::FromGeometrical "

Convert to arbitrary length unit from geometrical units.

Convert value to unit represented by \"unit\" from geometrical units.

Parameters:
-----------

value:  (double) the value to convert, expressed in geometrical units.

unit:  (std::string) the \"unit\" to which to convert, e.g. \"km\",
\"sunradius\" or \"geometrical\". More units are supported if Gyoto
was compiled with udunits support.

gg:  (const Gyoto::SmartPointer<Gyoto::Metric::Generic> &) metric to
interpret \"geometrical\".

value, expressed in \"unit\". ";

%feature("docstring")  Gyoto::Units::ToGeometricalTime "

Convert from arbitrary time unit to geometrical units.

Parameters:
-----------

value:  (double) the value to convert, expressed according to
\"unit\".

unit:  (std::string) the \"unit\" from which to convert, e.g. \"s\",
\"kyr\" or \"geometrical_time\". More units are supported if Gyoto was
compiled with udunits support.

gg:  (const Gyoto::SmartPointer<Gyoto::Metric::Generic> &) metric to
interpret \"geometrical_time\".

value, expressed in geometrical (time) units. ";

%feature("docstring")  Gyoto::Units::FromGeometricalTime "

Convert to arbitrary time unit from geometrical units.

Parameters:
-----------

value:  (double) the value to convert, expressed in geometrical units.

unit:  (std::string) the \"unit\" to which to convert, e.g. \"yr\",
\"s\" or \"geometrical_time\". More units are supported if Gyoto was
compiled with udunits support.

gg:  (const Gyoto::SmartPointer<Gyoto::Metric::Generic> &) metric to
interpret \"geometrical_time\".

value, expressed in \"unit\". ";

%feature("docstring")  Gyoto::Units::ToHerz "

Convert from arbitrary frequency unit to Herz.

ToHerz will also convert from length and energy units (such as
\"eV\").

Parameters:
-----------

value:  (double) the value to convert, expressed according to
\"unit\".

unit:  (std::string) the \"unit\" from which to convert, e.g. \"MHz\",
\"keV\"

value, expressed in \"Hz\". ";

%feature("docstring")  Gyoto::Units::FromHerz "

Convert to arbitrary frequency unit from Herz.

FromHerz will also convert to length and energy units (such as
\"eV\").

Parameters:
-----------

value:  (double) the value to convert, expressed according in \"Hz\".

unit:  (std::string) the \"unit\" from which to convert, e.g. \"MHz\",
\"keV\"

value, expressed in \"units\". ";


// File: namespace_lorene.xml


// File: _gyoto_8h.xml


// File: _gyoto_astrobj_8h.xml


// File: _gyoto_black_body_spectrum_8h.xml


// File: _gyoto_blob_8h.xml


// File: _gyoto_chern_simons_8h.xml


// File: _gyoto_complex_astrobj_8h.xml


// File: _gyoto_complex_metric_8h.xml


// File: _gyoto_complex_spectrometer_8h.xml


// File: _gyoto_config_8h.xml


// File: _gyoto_converters_8h.xml


// File: _gyoto_deformed_torus_8h.xml


// File: _gyoto_defs_8h.xml
/*  Observable quantities  */

/* Individual quantities are represented as a variable of this type. A
combination of quantities is an ored list of Quantity_t, e.g.

To check wheter a given quantity is listed in a Quantity_t variable
quant:

List of all possible Quantity_t individual values and the
corresponding string (see Gyoto::Scenery) with corresponding XML name:

*/

/*  Gyoto messages  */

/* Controling which messages are shown to the user

The user should be able to choose which messages are shown to her. In
Gyoto, this is determined by a user-settable verbosity level (see
Gyoto::verbose()) and a user-settable debug mode (see Goyto::debug()).

The following macros define various debug and verbosity level and
provide short-cuts to display formatted messages only at a given
verbosity level or in debug mode.

*/

/*  Coordinate system kind  */

/* GYOTO_COORDKIND_CARTESIAN or GYOTO_COORDKIND_SPHERICAL

Every Gyoto::Metric has a coordinate system kind. It can be used by
functions which need to express coordinates always in spherical or
always in Cartesian form, with trivial conversion between the two.

*/

/*  Default values for various things  */

/*  Physical constants  */

/*  Observer kind  */

/*  Renamed methods  */

/* Define GYOTO_NO_DEPRECATED to disable these macros and the warning.
For instance:

*/


// File: _gyoto_directional_disk_8h.xml


// File: _gyoto_disk3_d_8h.xml


// File: _gyoto_dynamical_disk_8h.xml


// File: _gyoto_dynamical_disk3_d_8h.xml


// File: _gyoto_dynamical_disk_bolometric_8h.xml


// File: _gyoto_equatorial_hot_spot_8h.xml


// File: _gyoto_error_8h.xml


// File: _gyoto_factory_8h.xml


// File: _gyoto_factory_messenger_8h.xml


// File: _gyoto_fits_r_w_8h.xml


// File: _gyoto_fixed_star_8h.xml


// File: _gyoto_flared_disk_synchrotron_8h.xml


// File: _gyoto_free_star_8h.xml


// File: _gyoto_functors_8h.xml


// File: _gyoto_grid_data2_d_8h.xml


// File: _gyoto_hayward_8h.xml


// File: _gyoto_hooks_8h.xml


// File: _gyoto_inflate_star_8h.xml


// File: _gyoto_jet_8h.xml


// File: _gyoto_kappa_distribution_synchrotron_spectrum_8h.xml


// File: _gyoto_kerr_b_l_8h.xml


// File: _gyoto_kerr_k_s_8h.xml


// File: _gyoto_metric_8h.xml


// File: _gyoto_minkowski_8h.xml


// File: _gyoto_neutron_star_8h.xml


// File: _gyoto_neutron_star_analytic_emission_8h.xml


// File: _gyoto_neutron_star_model_atmosphere_8h.xml


// File: _gyoto_numerical_metric_lorene_8h.xml


// File: _gyoto_object_8h.xml


// File: _gyoto_oscil_torus_8h.xml


// File: _gyoto_page_thorne_disk_8h.xml


// File: _gyoto_pattern_disk_8h.xml


// File: _gyoto_pattern_disk_b_b_8h.xml


// File: _gyoto_photon_8h.xml


// File: _gyoto_plasmoid_8h.xml


// File: _gyoto_polish_doughnut_8h.xml


// File: _gyoto_power_law_spectrum_8h.xml


// File: _gyoto_power_law_synchrotron_spectrum_8h.xml


// File: _gyoto_property_8h.xml


// File: _gyoto_python_8h.xml


// File: _gyoto_register_8h.xml


// File: _gyoto_rezzolla_zhidenko_8h.xml


// File: _gyoto_rot_star3__1_8h.xml


// File: _gyoto_scenery_8h.xml


// File: _gyoto_schwarzschild_harmonic_8h.xml


// File: _gyoto_screen_8h.xml


// File: _gyoto_shift_8h.xml


// File: _gyoto_smart_pointer_8h.xml


// File: _gyoto_spectrometer_8h.xml


// File: _gyoto_spectrum_8h.xml


// File: _gyoto_spherical_accretion_8h.xml


// File: _gyoto_standard_astrobj_8h.xml


// File: _gyoto_star_8h.xml


// File: _gyoto_star_trace_8h.xml


// File: _gyoto_thermal_bremsstrahlung_spectrum_8h.xml


// File: _gyoto_thermal_synchrotron_spectrum_8h.xml


// File: _gyoto_thick_disk_8h.xml


// File: _gyoto_thin_disk_8h.xml


// File: _gyoto_thin_disk_grid_intensity_8h.xml


// File: _gyoto_thin_disk_iron_line_8h.xml


// File: _gyoto_thin_disk_p_l_8h.xml


// File: _gyoto_thin_disk_profile_8h.xml


// File: _gyoto_torus_8h.xml


// File: _gyoto_uniform_spectrometer_8h.xml


// File: _gyoto_uniform_sphere_8h.xml


// File: _gyoto_utils_8h.xml


// File: _gyoto_value_8h.xml


// File: _gyoto_w_i_p_8h.xml


// File: _gyoto_worldline_8h.xml


// File: _gyoto_xillver_reflection_8h.xml


// File: yorick_plugin_page.xml


// File: writing_plugins_page.xml


// File: deprecated.xml


// File: dir_d44c64559bbebec7f509842c48db8b23.xml


// File: dir_88ae3fdf8dbcb3c257ad222b88e7e53a.xml


// File: dir_38c8d24aef3972a7f87b834274e76e31.xml


// File: dir_ce581dcb34db8ae13dfd9656874fdad3.xml


// File: indexpage.xml

