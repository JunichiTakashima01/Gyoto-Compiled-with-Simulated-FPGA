# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""The General relativitY Orbit Tracer of paris Observatory"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_core')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_core')
    _core = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_core', [dirname(__file__)])
        except ImportError:
            import _core
            return _core
        try:
            _mod = imp.load_module('_core', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _core = swig_import_helper()
    del swig_import_helper
else:
    import _core
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _core.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        """value(SwigPyIterator self) -> PyObject *"""
        return _core.SwigPyIterator_value(self)


    def incr(self, n=1):
        """
        incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        incr(SwigPyIterator self) -> SwigPyIterator
        """
        return _core.SwigPyIterator_incr(self, n)


    def decr(self, n=1):
        """
        decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        decr(SwigPyIterator self) -> SwigPyIterator
        """
        return _core.SwigPyIterator_decr(self, n)


    def distance(self, x):
        """distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _core.SwigPyIterator_distance(self, x)


    def equal(self, x):
        """equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _core.SwigPyIterator_equal(self, x)


    def copy(self):
        """copy(SwigPyIterator self) -> SwigPyIterator"""
        return _core.SwigPyIterator_copy(self)


    def next(self):
        """next(SwigPyIterator self) -> PyObject *"""
        return _core.SwigPyIterator_next(self)


    def __next__(self):
        """__next__(SwigPyIterator self) -> PyObject *"""
        return _core.SwigPyIterator___next__(self)


    def previous(self):
        """previous(SwigPyIterator self) -> PyObject *"""
        return _core.SwigPyIterator_previous(self)


    def advance(self, n):
        """advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _core.SwigPyIterator_advance(self, n)


    def __eq__(self, x):
        """__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _core.SwigPyIterator___eq__(self, x)


    def __ne__(self, x):
        """__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _core.SwigPyIterator___ne__(self, x)


    def __iadd__(self, n):
        """__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _core.SwigPyIterator___iadd__(self, n)


    def __isub__(self, n):
        """__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _core.SwigPyIterator___isub__(self, n)


    def __add__(self, n):
        """__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _core.SwigPyIterator___add__(self, n)


    def __sub__(self, *args):
        """
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _core.SwigPyIterator___sub__(self, *args)

    def __iter__(self):
        return self
SwigPyIterator_swigregister = _core.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class vector_string(_object):
    """Proxy of C++ std::vector<(std::string)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_string, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_string, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(vector_string self) -> SwigPyIterator"""
        return _core.vector_string_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(vector_string self) -> bool"""
        return _core.vector_string___nonzero__(self)


    def __bool__(self):
        """__bool__(vector_string self) -> bool"""
        return _core.vector_string___bool__(self)


    def __len__(self):
        """__len__(vector_string self) -> std::vector< std::string >::size_type"""
        return _core.vector_string___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(vector_string self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j) -> vector_string"""
        return _core.vector_string___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(vector_string self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)
        __setslice__(vector_string self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j, vector_string v)
        """
        return _core.vector_string___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(vector_string self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)"""
        return _core.vector_string___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(vector_string self, std::vector< std::string >::difference_type i)
        __delitem__(vector_string self, PySliceObject * slice)
        """
        return _core.vector_string___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(vector_string self, PySliceObject * slice) -> vector_string
        __getitem__(vector_string self, std::vector< std::string >::difference_type i) -> std::vector< std::string >::value_type const &
        """
        return _core.vector_string___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(vector_string self, PySliceObject * slice, vector_string v)
        __setitem__(vector_string self, PySliceObject * slice)
        __setitem__(vector_string self, std::vector< std::string >::difference_type i, std::vector< std::string >::value_type const & x)
        """
        return _core.vector_string___setitem__(self, *args)


    def pop(self):
        """pop(vector_string self) -> std::vector< std::string >::value_type"""
        return _core.vector_string_pop(self)


    def append(self, x):
        """append(vector_string self, std::vector< std::string >::value_type const & x)"""
        return _core.vector_string_append(self, x)


    def empty(self):
        """empty(vector_string self) -> bool"""
        return _core.vector_string_empty(self)


    def size(self):
        """size(vector_string self) -> std::vector< std::string >::size_type"""
        return _core.vector_string_size(self)


    def swap(self, v):
        """swap(vector_string self, vector_string v)"""
        return _core.vector_string_swap(self, v)


    def begin(self):
        """begin(vector_string self) -> std::vector< std::string >::iterator"""
        return _core.vector_string_begin(self)


    def end(self):
        """end(vector_string self) -> std::vector< std::string >::iterator"""
        return _core.vector_string_end(self)


    def rbegin(self):
        """rbegin(vector_string self) -> std::vector< std::string >::reverse_iterator"""
        return _core.vector_string_rbegin(self)


    def rend(self):
        """rend(vector_string self) -> std::vector< std::string >::reverse_iterator"""
        return _core.vector_string_rend(self)


    def clear(self):
        """clear(vector_string self)"""
        return _core.vector_string_clear(self)


    def get_allocator(self):
        """get_allocator(vector_string self) -> std::vector< std::string >::allocator_type"""
        return _core.vector_string_get_allocator(self)


    def pop_back(self):
        """pop_back(vector_string self)"""
        return _core.vector_string_pop_back(self)


    def erase(self, *args):
        """
        erase(vector_string self, std::vector< std::string >::iterator pos) -> std::vector< std::string >::iterator
        erase(vector_string self, std::vector< std::string >::iterator first, std::vector< std::string >::iterator last) -> std::vector< std::string >::iterator
        """
        return _core.vector_string_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::string)> self) -> vector_string
        __init__(std::vector<(std::string)> self, vector_string arg2) -> vector_string
        __init__(std::vector<(std::string)> self, std::vector< std::string >::size_type size) -> vector_string
        __init__(std::vector<(std::string)> self, std::vector< std::string >::size_type size, std::vector< std::string >::value_type const & value) -> vector_string
        """
        this = _core.new_vector_string(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(vector_string self, std::vector< std::string >::value_type const & x)"""
        return _core.vector_string_push_back(self, x)


    def front(self):
        """front(vector_string self) -> std::vector< std::string >::value_type const &"""
        return _core.vector_string_front(self)


    def back(self):
        """back(vector_string self) -> std::vector< std::string >::value_type const &"""
        return _core.vector_string_back(self)


    def assign(self, n, x):
        """assign(vector_string self, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)"""
        return _core.vector_string_assign(self, n, x)


    def resize(self, *args):
        """
        resize(vector_string self, std::vector< std::string >::size_type new_size)
        resize(vector_string self, std::vector< std::string >::size_type new_size, std::vector< std::string >::value_type const & x)
        """
        return _core.vector_string_resize(self, *args)


    def insert(self, *args):
        """
        insert(vector_string self, std::vector< std::string >::iterator pos, std::vector< std::string >::value_type const & x) -> std::vector< std::string >::iterator
        insert(vector_string self, std::vector< std::string >::iterator pos, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)
        """
        return _core.vector_string_insert(self, *args)


    def reserve(self, n):
        """reserve(vector_string self, std::vector< std::string >::size_type n)"""
        return _core.vector_string_reserve(self, n)


    def capacity(self):
        """capacity(vector_string self) -> std::vector< std::string >::size_type"""
        return _core.vector_string_capacity(self)

    __swig_destroy__ = _core.delete_vector_string
    __del__ = lambda self: None
vector_string_swigregister = _core.vector_string_swigregister
vector_string_swigregister(vector_string)

class vector_double(_object):
    """Proxy of C++ std::vector<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_double, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(vector_double self) -> SwigPyIterator"""
        return _core.vector_double_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(vector_double self) -> bool"""
        return _core.vector_double___nonzero__(self)


    def __bool__(self):
        """__bool__(vector_double self) -> bool"""
        return _core.vector_double___bool__(self)


    def __len__(self):
        """__len__(vector_double self) -> std::vector< double >::size_type"""
        return _core.vector_double___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(vector_double self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> vector_double"""
        return _core.vector_double___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(vector_double self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)
        __setslice__(vector_double self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, vector_double v)
        """
        return _core.vector_double___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(vector_double self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)"""
        return _core.vector_double___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(vector_double self, std::vector< double >::difference_type i)
        __delitem__(vector_double self, PySliceObject * slice)
        """
        return _core.vector_double___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(vector_double self, PySliceObject * slice) -> vector_double
        __getitem__(vector_double self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const &
        """
        return _core.vector_double___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(vector_double self, PySliceObject * slice, vector_double v)
        __setitem__(vector_double self, PySliceObject * slice)
        __setitem__(vector_double self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)
        """
        return _core.vector_double___setitem__(self, *args)


    def pop(self):
        """pop(vector_double self) -> std::vector< double >::value_type"""
        return _core.vector_double_pop(self)


    def append(self, x):
        """append(vector_double self, std::vector< double >::value_type const & x)"""
        return _core.vector_double_append(self, x)


    def empty(self):
        """empty(vector_double self) -> bool"""
        return _core.vector_double_empty(self)


    def size(self):
        """size(vector_double self) -> std::vector< double >::size_type"""
        return _core.vector_double_size(self)


    def swap(self, v):
        """swap(vector_double self, vector_double v)"""
        return _core.vector_double_swap(self, v)


    def begin(self):
        """begin(vector_double self) -> std::vector< double >::iterator"""
        return _core.vector_double_begin(self)


    def end(self):
        """end(vector_double self) -> std::vector< double >::iterator"""
        return _core.vector_double_end(self)


    def rbegin(self):
        """rbegin(vector_double self) -> std::vector< double >::reverse_iterator"""
        return _core.vector_double_rbegin(self)


    def rend(self):
        """rend(vector_double self) -> std::vector< double >::reverse_iterator"""
        return _core.vector_double_rend(self)


    def clear(self):
        """clear(vector_double self)"""
        return _core.vector_double_clear(self)


    def get_allocator(self):
        """get_allocator(vector_double self) -> std::vector< double >::allocator_type"""
        return _core.vector_double_get_allocator(self)


    def pop_back(self):
        """pop_back(vector_double self)"""
        return _core.vector_double_pop_back(self)


    def erase(self, *args):
        """
        erase(vector_double self, std::vector< double >::iterator pos) -> std::vector< double >::iterator
        erase(vector_double self, std::vector< double >::iterator first, std::vector< double >::iterator last) -> std::vector< double >::iterator
        """
        return _core.vector_double_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(double)> self) -> vector_double
        __init__(std::vector<(double)> self, vector_double arg2) -> vector_double
        __init__(std::vector<(double)> self, std::vector< double >::size_type size) -> vector_double
        __init__(std::vector<(double)> self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> vector_double
        """
        this = _core.new_vector_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(vector_double self, std::vector< double >::value_type const & x)"""
        return _core.vector_double_push_back(self, x)


    def front(self):
        """front(vector_double self) -> std::vector< double >::value_type const &"""
        return _core.vector_double_front(self)


    def back(self):
        """back(vector_double self) -> std::vector< double >::value_type const &"""
        return _core.vector_double_back(self)


    def assign(self, n, x):
        """assign(vector_double self, std::vector< double >::size_type n, std::vector< double >::value_type const & x)"""
        return _core.vector_double_assign(self, n, x)


    def resize(self, *args):
        """
        resize(vector_double self, std::vector< double >::size_type new_size)
        resize(vector_double self, std::vector< double >::size_type new_size, std::vector< double >::value_type const & x)
        """
        return _core.vector_double_resize(self, *args)


    def insert(self, *args):
        """
        insert(vector_double self, std::vector< double >::iterator pos, std::vector< double >::value_type const & x) -> std::vector< double >::iterator
        insert(vector_double self, std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const & x)
        """
        return _core.vector_double_insert(self, *args)


    def reserve(self, n):
        """reserve(vector_double self, std::vector< double >::size_type n)"""
        return _core.vector_double_reserve(self, n)


    def capacity(self):
        """capacity(vector_double self) -> std::vector< double >::size_type"""
        return _core.vector_double_capacity(self)

    __swig_destroy__ = _core.delete_vector_double
    __del__ = lambda self: None
vector_double_swigregister = _core.vector_double_swigregister
vector_double_swigregister(vector_double)

class vector_unsigned_long(_object):
    """Proxy of C++ std::vector<(unsigned long)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_unsigned_long, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_unsigned_long, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(vector_unsigned_long self) -> SwigPyIterator"""
        return _core.vector_unsigned_long_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(vector_unsigned_long self) -> bool"""
        return _core.vector_unsigned_long___nonzero__(self)


    def __bool__(self):
        """__bool__(vector_unsigned_long self) -> bool"""
        return _core.vector_unsigned_long___bool__(self)


    def __len__(self):
        """__len__(vector_unsigned_long self) -> std::vector< unsigned long >::size_type"""
        return _core.vector_unsigned_long___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(vector_unsigned_long self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j) -> vector_unsigned_long"""
        return _core.vector_unsigned_long___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(vector_unsigned_long self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j)
        __setslice__(vector_unsigned_long self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j, vector_unsigned_long v)
        """
        return _core.vector_unsigned_long___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(vector_unsigned_long self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j)"""
        return _core.vector_unsigned_long___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(vector_unsigned_long self, std::vector< unsigned long >::difference_type i)
        __delitem__(vector_unsigned_long self, PySliceObject * slice)
        """
        return _core.vector_unsigned_long___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(vector_unsigned_long self, PySliceObject * slice) -> vector_unsigned_long
        __getitem__(vector_unsigned_long self, std::vector< unsigned long >::difference_type i) -> std::vector< unsigned long >::value_type const &
        """
        return _core.vector_unsigned_long___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(vector_unsigned_long self, PySliceObject * slice, vector_unsigned_long v)
        __setitem__(vector_unsigned_long self, PySliceObject * slice)
        __setitem__(vector_unsigned_long self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::value_type const & x)
        """
        return _core.vector_unsigned_long___setitem__(self, *args)


    def pop(self):
        """pop(vector_unsigned_long self) -> std::vector< unsigned long >::value_type"""
        return _core.vector_unsigned_long_pop(self)


    def append(self, x):
        """append(vector_unsigned_long self, std::vector< unsigned long >::value_type const & x)"""
        return _core.vector_unsigned_long_append(self, x)


    def empty(self):
        """empty(vector_unsigned_long self) -> bool"""
        return _core.vector_unsigned_long_empty(self)


    def size(self):
        """size(vector_unsigned_long self) -> std::vector< unsigned long >::size_type"""
        return _core.vector_unsigned_long_size(self)


    def swap(self, v):
        """swap(vector_unsigned_long self, vector_unsigned_long v)"""
        return _core.vector_unsigned_long_swap(self, v)


    def begin(self):
        """begin(vector_unsigned_long self) -> std::vector< unsigned long >::iterator"""
        return _core.vector_unsigned_long_begin(self)


    def end(self):
        """end(vector_unsigned_long self) -> std::vector< unsigned long >::iterator"""
        return _core.vector_unsigned_long_end(self)


    def rbegin(self):
        """rbegin(vector_unsigned_long self) -> std::vector< unsigned long >::reverse_iterator"""
        return _core.vector_unsigned_long_rbegin(self)


    def rend(self):
        """rend(vector_unsigned_long self) -> std::vector< unsigned long >::reverse_iterator"""
        return _core.vector_unsigned_long_rend(self)


    def clear(self):
        """clear(vector_unsigned_long self)"""
        return _core.vector_unsigned_long_clear(self)


    def get_allocator(self):
        """get_allocator(vector_unsigned_long self) -> std::vector< unsigned long >::allocator_type"""
        return _core.vector_unsigned_long_get_allocator(self)


    def pop_back(self):
        """pop_back(vector_unsigned_long self)"""
        return _core.vector_unsigned_long_pop_back(self)


    def erase(self, *args):
        """
        erase(vector_unsigned_long self, std::vector< unsigned long >::iterator pos) -> std::vector< unsigned long >::iterator
        erase(vector_unsigned_long self, std::vector< unsigned long >::iterator first, std::vector< unsigned long >::iterator last) -> std::vector< unsigned long >::iterator
        """
        return _core.vector_unsigned_long_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(unsigned long)> self) -> vector_unsigned_long
        __init__(std::vector<(unsigned long)> self, vector_unsigned_long arg2) -> vector_unsigned_long
        __init__(std::vector<(unsigned long)> self, std::vector< unsigned long >::size_type size) -> vector_unsigned_long
        __init__(std::vector<(unsigned long)> self, std::vector< unsigned long >::size_type size, std::vector< unsigned long >::value_type const & value) -> vector_unsigned_long
        """
        this = _core.new_vector_unsigned_long(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(vector_unsigned_long self, std::vector< unsigned long >::value_type const & x)"""
        return _core.vector_unsigned_long_push_back(self, x)


    def front(self):
        """front(vector_unsigned_long self) -> std::vector< unsigned long >::value_type const &"""
        return _core.vector_unsigned_long_front(self)


    def back(self):
        """back(vector_unsigned_long self) -> std::vector< unsigned long >::value_type const &"""
        return _core.vector_unsigned_long_back(self)


    def assign(self, n, x):
        """assign(vector_unsigned_long self, std::vector< unsigned long >::size_type n, std::vector< unsigned long >::value_type const & x)"""
        return _core.vector_unsigned_long_assign(self, n, x)


    def resize(self, *args):
        """
        resize(vector_unsigned_long self, std::vector< unsigned long >::size_type new_size)
        resize(vector_unsigned_long self, std::vector< unsigned long >::size_type new_size, std::vector< unsigned long >::value_type const & x)
        """
        return _core.vector_unsigned_long_resize(self, *args)


    def insert(self, *args):
        """
        insert(vector_unsigned_long self, std::vector< unsigned long >::iterator pos, std::vector< unsigned long >::value_type const & x) -> std::vector< unsigned long >::iterator
        insert(vector_unsigned_long self, std::vector< unsigned long >::iterator pos, std::vector< unsigned long >::size_type n, std::vector< unsigned long >::value_type const & x)
        """
        return _core.vector_unsigned_long_insert(self, *args)


    def reserve(self, n):
        """reserve(vector_unsigned_long self, std::vector< unsigned long >::size_type n)"""
        return _core.vector_unsigned_long_reserve(self, n)


    def capacity(self):
        """capacity(vector_unsigned_long self) -> std::vector< unsigned long >::size_type"""
        return _core.vector_unsigned_long_capacity(self)

    __swig_destroy__ = _core.delete_vector_unsigned_long
    __del__ = lambda self: None
vector_unsigned_long_swigregister = _core.vector_unsigned_long_swigregister
vector_unsigned_long_swigregister(vector_unsigned_long)

class array_double(_object):
    """Proxy of C++ array_double class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, array_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, array_double, name)
    __repr__ = _swig_repr

    def __init__(self, nelements):
        """__init__(array_double self, size_t nelements) -> array_double"""
        this = _core.new_array_double(nelements)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_array_double
    __del__ = lambda self: None

    def __getitem__(self, index):
        """__getitem__(array_double self, size_t index) -> double"""
        return _core.array_double___getitem__(self, index)


    def __setitem__(self, index, value):
        """__setitem__(array_double self, size_t index, double value)"""
        return _core.array_double___setitem__(self, index, value)


    def cast(self):
        """cast(array_double self) -> double *"""
        return _core.array_double_cast(self)


    def frompointer(t):
        """frompointer(double * t) -> array_double"""
        return _core.array_double_frompointer(t)

    frompointer = staticmethod(frompointer)

    def fromnumpy1(IN_ARRAY1):
        """fromnumpy1(double * IN_ARRAY1) -> array_double"""
        return _core.array_double_fromnumpy1(IN_ARRAY1)

    fromnumpy1 = staticmethod(fromnumpy1)

    def fromnumpy2(IN_ARRAY2):
        """fromnumpy2(double * IN_ARRAY2) -> array_double"""
        return _core.array_double_fromnumpy2(IN_ARRAY2)

    fromnumpy2 = staticmethod(fromnumpy2)

    def fromnumpy3(IN_ARRAY3):
        """fromnumpy3(double * IN_ARRAY3) -> array_double"""
        return _core.array_double_fromnumpy3(IN_ARRAY3)

    fromnumpy3 = staticmethod(fromnumpy3)

    def fromnumpy4(IN_ARRAY4):
        """fromnumpy4(double * IN_ARRAY4) -> array_double"""
        return _core.array_double_fromnumpy4(IN_ARRAY4)

    fromnumpy4 = staticmethod(fromnumpy4)
array_double_swigregister = _core.array_double_swigregister
array_double_swigregister(array_double)

def array_double_frompointer(t):
    """array_double_frompointer(double * t) -> array_double"""
    return _core.array_double_frompointer(t)

def array_double_fromnumpy1(IN_ARRAY1):
    """array_double_fromnumpy1(double * IN_ARRAY1) -> array_double"""
    return _core.array_double_fromnumpy1(IN_ARRAY1)

def array_double_fromnumpy2(IN_ARRAY2):
    """array_double_fromnumpy2(double * IN_ARRAY2) -> array_double"""
    return _core.array_double_fromnumpy2(IN_ARRAY2)

def array_double_fromnumpy3(IN_ARRAY3):
    """array_double_fromnumpy3(double * IN_ARRAY3) -> array_double"""
    return _core.array_double_fromnumpy3(IN_ARRAY3)

def array_double_fromnumpy4(IN_ARRAY4):
    """array_double_fromnumpy4(double * IN_ARRAY4) -> array_double"""
    return _core.array_double_fromnumpy4(IN_ARRAY4)

class array_size_t(_object):
    """Proxy of C++ array_size_t class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, array_size_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, array_size_t, name)
    __repr__ = _swig_repr

    def __init__(self, nelements):
        """__init__(array_size_t self, size_t nelements) -> array_size_t"""
        this = _core.new_array_size_t(nelements)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_array_size_t
    __del__ = lambda self: None

    def __getitem__(self, index):
        """__getitem__(array_size_t self, size_t index) -> size_t"""
        return _core.array_size_t___getitem__(self, index)


    def __setitem__(self, index, value):
        """__setitem__(array_size_t self, size_t index, size_t value)"""
        return _core.array_size_t___setitem__(self, index, value)


    def cast(self):
        """cast(array_size_t self) -> size_t *"""
        return _core.array_size_t_cast(self)


    def frompointer(t):
        """frompointer(size_t * t) -> array_size_t"""
        return _core.array_size_t_frompointer(t)

    frompointer = staticmethod(frompointer)

    def fromnumpy1(IN_ARRAY1):
        """fromnumpy1(size_t * IN_ARRAY1) -> array_size_t"""
        return _core.array_size_t_fromnumpy1(IN_ARRAY1)

    fromnumpy1 = staticmethod(fromnumpy1)

    def fromnumpy2(IN_ARRAY2):
        """fromnumpy2(size_t * IN_ARRAY2) -> array_size_t"""
        return _core.array_size_t_fromnumpy2(IN_ARRAY2)

    fromnumpy2 = staticmethod(fromnumpy2)

    def fromnumpy3(IN_ARRAY3):
        """fromnumpy3(size_t * IN_ARRAY3) -> array_size_t"""
        return _core.array_size_t_fromnumpy3(IN_ARRAY3)

    fromnumpy3 = staticmethod(fromnumpy3)

    def fromnumpy4(IN_ARRAY4):
        """fromnumpy4(size_t * IN_ARRAY4) -> array_size_t"""
        return _core.array_size_t_fromnumpy4(IN_ARRAY4)

    fromnumpy4 = staticmethod(fromnumpy4)
array_size_t_swigregister = _core.array_size_t_swigregister
array_size_t_swigregister(array_size_t)

def array_size_t_frompointer(t):
    """array_size_t_frompointer(size_t * t) -> array_size_t"""
    return _core.array_size_t_frompointer(t)

def array_size_t_fromnumpy1(IN_ARRAY1):
    """array_size_t_fromnumpy1(size_t * IN_ARRAY1) -> array_size_t"""
    return _core.array_size_t_fromnumpy1(IN_ARRAY1)

def array_size_t_fromnumpy2(IN_ARRAY2):
    """array_size_t_fromnumpy2(size_t * IN_ARRAY2) -> array_size_t"""
    return _core.array_size_t_fromnumpy2(IN_ARRAY2)

def array_size_t_fromnumpy3(IN_ARRAY3):
    """array_size_t_fromnumpy3(size_t * IN_ARRAY3) -> array_size_t"""
    return _core.array_size_t_fromnumpy3(IN_ARRAY3)

def array_size_t_fromnumpy4(IN_ARRAY4):
    """array_size_t_fromnumpy4(size_t * IN_ARRAY4) -> array_size_t"""
    return _core.array_size_t_fromnumpy4(IN_ARRAY4)

class array_unsigned_long(_object):
    """Proxy of C++ array_unsigned_long class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, array_unsigned_long, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, array_unsigned_long, name)
    __repr__ = _swig_repr

    def __init__(self, nelements):
        """__init__(array_unsigned_long self, size_t nelements) -> array_unsigned_long"""
        this = _core.new_array_unsigned_long(nelements)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_array_unsigned_long
    __del__ = lambda self: None

    def __getitem__(self, index):
        """__getitem__(array_unsigned_long self, size_t index) -> unsigned long"""
        return _core.array_unsigned_long___getitem__(self, index)


    def __setitem__(self, index, value):
        """__setitem__(array_unsigned_long self, size_t index, unsigned long value)"""
        return _core.array_unsigned_long___setitem__(self, index, value)


    def cast(self):
        """cast(array_unsigned_long self) -> unsigned long *"""
        return _core.array_unsigned_long_cast(self)


    def frompointer(t):
        """frompointer(unsigned long * t) -> array_unsigned_long"""
        return _core.array_unsigned_long_frompointer(t)

    frompointer = staticmethod(frompointer)

    def fromnumpy1(IN_ARRAY1, DIM1):
        """fromnumpy1(unsigned long * IN_ARRAY1, size_t DIM1) -> array_unsigned_long"""
        return _core.array_unsigned_long_fromnumpy1(IN_ARRAY1, DIM1)

    fromnumpy1 = staticmethod(fromnumpy1)

    def fromnumpy2(IN_ARRAY2, DIM1, DIM2):
        """fromnumpy2(unsigned long * IN_ARRAY2, size_t DIM1, size_t DIM2) -> array_unsigned_long"""
        return _core.array_unsigned_long_fromnumpy2(IN_ARRAY2, DIM1, DIM2)

    fromnumpy2 = staticmethod(fromnumpy2)

    def fromnumpy3(IN_ARRAY3, DIM1, DIM2, DIM3):
        """fromnumpy3(unsigned long * IN_ARRAY3, size_t DIM1, size_t DIM2, size_t DIM3) -> array_unsigned_long"""
        return _core.array_unsigned_long_fromnumpy3(IN_ARRAY3, DIM1, DIM2, DIM3)

    fromnumpy3 = staticmethod(fromnumpy3)

    def fromnumpy4(IN_ARRAY4, DIM1, DIM2, DIM3, DIM4):
        """fromnumpy4(unsigned long * IN_ARRAY4, size_t DIM1, size_t DIM2, size_t DIM3, size_t DIM4) -> array_unsigned_long"""
        return _core.array_unsigned_long_fromnumpy4(IN_ARRAY4, DIM1, DIM2, DIM3, DIM4)

    fromnumpy4 = staticmethod(fromnumpy4)
array_unsigned_long_swigregister = _core.array_unsigned_long_swigregister
array_unsigned_long_swigregister(array_unsigned_long)

def array_unsigned_long_frompointer(t):
    """array_unsigned_long_frompointer(unsigned long * t) -> array_unsigned_long"""
    return _core.array_unsigned_long_frompointer(t)

def array_unsigned_long_fromnumpy1(IN_ARRAY1, DIM1):
    """array_unsigned_long_fromnumpy1(unsigned long * IN_ARRAY1, size_t DIM1) -> array_unsigned_long"""
    return _core.array_unsigned_long_fromnumpy1(IN_ARRAY1, DIM1)

def array_unsigned_long_fromnumpy2(IN_ARRAY2, DIM1, DIM2):
    """array_unsigned_long_fromnumpy2(unsigned long * IN_ARRAY2, size_t DIM1, size_t DIM2) -> array_unsigned_long"""
    return _core.array_unsigned_long_fromnumpy2(IN_ARRAY2, DIM1, DIM2)

def array_unsigned_long_fromnumpy3(IN_ARRAY3, DIM1, DIM2, DIM3):
    """array_unsigned_long_fromnumpy3(unsigned long * IN_ARRAY3, size_t DIM1, size_t DIM2, size_t DIM3) -> array_unsigned_long"""
    return _core.array_unsigned_long_fromnumpy3(IN_ARRAY3, DIM1, DIM2, DIM3)

def array_unsigned_long_fromnumpy4(IN_ARRAY4, DIM1, DIM2, DIM3, DIM4):
    """array_unsigned_long_fromnumpy4(unsigned long * IN_ARRAY4, size_t DIM1, size_t DIM2, size_t DIM3, size_t DIM4) -> array_unsigned_long"""
    return _core.array_unsigned_long_fromnumpy4(IN_ARRAY4, DIM1, DIM2, DIM3, DIM4)

GYOTO_DEBUG_ENABLED = _core.GYOTO_DEBUG_ENABLED
GYOTO_PLUGIN_SFX = _core.GYOTO_PLUGIN_SFX
GYOTO_SIZE__T_IS_UNSIGNED_LONG = _core.GYOTO_SIZE__T_IS_UNSIGNED_LONG
GYOTO_SOVERS = _core.GYOTO_SOVERS
GYOTO_USE_ARBLIB = _core.GYOTO_USE_ARBLIB
GYOTO_USE_CFITSIO = _core.GYOTO_USE_CFITSIO
GYOTO_USE_UDUNITS = _core.GYOTO_USE_UDUNITS
GYOTO_USE_XERCES = _core.GYOTO_USE_XERCES
HAVE_DLFCN_H = _core.HAVE_DLFCN_H
HAVE_INTTYPES_H = _core.HAVE_INTTYPES_H
HAVE_LIBDL = _core.HAVE_LIBDL
HAVE_MPI = _core.HAVE_MPI
HAVE_PTHREAD = _core.HAVE_PTHREAD
HAVE_PTHREAD_PRIO_INHERIT = _core.HAVE_PTHREAD_PRIO_INHERIT
HAVE_SINCOS = _core.HAVE_SINCOS
HAVE_STDINT_H = _core.HAVE_STDINT_H
HAVE_STDLIB_H = _core.HAVE_STDLIB_H
HAVE_STRINGS_H = _core.HAVE_STRINGS_H
HAVE_STRING_H = _core.HAVE_STRING_H
HAVE_SYS_STAT_H = _core.HAVE_SYS_STAT_H
HAVE_SYS_TYPES_H = _core.HAVE_SYS_TYPES_H
HAVE_BOOST_MULTIPRECISION_CPP_DEC_FLOAT_HPP = _core.HAVE_BOOST_MULTIPRECISION_CPP_DEC_FLOAT_HPP
HAVE_BOOST_ARRAY_HPP = _core.HAVE_BOOST_ARRAY_HPP
GYOTO_HAVE_BOOST_INTEGRATORS = _core.GYOTO_HAVE_BOOST_INTEGRATORS
HAVE_UNISTD_H = _core.HAVE_UNISTD_H
HAVE_FENV_H = _core.HAVE_FENV_H
STDC_HEADERS = _core.STDC_HEADERS
GYOTO_QUANTITY_NONE = _core.GYOTO_QUANTITY_NONE
GYOTO_QUANTITY_INTENSITY = _core.GYOTO_QUANTITY_INTENSITY
GYOTO_QUANTITY_EMISSIONTIME = _core.GYOTO_QUANTITY_EMISSIONTIME
GYOTO_QUANTITY_MIN_DISTANCE = _core.GYOTO_QUANTITY_MIN_DISTANCE
GYOTO_QUANTITY_FIRST_DMIN = _core.GYOTO_QUANTITY_FIRST_DMIN
GYOTO_QUANTITY_REDSHIFT = _core.GYOTO_QUANTITY_REDSHIFT
GYOTO_QUANTITY_IMPACTCOORDS = _core.GYOTO_QUANTITY_IMPACTCOORDS
GYOTO_QUANTITY_SPECTRUM = _core.GYOTO_QUANTITY_SPECTRUM
GYOTO_QUANTITY_SPECTRUM_STOKES_Q = _core.GYOTO_QUANTITY_SPECTRUM_STOKES_Q
GYOTO_QUANTITY_SPECTRUM_STOKES_U = _core.GYOTO_QUANTITY_SPECTRUM_STOKES_U
GYOTO_QUANTITY_SPECTRUM_STOKES_V = _core.GYOTO_QUANTITY_SPECTRUM_STOKES_V
GYOTO_QUANTITY_BINSPECTRUM = _core.GYOTO_QUANTITY_BINSPECTRUM
GYOTO_QUANTITY_NBCROSSEQPLANE = _core.GYOTO_QUANTITY_NBCROSSEQPLANE
GYOTO_QUANTITY_USER1 = _core.GYOTO_QUANTITY_USER1
GYOTO_QUANTITY_USER2 = _core.GYOTO_QUANTITY_USER2
GYOTO_QUANTITY_USER3 = _core.GYOTO_QUANTITY_USER3
GYOTO_QUANTITY_USER4 = _core.GYOTO_QUANTITY_USER4
GYOTO_QUANTITY_USER5 = _core.GYOTO_QUANTITY_USER5
GYOTO_QUANTITY_SPECTRAL = _core.GYOTO_QUANTITY_SPECTRAL
GYOTO_QUANTITY_SPECTRUM_STOKES = _core.GYOTO_QUANTITY_SPECTRUM_STOKES
GYOTO_DEFAULT_DEBUG_MODE = _core.GYOTO_DEFAULT_DEBUG_MODE
GYOTO_QUIET_VERBOSITY = _core.GYOTO_QUIET_VERBOSITY
GYOTO_SEVERE_VERBOSITY = _core.GYOTO_SEVERE_VERBOSITY
GYOTO_WARNING_VERBOSITY = _core.GYOTO_WARNING_VERBOSITY
GYOTO_DEFAULT_VERBOSITY = _core.GYOTO_DEFAULT_VERBOSITY
GYOTO_INFO_VERBOSITY = _core.GYOTO_INFO_VERBOSITY
GYOTO_DEBUG_VERBOSITY = _core.GYOTO_DEBUG_VERBOSITY
GYOTO_COORDKIND_UNSPECIFIED = _core.GYOTO_COORDKIND_UNSPECIFIED
GYOTO_COORDKIND_CARTESIAN = _core.GYOTO_COORDKIND_CARTESIAN
GYOTO_COORDKIND_SPHERICAL = _core.GYOTO_COORDKIND_SPHERICAL
GYOTO_DEFAULT_X_SIZE = _core.GYOTO_DEFAULT_X_SIZE
GYOTO_DEFAULT_DELTA = _core.GYOTO_DEFAULT_DELTA
GYOTO_DEFAULT_DELTA_MAX_OVER_R = _core.GYOTO_DEFAULT_DELTA_MAX_OVER_R
GYOTO_DEFAULT_ABSTOL = _core.GYOTO_DEFAULT_ABSTOL
GYOTO_DEFAULT_RELTOL = _core.GYOTO_DEFAULT_RELTOL
GYOTO_DEFAULT_MAXITER = _core.GYOTO_DEFAULT_MAXITER
GYOTO_T_TOL = _core.GYOTO_T_TOL
GYOTO_KERR_HORIZON_SECURITY = _core.GYOTO_KERR_HORIZON_SECURITY
GYOTO_PREC = _core.GYOTO_PREC
GYOTO_WIDTH = _core.GYOTO_WIDTH
GYOTO_DEFAULT_PLUGINS = _core.GYOTO_DEFAULT_PLUGINS
GYOTO_C = _core.GYOTO_C
GYOTO_C_CGS = _core.GYOTO_C_CGS
GYOTO_C2_CGS = _core.GYOTO_C2_CGS
GYOTO_C2_CGS_M1 = _core.GYOTO_C2_CGS_M1
GYOTO_G = _core.GYOTO_G
GYOTO_G_CGS = _core.GYOTO_G_CGS
GYOTO_G_OVER_C_SQUARE = _core.GYOTO_G_OVER_C_SQUARE
GYOTO_G_OVER_C_SQUARE_CGS = _core.GYOTO_G_OVER_C_SQUARE_CGS
GYOTO_PLANCK = _core.GYOTO_PLANCK
GYOTO_PLANCK_CGS = _core.GYOTO_PLANCK_CGS
GYOTO_PLANCK_OVER_C_SQUARE = _core.GYOTO_PLANCK_OVER_C_SQUARE
GYOTO_BOLTZMANN = _core.GYOTO_BOLTZMANN
GYOTO_BOLTZMANN_CGS = _core.GYOTO_BOLTZMANN_CGS
GYOTO_STEFANBOLTZMANN_CGS = _core.GYOTO_STEFANBOLTZMANN_CGS
GYOTO_PLANCK_OVER_BOLTZMANN = _core.GYOTO_PLANCK_OVER_BOLTZMANN
GYOTO_GAS_CST = _core.GYOTO_GAS_CST
GYOTO_GAS_CST_CGS = _core.GYOTO_GAS_CST_CGS
GYOTO_AVOGADRO = _core.GYOTO_AVOGADRO
GYOTO_THOMSON_CGS = _core.GYOTO_THOMSON_CGS
GYOTO_ALPHA_F = _core.GYOTO_ALPHA_F
GYOTO_PROTON_MASS_CGS = _core.GYOTO_PROTON_MASS_CGS
GYOTO_ELECTRON_MASS_CGS = _core.GYOTO_ELECTRON_MASS_CGS
GYOTO_ELECTRON_CLASSICAL_RADIUS_CGS = _core.GYOTO_ELECTRON_CLASSICAL_RADIUS_CGS
GYOTO_ELEMENTARY_CHARGE_CGS = _core.GYOTO_ELEMENTARY_CHARGE_CGS
GYOTO_EULER_MASCHERONI = _core.GYOTO_EULER_MASCHERONI
GYOTO_ATOMIC_MASS_UNIT_CGS = _core.GYOTO_ATOMIC_MASS_UNIT_CGS
GYOTO_INU_CGS_TO_SI = _core.GYOTO_INU_CGS_TO_SI
GYOTO_JNU_CGS_TO_SI = _core.GYOTO_JNU_CGS_TO_SI
GYOTO_ANU_CGS_TO_SI = _core.GYOTO_ANU_CGS_TO_SI
GYOTO_SUN_MASS = _core.GYOTO_SUN_MASS
GYOTO_SUN_MASS_CGS = _core.GYOTO_SUN_MASS_CGS
GYOTO_SUN_RADIUS = _core.GYOTO_SUN_RADIUS
GYOTO_KPC = _core.GYOTO_KPC
GYOTO_ASTRONOMICAL_UNIT = _core.GYOTO_ASTRONOMICAL_UNIT
GYOTO_LIGHT_YEAR = _core.GYOTO_LIGHT_YEAR
GYOTO_RADEG = _core.GYOTO_RADEG
GYOTO_DEGRAD = _core.GYOTO_DEGRAD
GYOTO_MINRAD = _core.GYOTO_MINRAD
GYOTO_SECRAD = _core.GYOTO_SECRAD
GYOTO_MASRAD = _core.GYOTO_MASRAD
GYOTO_MUASRAD = _core.GYOTO_MUASRAD
GYOTO_eV2Hz = _core.GYOTO_eV2Hz
GYOTO_OBSKIND_ATINFINITY = _core.GYOTO_OBSKIND_ATINFINITY
GYOTO_OBSKIND_KEPLERIAN = _core.GYOTO_OBSKIND_KEPLERIAN
GYOTO_OBSKIND_ZAMO = _core.GYOTO_OBSKIND_ZAMO
GYOTO_OBSKIND_VELOCITYSPECIFIED = _core.GYOTO_OBSKIND_VELOCITYSPECIFIED
GYOTO_OBSKIND_FULLYSPECIFIED = _core.GYOTO_OBSKIND_FULLYSPECIFIED
class Error(Exception):
    """


    Class for thowing exceptions.

    Gyoto dlopens its plug-ins. The throw/catch C++ mechanism cannot pass
    the dlopen boundary. The Gyoto::Error mechanism alleviates this C++
    language limitation.

    Every Gyoto method (either in the main Gyoto library or in a Gyoto
    plug-in) should check for possible error conditions and throw adequate
    Gyoto::Error exceptions through the GYOTO_ERROR macro (which calls the
    Gyoto::throwError() function). For instance:

    If the main code has set Gyoto::Error::handler_t error handler using
    Gyoto::Error::setHandler(), these errors will then be passed to it.
    Else, the Error is C++-thrown at the main Gyoto library level, above
    the dlopen boundary.

    The main code can then catch these exceptions and act appropriately,
    for instance:

    C++ includes: GyotoError.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Error, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Error, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Gyoto::Error self, std::string const m) -> Error
        __init__(Gyoto::Error self, Error o) -> Error
        """
        this = _core.new_Error(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Report(self):
        """
        Report(Error self)



        Print-out error message on standard error. 
        """
        return _core.Error_Report(self)


    def getErrcode(self):
        """
        getErrcode(Error self) -> int



        Retrieve error code.

        See also operator const char * () const and get_message().  Error code

        """
        return _core.Error_getErrcode(self)


    def get_message(self):
        """
        get_message(Error self) -> std::string



        Retrieve error message for custom handling of the exception.

        See also operator const char * () const and getErrCode(). char*
        message : pointer to the error message 
        """
        return _core.Error_get_message(self)


    def setHandler(phandler):
        """setHandler(Gyoto::Error::Handler_t * phandler)"""
        return _core.Error_setHandler(phandler)

    setHandler = staticmethod(setHandler)

    def __str__(self):
        """__str__(Error self) -> char const *"""
        return _core.Error___str__(self)

    __swig_destroy__ = _core.delete_Error
    __del__ = lambda self: None
Error_swigregister = _core.Error_swigregister
Error_swigregister(Error)

def Error_setHandler(phandler):
    """Error_setHandler(Gyoto::Error::Handler_t * phandler)"""
    return _core.Error_setHandler(phandler)


def throwError(arg1):
    """throwError(std::string arg1)"""
    return _core.throwError(arg1)
class SmartPointee(_object):
    """


    Can be pointed to by a SmartPointer.

    A class can be pointed to by a SmartPointer when it inherits from
    class SmartPointee.

    The SmartPointee methods need to be public to be accessed by all the
    SmartPointer < T > classes. However, it is a bad idea to manipulate
    the counter directly. To protect these methods inside your derive
    object, you can do as in the following example:

    C++ includes: GyotoSmartPointer.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SmartPointee, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SmartPointee, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _core.delete_SmartPointee
    __del__ = lambda self: None

    def __init__(self, *args):
        """
        __init__(Gyoto::SmartPointee self) -> SmartPointee
        __init__(Gyoto::SmartPointee self, SmartPointee arg2) -> SmartPointee



        Copy constructor. 
        """
        this = _core.new_SmartPointee(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def incRefCount(self):
        """
        incRefCount(SmartPointee self)



        Increment the reference counter. Warning: Don't mess with the counter.

        """
        return _core.SmartPointee_incRefCount(self)


    def decRefCount(self):
        """
        decRefCount(SmartPointee self) -> int



        Decrement the reference counter and return current value. Warning:
        Don't mess with the counter. 
        """
        return _core.SmartPointee_decRefCount(self)


    def getRefCount(self):
        """
        getRefCount(SmartPointee self) -> int



        Get the current number of references. 
        """
        return _core.SmartPointee_getRefCount(self)


    def getPointer(self):
        """getPointer(SmartPointee self) -> long"""
        return _core.SmartPointee_getPointer(self)

SmartPointee_swigregister = _core.SmartPointee_swigregister
SmartPointee_swigregister(SmartPointee)


def initRegister(pluglist=None):
    """
    initRegister(char const * pluglist=None)
    initRegister()



    Initialise the various registers.

    Normally called once at application start-up, Register::init()
    initiaizes the registers, loads the plug-ins, and fills the registers
    as appropriate.

    Parameters:
    -----------

    pluglist:  Coma-separated list of plug-ins to load. If NULL, default
    to the environment variable GYOTO_PLUGINS, if it exists. Else use
    GYOTO_DEFAULT_PLUGINS. Failing to load a plug-in prepended with
    "nofail:" is not fatal. 
    """
    return _core.initRegister(pluglist)

def listRegister():
    """
    listRegister()



    List the various registers. 
    """
    return _core.listRegister()

def loadPlugin(plugname, nofail=0):
    """
    loadPlugin(char const *const plugname, int nofail=0)
    loadPlugin(char const *const plugname) -> void *
    """
    return _core.loadPlugin(plugname, nofail)

def havePlugin(plugname):
    """havePlugin(std::string plugname) -> bool"""
    return _core.havePlugin(plugname)

def requirePlugin(plugname, nofail=0):
    """
    requirePlugin(std::string plugname, int nofail=0)
    requirePlugin(std::string plugname)
    """
    return _core.requirePlugin(plugname, nofail)
class RegisterEntry(_object):
    """


    Entry in a register (or a full register)

    A register is actually a chained list of Register::Entry instances.

    C++ includes: GyotoRegister.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RegisterEntry, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RegisterEntry, name)
    __repr__ = _swig_repr

    def __init__(self, name, subcontractor, next):
        """
        __init__(Gyoto::Register::Entry self, std::string name, Gyoto::SmartPointee::Subcontractor_t * subcontractor, RegisterEntry next) -> RegisterEntry



        Constructor. 
        """
        this = _core.new_RegisterEntry(name, subcontractor, next)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_RegisterEntry
    __del__ = lambda self: None

    def getSubcontractor(self, name, plugin, errmode=0):
        """
        getSubcontractor(RegisterEntry self, std::string name, std::string & plugin, int errmode=0) -> Gyoto::SmartPointee::Subcontractor_t
        getSubcontractor(RegisterEntry self, std::string name, std::string & plugin) -> Gyoto::SmartPointee::Subcontractor_t *



        Get subcontractor for a given name.

        Search through the register for an Entry matching name and return the
        corresponding subcontractor. If plugin is specified, only a
        subcontractor matching both name and plugin will be returned. Note
        that Gyoto::Entry::getSubcontractor() will not load the plug-in for
        you, contrary to e.g. Gyoto::Metric::getSubcontractor(). If plugin is
        the empty string, then the first subcontractor matching name will be
        returned, and the name of the plug-in it belongs to will be returned
        in plugin upon output.

        Parameters:
        -----------

        name:  Name of the kind to look for.

        plugin:  e.g. "stdplug".

        errmode:  1 if getSubContractor() should return NULL upon failure.
        Else a Gyoto::Error is thrown.

        Pointer to subcontractor function. 
        """
        return _core.RegisterEntry_getSubcontractor(self, name, plugin, errmode)

RegisterEntry_swigregister = _core.RegisterEntry_swigregister
RegisterEntry_swigregister(RegisterEntry)

class Functor__Double_constDoubleArray(_object):
    """


    A functor like double (func) (double const data[])

    C++ includes: GyotoFunctors.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Functor__Double_constDoubleArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Functor__Double_constDoubleArray, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _core.delete_Functor__Double_constDoubleArray
    __del__ = lambda self: None

    def __call__(self, data):
        """__call__(Functor__Double_constDoubleArray self, double const [] data) -> double"""
        return _core.Functor__Double_constDoubleArray___call__(self, data)

Functor__Double_constDoubleArray_swigregister = _core.Functor__Double_constDoubleArray_swigregister
Functor__Double_constDoubleArray_swigregister(Functor__Double_constDoubleArray)

class Functor__Double_Double_const(_object):
    """


    A functor like double (func) (double) const.

    C++ includes: GyotoFunctors.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Functor__Double_Double_const, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Functor__Double_Double_const, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _core.delete_Functor__Double_Double_const
    __del__ = lambda self: None
    __swig_setmethods__["status"] = _core.Functor__Double_Double_const_status_set
    __swig_getmethods__["status"] = _core.Functor__Double_Double_const_status_get
    if _newclass:
        status = _swig_property(_core.Functor__Double_Double_const_status_get, _core.Functor__Double_Double_const_status_set)

    def __call__(self, arg2):
        """__call__(Functor__Double_Double_const self, double arg2) -> double"""
        return _core.Functor__Double_Double_const___call__(self, arg2)


    def ridders(self, arg2, to):
        """
        ridders(Functor__Double_Double_const self, double arg2, double to) -> double



        Ridder's root-finding method applied on operator()()

        Parameters:
        -----------

        from:  to:  boundaries for root-searching

        the root 
        """
        return _core.Functor__Double_Double_const_ridders(self, arg2, to)


    def secant(self, arg2, to):
        """
        secant(Functor__Double_Double_const self, double arg2, double to) -> double



        Secant root-finding method applied on operator()()

        Sets status to -0 in case of convergence -1 if two distinct inputs
        evaluated to the same output -2 if maximum number of iterations (20)
        reached

        Parameters:
        -----------

        from:  to:  boundaries for root-finding

        the root 
        """
        return _core.Functor__Double_Double_const_secant(self, arg2, to)

Functor__Double_Double_const_swigregister = _core.Functor__Double_Double_const_swigregister
Functor__Double_Double_const_swigregister(Functor__Double_Double_const)

class Listener(_object):
    """


    I might listen to a Teller.

    Whisper to my ear by using my tell() method.

    C++ includes: GyotoHooks.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Listener, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Listener, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(Gyoto::Hook::Listener self) -> Listener



        Constructor. 
        """
        this = _core.new_Listener()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_Listener
    __del__ = lambda self: None
Listener_swigregister = _core.Listener_swigregister
Listener_swigregister(Listener)

class Teller(_object):
    """


    Listen to me and I'll warn you when I change.

    Listen to me by calling my hook() method.

    C++ includes: GyotoHooks.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Teller, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Teller, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Gyoto::Hook::Teller self) -> Teller
        __init__(Gyoto::Hook::Teller self, Teller arg2) -> Teller



        Copy constructor. 
        """
        this = _core.new_Teller(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_Teller
    __del__ = lambda self: None

    def hook(self, listener):
        """
        hook(Teller self, Listener listener)



        Start listening.

        Use from a Hook::Listener object method: where "this" is a Listener
        and "teller" is a Teller.

        Use unhook() later to stop listening to a given Teller.

        Parameters:
        -----------

        listener:  pointer to the new listener 
        """
        return _core.Teller_hook(self, listener)


    def unhook(self, listener):
        """
        unhook(Teller self, Listener listener)



        Stop listening.

        Use from a Hook::Listener object method:

        where "this" is a Listener, "teller" is a Teller, and "this" has
        called teller->hook(this) previously.

        Parameters:
        -----------

        listener:  pointer to the listener 
        """
        return _core.Teller_unhook(self, listener)

Teller_swigregister = _core.Teller_swigregister
Teller_swigregister(Teller)

class WIP(_object):
    """


    Base class for work in progress.

    The constructors of this class simply issue a warning that the
    (derived) class is work in progress.

    C++ includes: GyotoWIP.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, WIP, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, WIP, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Gyoto::WIP self) -> WIP
        __init__(Gyoto::WIP self, std::string classname) -> WIP



        Issue a warning specifying the name of the derived class.

        If classname is the empty string (""), the warning is not issued.
        Use this to mark that a class is no more work in progress without
        breaking the ABI (i.e. in the Gyoto stable branch). 
        """
        this = _core.new_WIP(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_WIP
    __del__ = lambda self: None
WIP_swigregister = _core.WIP_swigregister
WIP_swigregister(WIP)

class Value(_object):
    """


    Container for the value of a Property.

    The Value class is very similar to the C union type (although not as
    memory efficient): it can hold several type of values, but only one at
    a time. Care must be taken to ensure only the member that was set is
    retrieved. The purpose of the Value class is to be used together with
    the Property class: code determines dynamicaly the type of a Property,
    reads the corresponding value appropriateley (e.g. from XML or from
    the Yorick prompt), stores the value in a Value instance, and sets the
    Property using the Object::set() method. Likewise, the Object::get()
    method returns a Gyoto::Value. Property::type must be used to
    determine which member of the Value is meaningful.

    Casting between Value and the various data type it can hold is
    normally automatic, but the members can also be accessed explicitly
    make code more easy to read and less ambiguous.

    C++ includes: GyotoValue.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Value, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Value, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _core.delete_Value
    __del__ = lambda self: None

    def assign(self, arg2):
        """assign(Value self, Value arg2) -> Value"""
        return _core.Value_assign(self, arg2)

    __swig_getmethods__["type"] = _core.Value_type_get
    if _newclass:
        type = _swig_property(_core.Value_type_get)

    def toDouble(self):
        """toDouble(Value self) -> double"""
        return _core.Value_toDouble(self)


    def __nonzero__(self):
        return _core.Value___nonzero__(self)
    __bool__ = __nonzero__



    def toLong(self):
        """toLong(Value self) -> long"""
        return _core.Value_toLong(self)


    def toULong(self):
        """toULong(Value self) -> unsigned long"""
        return _core.Value_toULong(self)


    def toString(self):
        """toString(Value self) -> std::string"""
        return _core.Value_toString(self)


    def toVDouble(self):
        """toVDouble(Value self) -> vector_double"""
        return _core.Value_toVDouble(self)


    def toMetric(self):
        """toMetric(Value self) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >"""
        return _core.Value_toMetric(self)


    def toAstrobj(self):
        """toAstrobj(Value self) -> Gyoto::SmartPointer< Gyoto::Astrobj::Generic >"""
        return _core.Value_toAstrobj(self)


    def toSpectrum(self):
        """toSpectrum(Value self) -> Gyoto::SmartPointer< Gyoto::Spectrum::Generic >"""
        return _core.Value_toSpectrum(self)


    def toSpectrometer(self):
        """toSpectrometer(Value self) -> Gyoto::SmartPointer< Gyoto::Spectrometer::Generic >"""
        return _core.Value_toSpectrometer(self)


    def __init__(self, *args):
        """
        __init__(Gyoto::Value self) -> Value
        __init__(Gyoto::Value self, double arg2) -> Value
        __init__(Gyoto::Value self, bool arg2) -> Value
        __init__(Gyoto::Value self, long arg2) -> Value
        __init__(Gyoto::Value self, unsigned long arg2) -> Value
        __init__(Gyoto::Value self, std::string arg2) -> Value
        __init__(Gyoto::Value self, vector_double arg2) -> Value
        __init__(Gyoto::Value self, vector_unsigned_long arg2) -> Value
        __init__(Gyoto::Value self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2) -> Value
        __init__(Gyoto::Value self, Gyoto::SmartPointer< Gyoto::Astrobj::Generic > arg2) -> Value
        __init__(Gyoto::Value self, Gyoto::SmartPointer< Gyoto::Spectrum::Generic > arg2) -> Value
        __init__(Gyoto::Value self, Gyoto::SmartPointer< Gyoto::Spectrometer::Generic > arg2) -> Value
        __init__(Gyoto::Value self, Gyoto::SmartPointer< Gyoto::Screen > arg2) -> Value



        Cast from Screen. 
        """
        this = _core.new_Value(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def toScreen(self):
        """toScreen(Value self) -> Gyoto::SmartPointer< Gyoto::Screen >"""
        return _core.Value_toScreen(self)


    def toSizeT(self):
        """toSizeT(Value self) -> size_t"""
        return _core.Value_toSizeT(self)


    def toVULong(self):
        """toVULong(Value self) -> vector_unsigned_long"""
        return _core.Value_toVULong(self)

Value_swigregister = _core.Value_swigregister
Value_swigregister(Value)

class Object(_object):
    """


    Object with properties.

    The Object API allows declaring a list of Properties that can be set
    and retrieved using a common, text-based interface. This interface
    simplifies a lot how to read and write XML, as well as writing
    bindings for interpreted langages (e.g. the Yorick interface).

    In fact, any class member that has an interface implemented as a
    Property can be readily read and written from/to XML as well as from
    the Yorick plug-in, without the need for any additional code.

    To declare a Property list: declare (in the class declaration, .h
    file) and define (.C file) the pair or quadruplet of accessors for
    your Property (see Property class documentation;

    call the GYOTO_OBJECT macro in in a public section of the class
    declaration (in the .h file):

    call the various GYOTO_PROPERTY_* macros in the corresponding .C file
    (see the documentation of the Property class).

    It is possible to get a Property by name (Assume A is a class deriving
    from Object): It then becomes possible to set or get the Property from
    or to a Value: Of course the type of the Value instance and of the
    Property instance must match. Refer to the documentation of these to
    classes for details.

    C++ includes: GyotoObject.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Object, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Object, name)
    __repr__ = _swig_repr

    def isThreadSafe(self):
        """
        isThreadSafe(Object self) -> bool



        Whether this class is thread-safe.

        Return True if this object is thread-safe, i.e. if an instance and its
        clone can be used in parallel threads (in the context of
        Scenery::raytrace()). Known objects which are not thread-safe include
        Lorene metrics and everything from the Python plug-in.

        The default implementation considers that the class itself is thread
        safe and recurses into the declared properties to check whether they
        are safe too. Classes that abide to the Object/Property paradigm and
        are themselves thread-safe have nothing special to do.

        Objects that clone children in their copy constructor that are not
        declared as properties must take these children into account.

        Classes that are never thread-safe must declare it. It acn be easily
        done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
        GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. 
        """
        return _core.Object_isThreadSafe(self)


    def getProperties(self):
        """
        getProperties(Object self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _core.Object_getProperties(self)


    def plugins(self, *args):
        """
        plugins(Object self, vector_string plugname)
        plugins(Object self) -> vector_string
        """
        return _core.Object_plugins(self, *args)


    def __init__(self, *args):
        """
        __init__(Gyoto::Object self, std::string const & kind) -> Object
        __init__(Gyoto::Object self) -> Object
        __init__(Gyoto::Object self, Object orig) -> Object



        Deep copy constructor. 
        """
        this = _core.new_Object(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_Object
    __del__ = lambda self: None

    def set(self, *args):
        """
        set(Object self, Property p, Value val)
        set(Object self, Property p, Value val, std::string const & unit)
        set(Object self, std::string const & pname, Value val)
        set(Object self, std::string const & pname, Value val, std::string const & unit)



        Set Value (expressed in unit) of a Property. 
        """
        return _core.Object_set(self, *args)


    def get(self, *args):
        """
        get(Object self, Property p) -> Value
        get(Object self, std::string const & pname) -> Value
        get(Object self, Property p, std::string const & unit) -> Value
        get(Object self, std::string const & pname, std::string const & unit) -> Value



        Get Value of a Property, converted to unit. 
        """
        return _core.Object_get(self, *args)


    def property(self, pname):
        """
        property(Object self, std::string const pname) -> Property



        Find property by name.

        Look into the Property list for a Property whose name (or name_false,
        for a boolean Property) is pname. Return a const pointer to the first
        such property found, or NULL if none is found. 
        """
        return _core.Object_property(self, pname)


    def fillProperty(self, fmp, p):
        """
        fillProperty(Object self, FactoryMessenger fmp, Property p)



        Output a single Property to XML.

        The base implementation decides what to do based on the p.type. The
        format matches how setParameters() an setParameter() would interpret
        the XML descition.

        Overriding this method should be avoided, but makes sense in some
        cases (for instance Screen::fillProperty() selects a different unit
        for Distance based on its magnitude, so that stellar sizes are
        expressed in solar radii while smaller sizes can be expressed in
        meters and larger sizes in parsecs).

        Overriding implementation should fall-back on calling the
        implementation in the direct parent class: 
        """
        return _core.Object_fillProperty(self, fmp, p)


    def fillElement(self, fmp):
        """
        fillElement(Object self, FactoryMessenger fmp)



        Fill the XML element for this Object.

        The base implementation simply calls fillProperty() for each Property
        defined for the Object.

        Derived classes should avoid overriding fillElement(). It may make
        sense occasionally, e.g. to make sure that the metric is output first.

        To customize how a given Property is rendered, it is better to
        override fillProperty().

        If this method is overridden, the implementation should in general
        call fillElement() on the direct base. 
        """
        return _core.Object_fillElement(self, fmp)


    def setParameters(self, fmp):
        """
        setParameters(Object self, FactoryMessenger fmp)



        Main loop for parsing Properties from XML description.

        This function queries the FactoryMessenger for elements to parse, and
        tries to matche each element to a Property to set it  accordingly. Any
        class that tries to be buildable from XML must supply a subcontractor
        (for base classes such as Metric, Astrobj, Spectrum  and Spectrometer,
        it is done as a template that must be  specialized for each class).
        This subcontractor typically looks somewhat like this: Although this
        is discouraged, it is possible to override the following functions to
        customize how XML entities are parsed:    - setParameters() if low-
        level access to the      FactoryMessenger is required;    -
        setParameter(std::string name, std::string content,
        std::string unit)      to interpret an entity that does not match a
        Property      (e.g. alternative name);    -
        setParameter(Gyoto::Property const &p, std::string const &name,
        std::string const &content, std::string const &unit)      to change
        how a Property is interpreted. 
        """
        return _core.Object_setParameters(self, fmp)


    def setParameter(self, *args):
        """
        setParameter(Object self, std::string name, std::string content, std::string unit) -> int
        setParameter(Object self, Property p, std::string const & name, std::string const & content, std::string const & unit)



        Set parameter by Property (and name)

        This function is used when parsing an XML description, if Property (
        p) of this name is found (i.e. either p.name or p.name_false is equal
        to name). Implementation should fall-back on calling the direct's
        parent implementation:

        Parameters:
        -----------

        p:   Property that matches name ( p.name == name or p.name_false ==
        name)

        name:  XML name of the parameter (XML entity)

        content:  string representation of the value

        unit:  string representation of the unit 
        """
        return _core.Object_setParameter(self, *args)


    def describeProperty(self, p):
        """
        describeProperty(Object self, Property p) -> std::string



        Format desrciption for a property.

        Returns a string containing the name(s) and type of the property, as
        well as whether it supports unit. 
        """
        return _core.Object_describeProperty(self, p)


    def help(self):
        """
        help(Object self)



        Print (to stdout) some help on this class.

        Describe all properties that this instance supports. 
        """
        return _core.Object_help(self)


    def kind(self):
        """
        kind(Object self) -> std::string



        Get kind_. 
        """
        return _core.Object_kind(self)

Object_swigregister = _core.Object_swigregister
Object_swigregister(Object)
cvar = _core.cvar
Object.properties = _core.cvar.Object_properties
Object.builtinPluginValue = _core.cvar.Object_builtinPluginValue

class Worldline(_object):
    """


    Timelike or null geodesics.

    Their are two derived classes: Photon and Star. A Worldline can be
    integrated from an initial condition either backward or forward in
    time using xFill() ( Photon::hit() also integrates the Worldline).
    Member state_ holds the integration state as well as an integrator.
    There are several kinds of integration states, that derive from
    IntegState::Generic.

    The coordinates of the Worldline are stored in x0_, x1_, x2_, x3_,
    x0dot_, x1dot_, x2dot_ ans x3dot_. Those arrays are extended as needed
    using xExpand(). These coordinates can be retrieved using get_t(),
    get_xyz(), getCartesian(), getCoord() etc.

    Worldline does not derive from Object, and does not instantiate a
    Property list. This is because this would lead to multiple inheritance
    of the Object base in derived classes. Instead, #GyotoWorldline.h
    provides a few macros that can be used to include the Worldline
    properties in a derived classe's Property list:  GYOTO_WORLDLINE is to
    be used in a public section of the derived class declaration (.h
    file); it declares wrappers around the Worldline property accessors;

    GYOTO_WORLDLINE_ACCESSORS is to be used with the class definition (.C
    file; it defines the accessors declared by GYOTO_WORLDLINE;

    GYOTO_WORLDLINE_PROPERTIES declares the Properties that use these
    accessors. It must be used like e.g. GYOTO_PROPERTY_DOUBLE, between
    GYOTO_PROPERTY_START andf GYOTO_PROPERTY_END.

    Finally, GYOTO_WORLDLINE_PROPERTY_END is a drop-in replacement for
    GYOTO_PROPERTY_END that calls GYOTO_WORLDLINE_PROPERTIES and
    GYOTO_WORLDLINE_ACCESSORS.

    C++ includes: GyotoWorldline.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Worldline, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Worldline, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_setmethods__["stopcond"] = _core.Worldline_stopcond_set
    __swig_getmethods__["stopcond"] = _core.Worldline_stopcond_get
    if _newclass:
        stopcond = _swig_property(_core.Worldline_stopcond_get, _core.Worldline_stopcond_set)
    __swig_destroy__ = _core.delete_Worldline
    __del__ = lambda self: None

    def getImin(self):
        """
        getImin(Worldline self) -> size_t



        Get imin_. 
        """
        return _core.Worldline_getImin(self)


    def getImax(self):
        """
        getImax(Worldline self) -> size_t



        Get imax_. 
        """
        return _core.Worldline_getImax(self)


    def getI0(self):
        """
        getI0(Worldline self) -> size_t



        Get i0_. 
        """
        return _core.Worldline_getI0(self)


    def getMass(self):
        """
        getMass(Worldline self) -> double



        Get mass of particule. 
        """
        return _core.Worldline_getMass(self)


    def metric(self, *args):
        """
        metric(Worldline self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)
        metric(Worldline self) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >



        Get metric. 
        """
        return _core.Worldline_metric(self, *args)


    def initCoord(self, *args):
        """
        initCoord(Worldline self, vector_double arg2)
        initCoord(Worldline self) -> vector_double
        """
        return _core.Worldline_initCoord(self, *args)


    def setInitCoord(self, *args):
        """
        setInitCoord(Worldline self, double const [8] coord, int dir, double const [4] Ephi, double const [4] Etheta)
        setInitCoord(Worldline self, double const [8] coord, int dir=0)
        setInitCoord(Worldline self, double const [8] coord)
        setInitCoord(Worldline self, double const [4] pos, double const [3] vel, int dir=0)
        setInitCoord(Worldline self, double const [4] pos, double const [3] vel)



        Set initial coordinate.

        Parameters:
        -----------

        pos:  initial 4-position

        vel:  initial 3-velocity

        dir:  direction of integration 
        """
        return _core.Worldline_setInitCoord(self, *args)


    def setPosition(self, pos):
        """
        setPosition(Worldline self, double const [4] pos)



        Set initial 4-position. 
        """
        return _core.Worldline_setPosition(self, pos)


    def setVelocity(self, vel):
        """
        setVelocity(Worldline self, double const [3] vel)



        Set initial 3-velocity. 
        """
        return _core.Worldline_setVelocity(self, vel)


    def reset(self):
        """
        reset(Worldline self)



        Forget integration, keeping initial contition. 
        """
        return _core.Worldline_reset(self)


    def reInit(self):
        """
        reInit(Worldline self)



        Reset and recompute particle properties. 
        """
        return _core.Worldline_reInit(self)


    def className(self):
        """
        className(Worldline self) -> std::string



        "Worldline" 
        """
        return _core.Worldline_className(self)


    def className_l(self):
        """
        className_l(Worldline self) -> std::string



        "worldline" 
        """
        return _core.Worldline_className_l(self)


    def integrator(self, *args):
        """
        integrator(Worldline self, std::string const & type)
        integrator(Worldline self) -> std::string



        Describe the integrator used by state_. 
        """
        return _core.Worldline_integrator(self, *args)


    def integ31(self, *args):
        """
        integ31(Worldline self, bool integ)
        integ31(Worldline self) -> bool



        Get the kind of geodesic equation integrated by state_. 
        """
        return _core.Worldline_integ31(self, *args)


    def deltaMin(self, *args):
        """
        deltaMin(Worldline self) -> double
        deltaMin(Worldline self, double h1)



        Set delta_min_. 
        """
        return _core.Worldline_deltaMin(self, *args)


    def absTol(self, *args):
        """
        absTol(Worldline self, double arg2)
        absTol(Worldline self) -> double



        Get abstol_. 
        """
        return _core.Worldline_absTol(self, *args)


    def relTol(self, *args):
        """
        relTol(Worldline self, double arg2)
        relTol(Worldline self) -> double



        Get reltol_. 
        """
        return _core.Worldline_relTol(self, *args)


    def maxCrossEqplane(self, *args):
        """
        maxCrossEqplane(Worldline self, double arg2)
        maxCrossEqplane(Worldline self) -> double



        Get maxCrossEqplane_. 
        """
        return _core.Worldline_maxCrossEqplane(self, *args)


    def deltaMax(self, *args):
        """
        deltaMax(Worldline self) -> double
        deltaMax(Worldline self, double const [8] pos, double delta_max_external) -> double
        deltaMax(Worldline self, double h1)



        Set delta_max_ 
        """
        return _core.Worldline_deltaMax(self, *args)


    def deltaMaxOverR(self, *args):
        """
        deltaMaxOverR(Worldline self) -> double
        deltaMaxOverR(Worldline self, double t)



        Set delta_max_over_r_. 
        """
        return _core.Worldline_deltaMaxOverR(self, *args)


    def delta(self, *args):
        """
        delta(Worldline self, double const delta)
        delta(Worldline self, double arg2, std::string const & unit)
        delta(Worldline self) -> double
        delta(Worldline self, std::string const & unit) -> double



        Get delta_ in specified units. 
        """
        return _core.Worldline_delta(self, *args)


    def tMin(self, *args):
        """
        tMin(Worldline self) -> double
        tMin(Worldline self, std::string const & unit) -> double
        tMin(Worldline self, double tlim)
        tMin(Worldline self, double arg2, std::string const & unit)



        Set tmin_ in specified unit. 
        """
        return _core.Worldline_tMin(self, *args)


    def adaptive(self, *args):
        """
        adaptive(Worldline self, bool mode)
        adaptive(Worldline self) -> bool



        Get adaptive_. 
        """
        return _core.Worldline_adaptive(self, *args)


    def secondary(self, *args):
        """
        secondary(Worldline self, bool sec)
        secondary(Worldline self) -> bool



        Get secondary_. 
        """
        return _core.Worldline_secondary(self, *args)


    def parallelTransport(self, *args):
        """
        parallelTransport(Worldline self, bool pt)
        parallelTransport(Worldline self) -> bool



        Get parallel_transport_. 
        """
        return _core.Worldline_parallelTransport(self, *args)


    def maxiter(self, *args):
        """
        maxiter(Worldline self, size_t miter)
        maxiter(Worldline self) -> size_t



        Get maxiter_. 
        """
        return _core.Worldline_maxiter(self, *args)


    def getCst(self):
        """
        getCst(Worldline self) -> double const *



        Returns the worldline's cst of motion (if any)

        Return pointer to array holding the previously set Metric-specific
        constants of motion.

        This function returns a pointer to the actual storage location and
        should be handled with care. std::vector<double> Worldline:
        constantsOfMotion() constprovides a convenient way to retrieve a copy
        of the content. 
        """
        return _core.Worldline_getCst(self)


    def setCst(self, cst):
        """
        setCst(Worldline self, double const * cst)



        Set Metric-specific constants of motion.

        The will (re)allocate Worldline::cst_, copy cst into it, and set
        Worldline::cst_n_.

        This is the same as void Worldline:
        constantsOfMotion(std::vector<double> const cstv) using a C-style
        array instead of a vector. 
        """
        return _core.Worldline_setCst(self, cst)


    def constantsOfMotion(self, *args):
        """
        constantsOfMotion(Worldline self, vector_double cstv)
        constantsOfMotion(Worldline self) -> vector_double



        Return a copy of the Metric-specific constants of motion.

        This funtion return a copy of the constants of motion. getCst() can be
        used to retrieve a pointer to the actual array used internally which
        is slightly more efficient for read-only access. 
        """
        return _core.Worldline_constantsOfMotion(self, *args)


    def setInitialCondition(self, *args):
        """
        setInitialCondition(Worldline self, Gyoto::SmartPointer< Gyoto::Metric::Generic > gg, double const [8] coord, int const dir, double const [4] Ephi, double const [4] Etheta)
        setInitialCondition(Worldline self, Gyoto::SmartPointer< Gyoto::Metric::Generic > gg, double const [8] coord, int const dir)



        Set or re-set the initial condition prior to integration.

        Parameters:
        -----------

        gg:   Gyoto::SmartPointer to the Gyoto::Metric in this universe;

        coord:  8 element array containing the initial condition, i.e. the
        4-position and the 4-velocity of the Photon at the receiving end;

        dir:  direction: 1 for future, -1 for past. 
        """
        return _core.Worldline_setInitialCondition(self, *args)


    def getInitialCoord(self, dest):
        """
        getInitialCoord(Worldline self, vector_double dest)



        Get initial coordinates + base vectors.

        Depending on the size of dest and on the value of parallel_transport_,
        get position (xi_), velocity (xidot_) and possibly other triad vectors
        (epi_ and eti_). 
        """
        return _core.Worldline_getInitialCoord(self, dest)


    def xStore(self, ind, coord, tau):
        """
        xStore(Worldline self, size_t ind, vector_double coord, double tau)



        Obsolete, update your code. 
        """
        return _core.Worldline_xStore(self, ind, coord, tau)


    def xFill(self, tlim, proper=False):
        """
        xFill(Worldline self, double tlim, bool proper=False)
        xFill(Worldline self, double tlim)



        Fill x0, x1... by integrating the Worldline from previously set
        inittial condition to time tlim. 
        """
        return _core.Worldline_xFill(self, tlim, proper)


    def get_nelements(self):
        """
        get_nelements(Worldline self) -> size_t



        Get number of computed dates. 
        """
        return _core.Worldline_get_nelements(self)


    def get_tau(self, dest):
        """
        get_tau(Worldline self, double * dest)



        Get computed proper times or values of the affine parameter. 
        """
        return _core.Worldline_get_tau(self, dest)


    def getCartesian(self, dates, n_dates, x, y, z, xprime=None, yprime=None, zprime=None):
        """
        getCartesian(Worldline self, double const *const dates, size_t const n_dates, double *const x, double *const y, double *const z, double *const xprime=None, double *const yprime=None, double *const zprime=None)
        getCartesian(Worldline self, double const *const dates, size_t const n_dates, double *const x, double *const y, double *const z, double *const xprime=None, double *const yprime=None)
        getCartesian(Worldline self, double const *const dates, size_t const n_dates, double *const x, double *const y, double *const z, double *const xprime=None)
        getCartesian(Worldline self, double const *const dates, size_t const n_dates, double *const x, double *const y, double *const z)



        Get the 6 Cartesian coordinates for specific dates.

        The 6 coordinates (x, y, z, dx/dt, dy/dt, dz/dt) will be computed
        using the integrator and interpolated if necessary, so they will be as
        accurate as possible. Transforming to Cartesian coordinates is not
        necessarily meaningful.

        Parameters:
        -----------

        dates:  List of dates for which the coordinates are to be computed;

        n_dates:  Number of dates to compute ;

        x:  y:  z:  xprime:  yprime:  zprime:  Arrays in which to store the
        result. These pointer may be set to NULL to retrieve only part of the
        information. Else, they must be pre- allocated. 
        """
        return _core.Worldline_getCartesian(self, dates, n_dates, x, y, z, xprime, yprime, zprime)


    def getCoord(self, *args):
        """
        getCoord(Worldline self, size_t index, vector_double dest)
        getCoord(Worldline self, size_t index, vector_double dest)
        getCoord(Worldline self, double date, vector_double dest, bool proper=False)
        getCoord(Worldline self, double date, vector_double dest)
        getCoord(Worldline self, double const *const dates, size_t const n_dates, double *const x1dest, double *const x2dest, double *const x3dest, double *const x0dot=None, double *const x1dot=None, double *const x2dot=None, double *const x3dot=None, double * ep0=None, double * ep1=None, double * ep2=None, double * ep3=None, double * et0=None, double * et1=None, double * et2=None, double * et3=None, double * otime=None, bool proper=False)
        getCoord(Worldline self, double const *const dates, size_t const n_dates, double *const x1dest, double *const x2dest, double *const x3dest, double *const x0dot=None, double *const x1dot=None, double *const x2dot=None, double *const x3dot=None, double * ep0=None, double * ep1=None, double * ep2=None, double * ep3=None, double * et0=None, double * et1=None, double * et2=None, double * et3=None, double * otime=None)
        getCoord(Worldline self, double const *const dates, size_t const n_dates, double *const x1dest, double *const x2dest, double *const x3dest, double *const x0dot=None, double *const x1dot=None, double *const x2dot=None, double *const x3dot=None, double * ep0=None, double * ep1=None, double * ep2=None, double * ep3=None, double * et0=None, double * et1=None, double * et2=None, double * et3=None)
        getCoord(Worldline self, double const *const dates, size_t const n_dates, double *const x1dest, double *const x2dest, double *const x3dest, double *const x0dot=None, double *const x1dot=None, double *const x2dot=None, double *const x3dot=None, double * ep0=None, double * ep1=None, double * ep2=None, double * ep3=None, double * et0=None, double * et1=None, double * et2=None)
        getCoord(Worldline self, double const *const dates, size_t const n_dates, double *const x1dest, double *const x2dest, double *const x3dest, double *const x0dot=None, double *const x1dot=None, double *const x2dot=None, double *const x3dot=None, double * ep0=None, double * ep1=None, double * ep2=None, double * ep3=None, double * et0=None, double * et1=None)
        getCoord(Worldline self, double const *const dates, size_t const n_dates, double *const x1dest, double *const x2dest, double *const x3dest, double *const x0dot=None, double *const x1dot=None, double *const x2dot=None, double *const x3dot=None, double * ep0=None, double * ep1=None, double * ep2=None, double * ep3=None, double * et0=None)
        getCoord(Worldline self, double const *const dates, size_t const n_dates, double *const x1dest, double *const x2dest, double *const x3dest, double *const x0dot=None, double *const x1dot=None, double *const x2dot=None, double *const x3dot=None, double * ep0=None, double * ep1=None, double * ep2=None, double * ep3=None)
        getCoord(Worldline self, double const *const dates, size_t const n_dates, double *const x1dest, double *const x2dest, double *const x3dest, double *const x0dot=None, double *const x1dot=None, double *const x2dot=None, double *const x3dot=None, double * ep0=None, double * ep1=None, double * ep2=None)
        getCoord(Worldline self, double const *const dates, size_t const n_dates, double *const x1dest, double *const x2dest, double *const x3dest, double *const x0dot=None, double *const x1dot=None, double *const x2dot=None, double *const x3dot=None, double * ep0=None, double * ep1=None)
        getCoord(Worldline self, double const *const dates, size_t const n_dates, double *const x1dest, double *const x2dest, double *const x3dest, double *const x0dot=None, double *const x1dot=None, double *const x2dot=None, double *const x3dot=None, double * ep0=None)
        getCoord(Worldline self, double const *const dates, size_t const n_dates, double *const x1dest, double *const x2dest, double *const x3dest, double *const x0dot=None, double *const x1dot=None, double *const x2dot=None, double *const x3dot=None)
        getCoord(Worldline self, double const *const dates, size_t const n_dates, double *const x1dest, double *const x2dest, double *const x3dest, double *const x0dot=None, double *const x1dot=None, double *const x2dot=None)
        getCoord(Worldline self, double const *const dates, size_t const n_dates, double *const x1dest, double *const x2dest, double *const x3dest, double *const x0dot=None, double *const x1dot=None)
        getCoord(Worldline self, double const *const dates, size_t const n_dates, double *const x1dest, double *const x2dest, double *const x3dest, double *const x0dot=None)
        getCoord(Worldline self, double const *const dates, size_t const n_dates, double *const x1dest, double *const x2dest, double *const x3dest)
        getCoord(Worldline self, double * x0, double * x1, double * x2, double * x3)



        Get all computed positions.

        Get all the pre-computed 8 coordinates (e.g. thanks to a prior call to
        xFill()) of this worldline. 
        """
        return _core.Worldline_getCoord(self, *args)


    def checkPhiTheta(self, coord):
        """
        checkPhiTheta(Worldline self, double [8] coord)



        Bring in [0,] and in [0,2].

        checkPhiTheta() Modifies coord if the corrdinates are spherical-like
        so that coord[2]=theta is in [0,pi] and coord[3]=phi is in [0,2pi].
        Important to use in all astrobj in spherical coordinates to prevent
        "z-axis problems". 
        """
        return _core.Worldline_checkPhiTheta(self, coord)


    def save_txyz(self, *args):
        """
        save_txyz(Worldline self, char * fichierxyz)
        save_txyz(Worldline self, char *const filename, double const t1, double const mass_sun, double const distance_kpc, std::string const unit, Gyoto::SmartPointer< Gyoto::Screen > sc=0)
        save_txyz(Worldline self, char *const filename, double const t1, double const mass_sun, double const distance_kpc, std::string const unit)



        Save, converted. 
        """
        return _core.Worldline_save_txyz(self, *args)


    def get_t(self, *args):
        """
        get_t(Worldline self, double * dest)
        get_t(Worldline self, double * INPLACE_ARRAY1)



        Get computed dates. 
        """
        return _core.Worldline_get_t(self, *args)


    def get_xyz(self, *args):
        """
        get_xyz(Worldline self, double * x, double * y, double * z)
        get_xyz(Worldline self, double * x1dest, double * x2dest, double * x3dest)



        Get 3-position in cartesian coordinates for computed dates. 
        """
        return _core.Worldline_get_xyz(self, *args)


    def getSkyPos(self, *args):
        """
        getSkyPos(Worldline self, Gyoto::SmartPointer< Gyoto::Screen > screen, double * dalpha, double * ddellta, double * dD)
        getSkyPos(Worldline self, Gyoto::SmartPointer< Gyoto::Screen > screen, double * x1dest, double * x2dest, double * x3dest)



        Get computed positions in sky coordinates. 
        """
        return _core.Worldline_getSkyPos(self, *args)


    def get_dot(self, *args):
        """
        get_dot(Worldline self, double * x0dot, double * x1dot, double * x2dot, double * x3dot)
        get_dot(Worldline self, double * x0dot, double * x1dot, double * x2dot, double * x3dot)



        Get computed 4-velocities. 
        """
        return _core.Worldline_get_dot(self, *args)


    def get_prime(self, *args):
        """
        get_prime(Worldline self, double * x1prime, double * x2prime, double * x3prime)
        get_prime(Worldline self, double * x1dot, double * x2dot, double * x3dot)



        Get computed 3-velocities. 
        """
        return _core.Worldline_get_prime(self, *args)


    def getCartesianPos(self, *args):
        """
        getCartesianPos(Worldline self, size_t index, double [4] dest)
        getCartesianPos(Worldline self, size_t index)



        Get Cartesian expression of 4-position at index. 
        """
        return _core.Worldline_getCartesianPos(self, *args)

Worldline_swigregister = _core.Worldline_swigregister
Worldline_swigregister(Worldline)

class Screen(SmartPointee, Object):
    """


    The camera with which the Astrobj is observed.

    In the observer-centric point-of-view, the center of the Metric's
    coordinate system is positioned relatively to the observing Screen
    using three Euler angles and the distance (in meters). The three Euler
    angles are: position angle of the line of nodes (North of East);

    inclination (0 = face-on);

    argument of the X axis of the Metric's coordinate system. We use the
    z-x-z convention. Seehttp://en.wikipedia.org/wiki/Euler_angles

    In addition, the Screen conveys: the observing date (in geometrical
    units, but expect it to change to seconds in a future version);

    the field-of-view of the image;

    the resolution of the camera: number of pixels on each side (the
    camera is square);

    the observing frequency.

    The scalar FreqObs defines the observing frequency for Scenery
    quantity Intensity.

    Likewise, a Gyoto::Spectrometer defines for which frequencies spectra
    are computed (when the Quantity Spectrum is requested in the Scenery).

    For the sake of theoreticians, there is an alternate way of specifying
    the relative position of the Screen and Metric, by specifying the
    4-coordinates of the Screen in the Metric's coordinate system (in that
    case, eerything is specified in geometrical units).

    So an XML stanza for a Screen may look like that:

    or like that:

    Units can be specified using the unit attribute in the XML file, for
    instance:

    Possible units are (with [] noting the default): distance: [m],
    geometrical, cm, km, AU, ly, pc, kpc, Mpc;

    PALN, inclination, argument: [rad], deg.

    frequency: [Hz], m, GeV...

    When the distance is really large and most of the ray-tracing would
    happen de facto in flat space, the camera is transported to a location
    at a reasonable distance from the metric and the images are scaled
    accordingly. The default value for this distance should be fine, but
    it can be customized using the "dmax" attribute of the "Distance"
    element. "dmax" is always expressed in geometrical units:

    Symptoms when dmax is too large include pixelization of the image
    (neighbouring photons are numerically identical) and other numerical
    overflows. dmax is too small when it is apparent that changing it
    yields projection effects. dmax must be large compared to rmax in the
    Astrobj and ideally, changing it by an order of magnitude should not
    yield significant changes in the ray-traced image.

    A mask may be used to limit ray-tracing to only some portions of the
    field. The Scenery checks whether a mask is to be used using
    Screen::operator()(size_t i, size_t j). The mask can be loaded from a
    FITS file as a square image of doubles: The mask needs to be have the
    same size as the Screen itself, so loading a mask also sets the
    resolution, and changing the resolution after setting a mask also
    removes the mask. The content of the Mask entity is parsed by
    Factory::fullPath(), so it can be an absolute path, a path relative to
    where the XML file is stored, or relative to the current working
    directory if prefixed with "`pwd`/".

    C++ includes: GyotoScreen.h 
    """

    __swig_setmethods__ = {}
    for _s in [SmartPointee, Object]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Screen, name, value)
    __swig_getmethods__ = {}
    for _s in [SmartPointee, Object]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Screen, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(Screen self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _core.Screen_getProperties(self)


    def plugins(self, *args):
        """
        plugins(Screen self, vector_string plugname)
        plugins(Screen self) -> vector_string
        """
        return _core.Screen_plugins(self, *args)


    def isThreadSafe(self):
        """
        isThreadSafe(Screen self) -> bool



        Whether this class is thread-safe.

        Return True if this object is thread-safe, i.e. if an instance and its
        clone can be used in parallel threads (in the context of
        Scenery::raytrace()). Known objects which are not thread-safe include
        Lorene metrics and everything from the Python plug-in.

        The default implementation considers that the class itself is thread
        safe and recurses into the declared properties to check whether they
        are safe too. Classes that abide to the Object/Property paradigm and
        are themselves thread-safe have nothing special to do.

        Objects that clone children in their copy constructor that are not
        declared as properties must take these children into account.

        Classes that are never thread-safe must declare it. It acn be easily
        done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
        GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. 
        """
        return _core.Screen_isThreadSafe(self)


    def __init__(self, *args):
        """
        __init__(Gyoto::Screen self) -> Screen
        __init__(Gyoto::Screen self, Screen arg2) -> Screen



        Copy constructor. 
        """
        this = _core.new_Screen(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def clone(self):
        """
        clone(Screen self) -> Screen



        Cloner. 
        """
        return _core.Screen_clone(self)

    __swig_destroy__ = _core.delete_Screen
    __del__ = lambda self: None

    def setProjection(self, *args):
        """
        setProjection(Screen self, double const paln, double const inclination, double const argument)
        setProjection(Screen self, double const distance, double const paln, double const inclination, double const argument)



        Set distance, inclination etc. 
        """
        return _core.Screen_setProjection(self, *args)


    def spectrometer(self, *args):
        """
        spectrometer(Screen self, Gyoto::SmartPointer< Gyoto::Spectrometer::Generic > spectro)
        spectrometer(Screen self) -> Gyoto::SmartPointer< Gyoto::Spectrometer::Generic >



        Get Screen::spectro_. 
        """
        return _core.Screen_spectrometer(self, *args)


    def freqObs(self, *args):
        """
        freqObs(Screen self, double fo)
        freqObs(Screen self, double fo, std::string const & unit)
        freqObs(Screen self) -> double
        freqObs(Screen self, std::string const & unit) -> double



        Get freq_obs_.

        Parameters:
        -----------

        unit:  string: unit in which freq_obs_ should be returned is
        expressed, convertible to Herz or meters or energy. 
        """
        return _core.Screen_freqObs(self, *args)


    def setObserverPos(self, pos):
        """
        setObserverPos(Screen self, double const [4] pos)



        Alternative way to set projection.

        Beware : paln can not be set this way, setting later other parameters
        change the observer's coordinates. For observationnal ray-tracing
        purposes, prefer setProjection().

        Parameters:
        -----------

        pos:  position of observer in Screen's coordinate system. Content is
        copied. 
        """
        return _core.Screen_setObserverPos(self, pos)


    def observerKind(self, *args):
        """
        observerKind(Screen self, std::string const & kind)
        observerKind(Screen self) -> std::string
        """
        return _core.Screen_observerKind(self, *args)


    def setFourVel(self, coord):
        """
        setFourVel(Screen self, double const [4] coord)



        Sets the observer's 4-velocity. 
        """
        return _core.Screen_setFourVel(self, coord)


    def setScreen1(self, coord):
        """
        setScreen1(Screen self, double const [4] coord)



        Sets the screen vector e1. 
        """
        return _core.Screen_setScreen1(self, coord)


    def setScreen2(self, coord):
        """
        setScreen2(Screen self, double const [4] coord)



        Sets the screen vector e2. 
        """
        return _core.Screen_setScreen2(self, coord)


    def setScreen3(self, coord):
        """
        setScreen3(Screen self, double const [4] coord)



        Sets the screen vector e3 (normal) 
        """
        return _core.Screen_setScreen3(self, coord)


    def coordKind(self):
        """
        coordKind(Screen self) -> int



        Get coordinate kind.

        From Screen::gg_. 
        """
        return _core.Screen_coordKind(self)


    def distance(self, *args):
        """
        distance(Screen self, double dist)
        distance(Screen self, double dist, std::string const & unit)
        distance(Screen self) -> double
        distance(Screen self, std::string const & arg2) -> double



        Get distance from observer.

        In specified unit. Get distance from observer 
        """
        return _core.Screen_distance(self, *args)


    def dMax(self, *args):
        """
        dMax(Screen self, double dist)
        dMax(Screen self) -> double



        Get maximum ray-tracing distance.

        In geometrical units. 
        """
        return _core.Screen_dMax(self, *args)


    def inclination(self, *args):
        """
        inclination(Screen self, double arg2)
        inclination(Screen self, double arg2, std::string const & unit)
        inclination(Screen self) -> double
        inclination(Screen self, std::string const & arg2) -> double



        Get inclination relative to line-of-sight.

        Inclination of z-axis relative to line-of-sight, or inclination of
        equatorial plane relative to plane of the sky, in specified unit. 
        """
        return _core.Screen_inclination(self, *args)


    def PALN(self, *args):
        """
        PALN(Screen self, double arg2)
        PALN(Screen self, double arg2, std::string const & unit)
        PALN(Screen self) -> double
        PALN(Screen self, std::string const & arg2) -> double



        Get position angle of the line of nodes. 
        """
        return _core.Screen_PALN(self, *args)


    def argument(self, *args):
        """
        argument(Screen self, double arg2)
        argument(Screen self, double arg2, std::string const & unit)
        argument(Screen self) -> double
        argument(Screen self, std::string const & arg2) -> double



        Get angle between line of nodes and X axis of object. 
        """
        return _core.Screen_argument(self, *args)


    def metric(self, *args):
        """
        metric(Screen self) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >
        metric(Screen self, Gyoto::SmartPointer< Gyoto::Metric::Generic > gg)



        Set Screen::gg_. 
        """
        return _core.Screen_metric(self, *args)


    def time(self, *args):
        """
        time(Screen self) -> double
        time(Screen self, std::string const & arg2) -> double
        time(Screen self, double arg2, std::string const & arg3)
        time(Screen self, double arg2)



        Set observing date in seconds. 
        """
        return _core.Screen_time(self, *args)


    def fieldOfView(self, *args):
        """
        fieldOfView(Screen self) -> double
        fieldOfView(Screen self, std::string const & unit) -> double
        fieldOfView(Screen self, double arg2)
        fieldOfView(Screen self, double arg2, std::string const & unit)



        Set Screen::fov_ in specified unit. 
        """
        return _core.Screen_fieldOfView(self, *args)


    def azimuthalFieldOfView(self, *args):
        """
        azimuthalFieldOfView(Screen self) -> double
        azimuthalFieldOfView(Screen self, double ff)



        Set Screen::azimuthal_fov_. 
        """
        return _core.Screen_azimuthalFieldOfView(self, *args)


    def dangle1(self, *args):
        """
        dangle1(Screen self, double arg2)
        dangle1(Screen self, double arg2, std::string const & unit)
        dangle1(Screen self) -> double
        dangle1(Screen self, std::string const & unit) -> double



        Get increment to first position angle in specified unit. 
        """
        return _core.Screen_dangle1(self, *args)


    def dangle2(self, *args):
        """
        dangle2(Screen self, double arg2)
        dangle2(Screen self, double arg2, std::string const & unit)
        dangle2(Screen self) -> double
        dangle2(Screen self, std::string const & unit) -> double



        Get increment to second position angle in specified unit. 
        """
        return _core.Screen_dangle2(self, *args)


    def anglekind(self, *args):
        """
        anglekind(Screen self, int arg2)
        anglekind(Screen self, std::string const & arg2)
        anglekind(Screen self) -> std::string
        """
        return _core.Screen_anglekind(self, *args)


    def resolution(self, *args):
        """
        resolution(Screen self) -> size_t
        resolution(Screen self, size_t arg2)



        Set Screen::npix_. 
        """
        return _core.Screen_resolution(self, *args)


    def mask(self, *args):
        """
        mask(Screen self, double const *const mm, size_t resolution=0)
        mask(Screen self, double const *const mm)
        mask(Screen self) -> double const *



        Retrieve const pointer to mask_. 
        """
        return _core.Screen_mask(self, *args)


    def maskFile(self, *args):
        """
        maskFile(Screen self, std::string const & fname)
        maskFile(Screen self) -> std::string
        """
        return _core.Screen_maskFile(self, *args)


    def fitsReadMask(self, fname):
        """fitsReadMask(Screen self, std::string const & fname)"""
        return _core.Screen_fitsReadMask(self, fname)


    def fitsWriteMask(self, fname):
        """fitsWriteMask(Screen self, std::string const & fname)"""
        return _core.Screen_fitsWriteMask(self, fname)


    def __call__(self, arg2, arg3):
        """__call__(Screen self, size_t arg2, size_t arg3) -> bool"""
        return _core.Screen___call__(self, arg2, arg3)


    def fourVel(self, *args):
        """
        fourVel(Screen self, vector_double arg2)
        fourVel(Screen self) -> vector_double
        """
        return _core.Screen_fourVel(self, *args)


    def screenVector1(self, *args):
        """
        screenVector1(Screen self, vector_double arg2)
        screenVector1(Screen self) -> vector_double
        """
        return _core.Screen_screenVector1(self, *args)


    def screenVector2(self, *args):
        """
        screenVector2(Screen self, vector_double arg2)
        screenVector2(Screen self) -> vector_double
        """
        return _core.Screen_screenVector2(self, *args)


    def screenVector3(self, *args):
        """
        screenVector3(Screen self, vector_double arg2)
        screenVector3(Screen self) -> vector_double
        """
        return _core.Screen_screenVector3(self, *args)


    def getScreen1(self, dest):
        """
        getScreen1(Screen self, double [4] dest)



        Get copy of Screen::screen1_.

        Parameters:
        -----------

        dest:  preallocated 4-element array 
        """
        return _core.Screen_getScreen1(self, dest)


    def getScreen2(self, dest):
        """
        getScreen2(Screen self, double [4] dest)



        Get copy of Screen::screen2_.

        Parameters:
        -----------

        dest:  preallocated 4-element array 
        """
        return _core.Screen_getScreen2(self, dest)


    def getScreen3(self, dest):
        """
        getScreen3(Screen self, double [4] dest)



        Get copy of Screen::screen3_.

        Parameters:
        -----------

        dest:  preallocated 4-element array 
        """
        return _core.Screen_getScreen3(self, dest)


    def getRayTriad(self, *args):
        """
        getRayTriad(Screen self, double x, double y, double [8] dest, bool compute_polar_basis=False, double [4] Ephi=0, double [4] Etheta=0)
        getRayTriad(Screen self, double x, double y, double [8] dest, bool compute_polar_basis=False, double [4] Ephi=0)
        getRayTriad(Screen self, double x, double y, double [8] dest, bool compute_polar_basis=False)
        getRayTriad(Screen self, double x, double y, double [8] dest)
        getRayTriad(Screen self, size_t const i, size_t const j, double [8] dest, bool compute_polar_basis=False, double [4] Ephi=0, double [4] Etheta=0)
        getRayTriad(Screen self, size_t const i, size_t const j, double [8] dest, bool compute_polar_basis=False, double [4] Ephi=0)
        getRayTriad(Screen self, size_t const i, size_t const j, double [8] dest, bool compute_polar_basis=False)
        getRayTriad(Screen self, size_t const i, size_t const j, double [8] dest)



        Get 8-coordinate of Photon hitting screen pixel and polarization basis
        if needed.

        Similar to Screen::getObserverPos() but will return in addition the
        4-velocity of a photon corresponding to the sky direction given by x
        and y.

        Parameters:
        -----------

        i:  j:  pixel coordinates

        dest:  position-velocity of the Photon. Preallocated.

        compute_polar_basis:  True if polarization basis Ephi,Etheta is needed

        Ephi:  first polarisation direction. Preallocated. Default: NULL.

        Etheta:  second polarisation direction. Preallocated. Default: NULL.

        """
        return _core.Screen_getRayTriad(self, *args)


    def coordToSky(self, pos, dest, geometrical=False):
        """
        coordToSky(Screen self, double const [4] pos, double [3] dest, bool geometrical=False)
        coordToSky(Screen self, double const [4] pos, double [3] dest)



        Convert metric 4-position to sky 3-position.

        Parameters:
        -----------

        pos:  4-position in metric coordinates.

        dest:  3-position in plane of the sky: Cartesian East, North, front.

        geometrical:  if true, #dest will be in geometrical units instead of
        meters. 
        """
        return _core.Screen_coordToSky(self, pos, dest, geometrical)


    def skyToCoord(self, sky, dest, geometrical=False):
        """
        skyToCoord(Screen self, double const [3] sky, double [4] dest, bool geometrical=False)
        skyToCoord(Screen self, double const [3] sky, double [4] dest)



        Convert sky 3-position to metric 4-position.

        Parameters:
        -----------

        sky:  3-position in plane of the sky.

        dest:  4-position in metric coordinates (dest[0] is not modified).

        geometrical:  set to true if #sky is in geometrical units instead of
        meters. 
        """
        return _core.Screen_skyToCoord(self, sky, dest, geometrical)


    def coordToXYZ(self, pos, dest):
        """
        coordToXYZ(Screen self, double const [4] pos, double [3] dest)



        Convert 4-position to 3-cartesian coordinates. 
        """
        return _core.Screen_coordToXYZ(self, pos, dest)


    def computeBaseVectors(self):
        """
        computeBaseVectors(Screen self)



        Compute base vectors according to projection parameters. 
        """
        return _core.Screen_computeBaseVectors(self)


    def _print(self, arg2):
        """
        _print(Screen self, std::ostream & arg2) -> std::ostream &



        Display.

        Debug helper 
        """
        return _core.Screen__print(self, arg2)


    def printBaseVectors(self, arg2):
        """
        printBaseVectors(Screen self, std::ostream & arg2) -> std::ostream &



        Debug helper. 
        """
        return _core.Screen_printBaseVectors(self, arg2)


    def mapPixUnit(self):
        """mapPixUnit(Screen self)"""
        return _core.Screen_mapPixUnit(self)


    def unmapPixUnit(self):
        """unmapPixUnit(Screen self)"""
        return _core.Screen_unmapPixUnit(self)


    def fillProperty(self, fmp, p):
        """
        fillProperty(Screen self, FactoryMessenger fmp, Property p)



        Output a single Property to XML.

        The base implementation decides what to do based on the p.type. The
        format matches how setParameters() an setParameter() would interpret
        the XML descition.

        Overriding this method should be avoided, but makes sense in some
        cases (for instance Screen::fillProperty() selects a different unit
        for Distance based on its magnitude, so that stellar sizes are
        expressed in solar radii while smaller sizes can be expressed in
        meters and larger sizes in parsecs).

        Overriding implementation should fall-back on calling the
        implementation in the direct parent class: 
        """
        return _core.Screen_fillProperty(self, fmp, p)


    def Subcontractor(fmp):
        """Subcontractor(FactoryMessenger fmp) -> Gyoto::SmartPointer< Gyoto::Screen >"""
        return _core.Screen_Subcontractor(fmp)

    Subcontractor = staticmethod(Subcontractor)
    angle = _core.Screen_angle
    pixel = _core.Screen_pixel

    def getObserverPos(self, *args):
        """
        getObserverPos(Screen self, double [4] dest)
        getObserverPos(Screen self)



        4-Position of the observer relative to the metric

        A Screen is positioned relative to the observer with four elements:
        Screen::distance, Screen::inclination, Screen::paln and
        Screen::argument.

        This function returns the position of the observer relative to the
        metric system in Screen::gg_, using these parameters. The output
        parameter is coord.

        Parameters:
        -----------

        coord:  position of the observer. Must be preallocated. 
        """
        return _core.Screen_getObserverPos(self, *args)


    def getFourVel(self, *args):
        """
        getFourVel(Screen self, double [4] dest)
        getFourVel(Screen self)



        Get copy of Screen::fourvel_.

        Parameters:
        -----------

        fourvel:  preallocated 4-element array 
        """
        return _core.Screen_getFourVel(self, *args)


    def __str__(self):
        """__str__(Screen self) -> std::string"""
        return _core.Screen___str__(self)

Screen_swigregister = _core.Screen_swigregister
Screen_swigregister(Screen)
Screen.properties = _core.cvar.Screen_properties
Screen.builtinPluginValue = _core.cvar.Screen_builtinPluginValue

def Screen_Subcontractor(fmp):
    """Screen_Subcontractor(FactoryMessenger fmp) -> Gyoto::SmartPointer< Gyoto::Screen >"""
    return _core.Screen_Subcontractor(fmp)

class Scenery(SmartPointee, Object):
    """


    Ray-tracing scene.

    An Scenery contains: a Metric: used in Astrobj, Screen and Photon;

    a Screen: sets the field-of-view, the position of the camera, the
    observation time, and the Spectrometer;

    an Astrobj: light emitter.

    In addition, Quantities may be specified (or the default Quantity will
    be produced: generally Intensity). Not all Astrobj implement all
    Quantities. The order in which Quantities are listed is not relevant
    (it is not stored). Possible Quantities:

    Intensity: the intensity that reaches the object, integrated over the
    line-of-sight;

    EmissionTime: date of emission;

    MinDistance: minimum distance between the Photon reaching each pixel
    and the Astrobj;

    FirstDistMin: last closest approach between Photon and Astrobj;

    Redshift;

    ImpactCoords: 8-coordinates of the object and photon at impact;

    Spectrum: I computed at various values frequencies, corresponding to
    the Screen's Spectrometer.

    BinSpectrum:12Id computed between various (1,2 pairs corresponding to
    the Screen's Spectrometer. This is what a physical spectrometer
    measures.

    In addition, it is possible to ray-trace an image using several cores
    on a single machine (if Gyoto has been compiled with POSIX threads
    support). The number of threads can be specified using NThreads
    entity. Setting NThreads to 0 is equivalent to setting it to 1. Beware
    that setting NThreads to a number higher than the actual number of
    cores available on the machine usually leads to a decrease in
    performance.

    Finally, Scenery accepts a number of numerical tuning parameters that
    are passed directly to the underlying photons (actually, the Scenery
    object holds a Photon instance which stores many parameters, including
    the Metric and Astrobj): Adaptive/NonAdaptive, Delta, MinimumTime,
    MaxIter, PrimaryOnly.

    Thus a fully populated Scenery XML looks like that (the values are
    examples, they are not necessary the default nor the best or even good
    values):

    C++ includes: GyotoScenery.h 
    """

    __swig_setmethods__ = {}
    for _s in [SmartPointee, Object]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Scenery, name, value)
    __swig_getmethods__ = {}
    for _s in [SmartPointee, Object]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Scenery, name)
    __repr__ = _swig_repr

    def isThreadSafe(self):
        """
        isThreadSafe(Scenery self) -> bool



        Whether this class is thread-safe.

        Return True if this object is thread-safe, i.e. if an instance and its
        clone can be used in parallel threads (in the context of
        Scenery::raytrace()). Known objects which are not thread-safe include
        Lorene metrics and everything from the Python plug-in.

        The default implementation considers that the class itself is thread
        safe and recurses into the declared properties to check whether they
        are safe too. Classes that abide to the Object/Property paradigm and
        are themselves thread-safe have nothing special to do.

        Objects that clone children in their copy constructor that are not
        declared as properties must take these children into account.

        Classes that are never thread-safe must declare it. It acn be easily
        done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
        GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. 
        """
        return _core.Scenery_isThreadSafe(self)

    __swig_setmethods__["mpi_team_"] = _core.Scenery_mpi_team__set
    __swig_getmethods__["mpi_team_"] = _core.Scenery_mpi_team__get
    if _newclass:
        mpi_team_ = _swig_property(_core.Scenery_mpi_team__get, _core.Scenery_mpi_team__set)
    __swig_setmethods__["am_worker"] = _core.Scenery_am_worker_set
    __swig_getmethods__["am_worker"] = _core.Scenery_am_worker_get
    if _newclass:
        am_worker = _swig_property(_core.Scenery_am_worker_get, _core.Scenery_am_worker_set)

    def mpiSpawn(self, nbchildren):
        """
        mpiSpawn(Scenery self, int nbchildren)



        Spawn gyoto-mpi-worker processes.

        If nbchildren is -1 set #mpi_team_ to MPI_COMM_WORLD else spawn
        nbchildren processes and set nprocesses_ accordingly. If a different
        number of workers are already running, terminate them first. If
        nbchildren is 0, just terminate running workers.

        The approach of Gyoto to MPI is that a manager process (of rank 0
        within a given MPI communicator) will distribute ray-tracing tasks
        across worker processes. Several scenarii are supported, including
        spawning instances of the gyoto-mpi-worker.version executable, where
        "version" matches the version component in the library name
        (typically a number, possibly followed by "unreleased").

        In all cases, the manager process needs to call this function, either
        with -1 if the worker processes are already running or >1 if workers
        need to be spawned.

        Parameters:
        -----------

        nbchildren:  number of processes to spawn. 
        """
        return _core.Scenery_mpiSpawn(self, nbchildren)


    def mpiTerminate(self):
        """
        mpiTerminate(Scenery self)



        Terminate worker processes. 
        """
        return _core.Scenery_mpiTerminate(self)


    def mpiClone(self):
        """
        mpiClone(Scenery self)



        Send a copy of self to the mpi workers.

        Always call mpiClone() before ray-tracing if workers are running. 
        """
        return _core.Scenery_mpiClone(self)

    give_task = _core.Scenery_give_task
    read_scenery = _core.Scenery_read_scenery
    terminate = _core.Scenery_terminate
    raytrace = _core.Scenery_raytrace
    raytrace_done = _core.Scenery_raytrace_done
    ready = _core.Scenery_ready
    impactcoords = _core.Scenery_impactcoords
    noimpactcoords = _core.Scenery_noimpactcoords

    def mpiTask(self, tag):
        """
        mpiTask(Scenery self, Gyoto::Scenery::mpi_tag & tag)



        Send a tag to workers. 
        """
        return _core.Scenery_mpiTask(self, tag)


    def mpiWorker():
        """mpiWorker()"""
        return _core.Scenery_mpiWorker()

    mpiWorker = staticmethod(mpiWorker)

    def getProperties(self):
        """
        getProperties(Scenery self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _core.Scenery_getProperties(self)


    def plugins(self, *args):
        """
        plugins(Scenery self, vector_string plugname)
        plugins(Scenery self) -> vector_string
        """
        return _core.Scenery_plugins(self, *args)


    def _delta(self, *args):
        """
        _delta(Scenery self, double const delta)
        _delta(Scenery self, double arg2, std::string const & unit)
        _delta(Scenery self) -> double
        _delta(Scenery self, std::string const & unit) -> double
        """
        return _core.Scenery__delta(self, *args)


    def _tMin(self, *args):
        """
        _tMin(Scenery self, double const tmin)
        _tMin(Scenery self, double arg2, std::string const & unit)
        _tMin(Scenery self) -> double
        _tMin(Scenery self, std::string const & unit) -> double
        """
        return _core.Scenery__tMin(self, *args)


    def _adaptive(self, *args):
        """
        _adaptive(Scenery self, bool mode)
        _adaptive(Scenery self) -> bool
        """
        return _core.Scenery__adaptive(self, *args)


    def _secondary(self, *args):
        """
        _secondary(Scenery self, bool sec)
        _secondary(Scenery self) -> bool
        """
        return _core.Scenery__secondary(self, *args)


    def _integ31(self, *args):
        """
        _integ31(Scenery self, bool sec)
        _integ31(Scenery self) -> bool
        """
        return _core.Scenery__integ31(self, *args)


    def _parallelTransport(self, *args):
        """
        _parallelTransport(Scenery self, bool sec)
        _parallelTransport(Scenery self) -> bool
        """
        return _core.Scenery__parallelTransport(self, *args)


    def _maxiter(self, *args):
        """
        _maxiter(Scenery self, size_t miter)
        _maxiter(Scenery self) -> size_t
        """
        return _core.Scenery__maxiter(self, *args)


    def _integrator(self, *args):
        """
        _integrator(Scenery self, std::string const & type)
        _integrator(Scenery self) -> std::string
        """
        return _core.Scenery__integrator(self, *args)


    def _deltaMin(self, *args):
        """
        _deltaMin(Scenery self) -> double
        _deltaMin(Scenery self, double h1)
        """
        return _core.Scenery__deltaMin(self, *args)


    def _absTol(self, *args):
        """
        _absTol(Scenery self, double arg2)
        _absTol(Scenery self) -> double
        """
        return _core.Scenery__absTol(self, *args)


    def _maxCrossEqplane(self, *args):
        """
        _maxCrossEqplane(Scenery self, double arg2)
        _maxCrossEqplane(Scenery self) -> double
        """
        return _core.Scenery__maxCrossEqplane(self, *args)


    def _relTol(self, *args):
        """
        _relTol(Scenery self, double arg2)
        _relTol(Scenery self) -> double
        """
        return _core.Scenery__relTol(self, *args)


    def _deltaMax(self, *args):
        """
        _deltaMax(Scenery self, double h1)
        _deltaMax(Scenery self) -> double
        """
        return _core.Scenery__deltaMax(self, *args)


    def _deltaMaxOverR(self, *args):
        """
        _deltaMaxOverR(Scenery self) -> double
        _deltaMaxOverR(Scenery self, double t)
        """
        return _core.Scenery__deltaMaxOverR(self, *args)


    def _initCoord(self, *args):
        """
        _initCoord(Scenery self) -> vector_double
        _initCoord(Scenery self, vector_double f)
        """
        return _core.Scenery__initCoord(self, *args)


    def _metric(self, *args):
        """
        _metric(Scenery self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)
        _metric(Scenery self) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >
        """
        return _core.Scenery__metric(self, *args)


    def clone(self):
        """
        clone(Scenery self) -> Scenery



        Cloner. 
        """
        return _core.Scenery_clone(self)


    def __init__(self, *args):
        """
        __init__(Gyoto::Scenery self) -> Scenery
        __init__(Gyoto::Scenery self, Scenery o) -> Scenery
        __init__(Gyoto::Scenery self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2, Gyoto::SmartPointer< Gyoto::Screen > arg3, Gyoto::SmartPointer< Gyoto::Astrobj::Generic > arg4) -> Scenery



        Constructor setting Scenery::gg_, Scenery::screen_, and Scenery::obj_.

        To ensure consistency, the Metric will be forcibly attached to the
        Screen and to the Astrobj (if they are not NULL). 
        """
        this = _core.new_Scenery(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_Scenery
    __del__ = lambda self: None

    def metric(self, *args):
        """
        metric(Scenery self) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >
        metric(Scenery self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)



        Set Scenery::gg_.

        The provided Metric will also be atached to the Screen and the
        Astrobj. 
        """
        return _core.Scenery_metric(self, *args)


    def screen(self, *args):
        """
        screen(Scenery self) -> Gyoto::SmartPointer< Gyoto::Screen >
        screen(Scenery self, Gyoto::SmartPointer< Gyoto::Screen > arg2)



        Set Scenery::screen_.

        The Metric attached to the Scenery will be attached to the Screen 
        """
        return _core.Scenery_screen(self, *args)


    def astrobj(self, *args):
        """
        astrobj(Scenery self) -> Gyoto::SmartPointer< Gyoto::Astrobj::Generic >
        astrobj(Scenery self, Gyoto::SmartPointer< Gyoto::Astrobj::Generic > arg2)



        Set ph_.obj_.

        The Metric attached to the Scenery will be attached to the Astrobj 
        """
        return _core.Scenery_astrobj(self, *args)


    def clonePhoton(self, *args):
        """
        clonePhoton(Scenery self) -> Gyoto::SmartPointer< Photon >
        clonePhoton(Scenery self, size_t i, size_t j) -> Gyoto::SmartPointer< Photon >
        clonePhoton(Scenery self, double a, double d) -> Gyoto::SmartPointer< Photon >



        Get clone of template Photon, intitializing it to direction. 
        """
        return _core.Scenery_clonePhoton(self, *args)


    def updatePhoton(self):
        """
        updatePhoton(Scenery self)



        Update values in cached Photon. 
        """
        return _core.Scenery_updatePhoton(self)


    def delta(self, *args):
        """
        delta(Scenery self) -> double
        delta(Scenery self, std::string const & unit) -> double
        delta(Scenery self, double arg2)
        delta(Scenery self, double arg2, std::string const & unit)



        set default step in specified units 
        """
        return _core.Scenery_delta(self, *args)


    def initCoord(self, *args):
        """
        initCoord(Scenery self, vector_double c)
        initCoord(Scenery self) -> vector_double
        """
        return _core.Scenery_initCoord(self, *args)


    def setRequestedQuantities(self, quant):
        """
        setRequestedQuantities(Scenery self, Gyoto::Quantity_t quant)



        Set Scenery::quantities_.

        Parameters:
        -----------

        quant:  Bitwise OR of desired quantities, e.g. 
        """
        return _core.Scenery_setRequestedQuantities(self, quant)


    def getRequestedQuantities(self):
        """
        getRequestedQuantities(Scenery self) -> Gyoto::Quantity_t



        Get Scenery::quantities_. 
        """
        return _core.Scenery_getRequestedQuantities(self)


    def requestedQuantitiesString(self, *args):
        """
        requestedQuantitiesString(Scenery self, std::string const & squant)
        requestedQuantitiesString(Scenery self) -> std::string



        Get a string representation of Scenery::quantities_. 
        """
        return _core.Scenery_requestedQuantitiesString(self, *args)


    def getScalarQuantitiesCount(self, q=None):
        """
        getScalarQuantitiesCount(Scenery self, Gyoto::Quantity_t * q=None) -> size_t
        getScalarQuantitiesCount(Scenery self) -> size_t



        Get number of requested quantities of scalar nature.

        This is all quantities except Spectrum, BinSpectrum and ImpactCoords.

        """
        return _core.Scenery_getScalarQuantitiesCount(self, q)


    def getSpectralQuantitiesCount(self, q=None):
        """
        getSpectralQuantitiesCount(Scenery self, Gyoto::Quantity_t * q=None) -> size_t
        getSpectralQuantitiesCount(Scenery self) -> size_t



        Get number of requested quantities of spectral nature.

        This is Spectrum, SpectrumStokesQ, SpectrumStokesU, SpectrumStokesV
        and BinSpectrum. 
        """
        return _core.Scenery_getSpectralQuantitiesCount(self, q)


    def tMin(self, *args):
        """
        tMin(Scenery self) -> double
        tMin(Scenery self, std::string const & unit) -> double
        tMin(Scenery self, double arg2)
        tMin(Scenery self, double arg2, std::string const & unit)



        Set ph_.tmin_ in specified unit. 
        """
        return _core.Scenery_tMin(self, *args)


    def adaptive(self, *args):
        """
        adaptive(Scenery self, bool mode)
        adaptive(Scenery self) -> bool



        Get ph_.adaptive_. 
        """
        return _core.Scenery_adaptive(self, *args)


    def integrator(self, *args):
        """
        integrator(Scenery self, std::string type)
        integrator(Scenery self) -> std::string



        Passed to ph_. 
        """
        return _core.Scenery_integrator(self, *args)


    def deltaMin(self, *args):
        """
        deltaMin(Scenery self) -> double
        deltaMin(Scenery self, double h1)



        Passed to ph_. 
        """
        return _core.Scenery_deltaMin(self, *args)


    def deltaMax(self, *args):
        """
        deltaMax(Scenery self) -> double
        deltaMax(Scenery self, double h1)



        Passed to ph_. 
        """
        return _core.Scenery_deltaMax(self, *args)


    def deltaMaxOverR(self, *args):
        """
        deltaMaxOverR(Scenery self) -> double
        deltaMaxOverR(Scenery self, double t)



        Passed to ph_. 
        """
        return _core.Scenery_deltaMaxOverR(self, *args)


    def absTol(self, *args):
        """
        absTol(Scenery self, double arg2)
        absTol(Scenery self) -> double



        Passed to ph_. 
        """
        return _core.Scenery_absTol(self, *args)


    def relTol(self, *args):
        """
        relTol(Scenery self, double arg2)
        relTol(Scenery self) -> double



        Passed to ph_. 
        """
        return _core.Scenery_relTol(self, *args)


    def maxCrossEqplane(self, *args):
        """
        maxCrossEqplane(Scenery self, double arg2)
        maxCrossEqplane(Scenery self) -> double



        Passed to ph_. 
        """
        return _core.Scenery_maxCrossEqplane(self, *args)


    def secondary(self, *args):
        """
        secondary(Scenery self, bool sec)
        secondary(Scenery self) -> bool



        Get ph_.secondary_. 
        """
        return _core.Scenery_secondary(self, *args)


    def integ31(self, *args):
        """
        integ31(Scenery self, bool integ)
        integ31(Scenery self) -> bool



        Get WorldlinIntegState integ_31_. 
        """
        return _core.Scenery_integ31(self, *args)


    def parallelTransport(self, *args):
        """
        parallelTransport(Scenery self, bool pt)
        parallelTransport(Scenery self) -> bool



        Get ph_.parallel_transport_. 
        """
        return _core.Scenery_parallelTransport(self, *args)


    def maxiter(self, *args):
        """
        maxiter(Scenery self, size_t miter)
        maxiter(Scenery self) -> size_t



        Get ph_.maxiter_. 
        """
        return _core.Scenery_maxiter(self, *args)


    def nThreads(self, *args):
        """
        nThreads(Scenery self, size_t arg2)
        nThreads(Scenery self) -> size_t



        Get nthreads_;. 
        """
        return _core.Scenery_nThreads(self, *args)


    def nProcesses(self, *args):
        """
        nProcesses(Scenery self, size_t arg2)
        nProcesses(Scenery self) -> size_t



        Get nprocesses_;. 
        """
        return _core.Scenery_nProcesses(self, *args)


    def intensityConverter(self, unit):
        """
        intensityConverter(Scenery self, std::string unit)



        Set Scenery::intensity_converter_. 
        """
        return _core.Scenery_intensityConverter(self, unit)


    def spectrumConverter(self, unit):
        """
        spectrumConverter(Scenery self, std::string unit)



        Set Scenery::spectrum_converter_. 
        """
        return _core.Scenery_spectrumConverter(self, unit)


    def binSpectrumConverter(self, unit):
        """
        binSpectrumConverter(Scenery self, std::string unit)



        Set Scenery::binspectrum_converter_. 
        """
        return _core.Scenery_binSpectrumConverter(self, unit)


    def setPropertyConverters(self, prop):
        """
        setPropertyConverters(Scenery self, AstrobjProperties prop)



        Copy converters to Astrobj::Properties instance.

        Copy Scenery::intensity_converter_, Scenery::spectrum_converter_ and
        Scenery::binspectrum_converter_ to there alter ego in *prop. 
        """
        return _core.Scenery_setPropertyConverters(self, prop)


    def rayTrace(self, ij, data, impactcoords=None):
        """
        rayTrace(Scenery self, Coord2dSet ij, AstrobjProperties data, double * impactcoords=None)
        rayTrace(Scenery self, Coord2dSet ij, AstrobjProperties data)



        Perform ray-tracing.

        For each directions specified, launch a Photon back in time to compute
        the various quantities.

        At this time, the computed quantities depend on on the pointers in
        *data which are not NULL.

        rayTrace() uses  setPropertyConverters() to set the converters in
        *data;

        Astrobj::Properties::init() to initialize each cell in *data;

        Astrobj::Properties::operator++() to step through the arrays in *data.

        data must have been instantiated prior to calling rayTrace and the
        various pointers in *data must be NULL or point to the first cell in
        an array of size at least Screen::npix_ squared.

        If MPI support is built-in, MPI_Init() has been called, and
        nprocesses_ is1, then rayTrace() will use several processes, launching
        them using mpiSpawn() if necessary.

        Else, if Scenery::nthreads_ is2 and Gyoto has been compiled with
        pthreads support, rayTrace() will use Scenery::nthreads_ threads and
        launch photons in parallel. This works only if the
        Astrobj::Generic::clone() and Metric::Generic::clone() methods have
        been properly implemented for the specific astrobj and metric kind,
        and if they are both thread-safe. At the moment, unfortunately, Lorene
        metrics are known to not be thread-safe.

        Parameters:
        -----------

        ij:   Screen::Coord2dSet specification of rays to trace. e.g.:

        Parameters:
        -----------

        data:  Pointer to a preallocated Astrobj::Properties instance which
        sets which quantities must be computed and where to store the output.

        impactcoords:  Optional pointer to an array of pre-computed impact
        coordinates. If impactcoords is provided, rayTracing is skipped and
        the quantities in *data are fill assuming that the impact coordinates
        are correct. This only makes sense in optically thick mode, when ray-
        tracing several sceneries for which the shape of the object is
        identical but their emission distributions are not. impactcoords can
        be computed using the ImpactCoords quantity. 
        """
        return _core.Scenery_rayTrace(self, ij, data, impactcoords)


    def __call__(self, *args):
        """
        __call__(Scenery self, size_t i, size_t j, AstrobjProperties data, double * impactcoords=None, Photon * ph=None)
        __call__(Scenery self, size_t i, size_t j, AstrobjProperties data, double * impactcoords=None)
        __call__(Scenery self, size_t i, size_t j, AstrobjProperties data)
        __call__(Scenery self, double alpha, double delta, AstrobjProperties data, Photon * ph=None)
        __call__(Scenery self, double alpha, double delta, AstrobjProperties data)
        """
        return _core.Scenery___call__(self, *args)


    def fillProperty(self, fmp, p):
        """
        fillProperty(Scenery self, FactoryMessenger fmp, Property p)



        Output a single Property to XML.

        The base implementation decides what to do based on the p.type. The
        format matches how setParameters() an setParameter() would interpret
        the XML descition.

        Overriding this method should be avoided, but makes sense in some
        cases (for instance Screen::fillProperty() selects a different unit
        for Distance based on its magnitude, so that stellar sizes are
        expressed in solar radii while smaller sizes can be expressed in
        meters and larger sizes in parsecs).

        Overriding implementation should fall-back on calling the
        implementation in the direct parent class: 
        """
        return _core.Scenery_fillProperty(self, fmp, p)


    def fillElement(self, fmp):
        """
        fillElement(Scenery self, FactoryMessenger fmp)



        Fill the XML element for this Object.

        The base implementation simply calls fillProperty() for each Property
        defined for the Object.

        Derived classes should avoid overriding fillElement(). It may make
        sense occasionally, e.g. to make sure that the metric is output first.

        To customize how a given Property is rendered, it is better to
        override fillProperty().

        If this method is overridden, the implementation should in general
        call fillElement() on the direct base. 
        """
        return _core.Scenery_fillElement(self, fmp)


    def Subcontractor(arg1):
        """Subcontractor(FactoryMessenger arg1) -> Gyoto::SmartPointer< Gyoto::Scenery >"""
        return _core.Scenery_Subcontractor(arg1)

    Subcontractor = staticmethod(Subcontractor)

    def __str__(self):
        """__str__(Scenery self) -> std::string"""
        return _core.Scenery___str__(self)

Scenery_swigregister = _core.Scenery_swigregister
Scenery_swigregister(Scenery)

def Scenery_mpiWorker():
    """Scenery_mpiWorker()"""
    return _core.Scenery_mpiWorker()
Scenery.properties = _core.cvar.Scenery_properties
Scenery.builtinPluginValue = _core.cvar.Scenery_builtinPluginValue

def Scenery_Subcontractor(arg2):
    """Scenery_Subcontractor(FactoryMessenger arg2) -> Gyoto::SmartPointer< Gyoto::Scenery >"""
    return _core.Scenery_Subcontractor(arg2)

class Photon(Worldline, SmartPointee, Object):
    """


    A null geodesic transporting light.

    This is the central object for ray-tracing.

    C++ includes: GyotoPhoton.h 
    """

    __swig_setmethods__ = {}
    for _s in [Worldline, SmartPointee, Object]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Photon, name, value)
    __swig_getmethods__ = {}
    for _s in [Worldline, SmartPointee, Object]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Photon, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(Photon self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _core.Photon_getProperties(self)


    def plugins(self, *args):
        """
        plugins(Photon self, vector_string plugname)
        plugins(Photon self) -> vector_string
        """
        return _core.Photon_plugins(self, *args)


    def isThreadSafe(self):
        """
        isThreadSafe(Photon self) -> bool



        Whether this class is thread-safe.

        Return True if this object is thread-safe, i.e. if an instance and its
        clone can be used in parallel threads (in the context of
        Scenery::raytrace()). Known objects which are not thread-safe include
        Lorene metrics and everything from the Python plug-in.

        The default implementation considers that the class itself is thread
        safe and recurses into the declared properties to check whether they
        are safe too. Classes that abide to the Object/Property paradigm and
        are themselves thread-safe have nothing special to do.

        Objects that clone children in their copy constructor that are not
        declared as properties must take these children into account.

        Classes that are never thread-safe must declare it. It acn be easily
        done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
        GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. 
        """
        return _core.Photon_isThreadSafe(self)


    def _delta(self, *args):
        """
        _delta(Photon self, double const delta)
        _delta(Photon self, double arg2, std::string const & unit)
        _delta(Photon self) -> double
        _delta(Photon self, std::string const & unit) -> double
        """
        return _core.Photon__delta(self, *args)


    def _tMin(self, *args):
        """
        _tMin(Photon self, double const tmin)
        _tMin(Photon self, double arg2, std::string const & unit)
        _tMin(Photon self) -> double
        _tMin(Photon self, std::string const & unit) -> double
        """
        return _core.Photon__tMin(self, *args)


    def _adaptive(self, *args):
        """
        _adaptive(Photon self, bool mode)
        _adaptive(Photon self) -> bool
        """
        return _core.Photon__adaptive(self, *args)


    def _secondary(self, *args):
        """
        _secondary(Photon self, bool sec)
        _secondary(Photon self) -> bool
        """
        return _core.Photon__secondary(self, *args)


    def _integ31(self, *args):
        """
        _integ31(Photon self, bool sec)
        _integ31(Photon self) -> bool
        """
        return _core.Photon__integ31(self, *args)


    def _parallelTransport(self, *args):
        """
        _parallelTransport(Photon self, bool sec)
        _parallelTransport(Photon self) -> bool
        """
        return _core.Photon__parallelTransport(self, *args)


    def _maxiter(self, *args):
        """
        _maxiter(Photon self, size_t miter)
        _maxiter(Photon self) -> size_t
        """
        return _core.Photon__maxiter(self, *args)


    def _integrator(self, *args):
        """
        _integrator(Photon self, std::string const & type)
        _integrator(Photon self) -> std::string
        """
        return _core.Photon__integrator(self, *args)


    def _deltaMin(self, *args):
        """
        _deltaMin(Photon self) -> double
        _deltaMin(Photon self, double h1)
        """
        return _core.Photon__deltaMin(self, *args)


    def _absTol(self, *args):
        """
        _absTol(Photon self, double arg2)
        _absTol(Photon self) -> double
        """
        return _core.Photon__absTol(self, *args)


    def _maxCrossEqplane(self, *args):
        """
        _maxCrossEqplane(Photon self, double arg2)
        _maxCrossEqplane(Photon self) -> double
        """
        return _core.Photon__maxCrossEqplane(self, *args)


    def _relTol(self, *args):
        """
        _relTol(Photon self, double arg2)
        _relTol(Photon self) -> double
        """
        return _core.Photon__relTol(self, *args)


    def _deltaMax(self, *args):
        """
        _deltaMax(Photon self, double h1)
        _deltaMax(Photon self) -> double
        """
        return _core.Photon__deltaMax(self, *args)


    def _deltaMaxOverR(self, *args):
        """
        _deltaMaxOverR(Photon self) -> double
        _deltaMaxOverR(Photon self, double t)
        """
        return _core.Photon__deltaMaxOverR(self, *args)


    def _initCoord(self, *args):
        """
        _initCoord(Photon self) -> vector_double
        _initCoord(Photon self, vector_double f)
        """
        return _core.Photon__initCoord(self, *args)


    def _metric(self, *args):
        """
        _metric(Photon self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)
        _metric(Photon self) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >
        """
        return _core.Photon__metric(self, *args)


    def className(self):
        """
        className(Photon self) -> std::string



        "Photon" 
        """
        return _core.Photon_className(self)


    def className_l(self):
        """
        className_l(Photon self) -> std::string



        "photon" 
        """
        return _core.Photon_className_l(self)


    def clone(self):
        """
        clone(Photon self) -> Photon



        Cloner. 
        """
        return _core.Photon_clone(self)


    def __init__(self, *args):
        """
        __init__(Gyoto::Photon self) -> Photon
        __init__(Gyoto::Photon self, Photon arg2) -> Photon
        __init__(Gyoto::Photon self, Gyoto::SmartPointer< Gyoto::Metric::Generic > gg, Gyoto::SmartPointer< Gyoto::Astrobj::Generic > obj, double * coord) -> Photon
        __init__(Gyoto::Photon self, Gyoto::SmartPointer< Gyoto::Metric::Generic > gg, Gyoto::SmartPointer< Gyoto::Astrobj::Generic > obj, Gyoto::SmartPointer< Gyoto::Screen > screen, double d_alpha, double d_delta) -> Photon



        Same as Photon() followed by
        setInitialCondition(SmartPointer<Metric::Generic> gg,
        SmartPointer<Astrobj::Generic> obj, SmartPointer<Screen> screen,
        double d_alpha, double d_delta) 
        """
        this = _core.new_Photon(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_Photon
    __del__ = lambda self: None

    def getMass(self):
        """
        getMass(Photon self) -> double



        Return 0. 
        """
        return _core.Photon_getMass(self)


    def astrobj(self, *args):
        """
        astrobj(Photon self, Gyoto::SmartPointer< Gyoto::Astrobj::Generic > arg2)
        astrobj(Photon self) -> Gyoto::SmartPointer< Gyoto::Astrobj::Generic >



        Get Photon::object_. 
        """
        return _core.Photon_astrobj(self, *args)


    def metric(self, *args):
        """
        metric(Photon self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)
        metric(Photon self) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >
        metric(Photon self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)



        Get metric. 
        """
        return _core.Photon_metric(self, *args)


    def spectrometer(self, *args):
        """
        spectrometer(Photon self, Gyoto::SmartPointer< Gyoto::Spectrometer::Generic > spr)
        spectrometer(Photon self) -> Gyoto::SmartPointer< Gyoto::Spectrometer::Generic >



        Get Photon::spectro_. 
        """
        return _core.Photon_spectrometer(self, *args)


    def freqObs(self, *args):
        """
        freqObs(Photon self, double arg2)
        freqObs(Photon self) -> double



        Get Photon::freq_obs__. 
        """
        return _core.Photon_freqObs(self, *args)


    def nb_cross_eqplane(self, *args):
        """
        nb_cross_eqplane(Photon self, int arg2)
        nb_cross_eqplane(Photon self) -> int



        Get Photon::nb_cross_eqplane_. 
        """
        return _core.Photon_nb_cross_eqplane(self, *args)


    def setInitialCondition(self, *args):
        """
        setInitialCondition(Photon self, Gyoto::SmartPointer< Gyoto::Metric::Generic > gg, double const [8] coord, int const dir, double const [4] Ephi, double const [4] Etheta)
        setInitialCondition(Photon self, Gyoto::SmartPointer< Gyoto::Metric::Generic > gg, double const [8] coord, int const dir)
        setInitialCondition(Photon self, Gyoto::SmartPointer< Gyoto::Metric::Generic > gg, Gyoto::SmartPointer< Gyoto::Astrobj::Generic > obj, double const [8] coord)
        setInitialCondition(Photon self, Gyoto::SmartPointer< Gyoto::Metric::Generic > gg, Gyoto::SmartPointer< Gyoto::Astrobj::Generic > obj, double const [8] coord, double const [4] Ephi, double const [4] Etheta)
        setInitialCondition(Photon self, Gyoto::SmartPointer< Gyoto::Metric::Generic > gg, Gyoto::SmartPointer< Gyoto::Astrobj::Generic > obj, Gyoto::SmartPointer< Gyoto::Screen > screen, double d_alpha, double d_delta)



        Set or re-set the initial condition prior to integration.

        Parameters:
        -----------

        gg:   Gyoto::SmartPointer to the Gyoto::Metric in this universe;

        coord:  8 element array containing the initial condition, i.e. the
        4-position and the 4-velocity of the Photon at the receiving end;

        dir:  direction: 1 for future, -1 for past. 
        """
        return _core.Photon_setInitialCondition(self, *args)


    def hit(self, data=None):
        """
        hit(Photon self, AstrobjProperties data=None) -> int
        hit(Photon self) -> int



        Integrate the geodesic.

        Parameters:
        -----------

        data:  Optional Astrobj::Properties to fill with observational
        quantities.

        1 if object was hit, else 0. 
        """
        return _core.Photon_hit(self, data)


    def findMin(self, *args):
        """
        findMin(Photon self, Functor__Double_constDoubleArray object, double t1, double t2, double & tmin, double threshold) -> double
        findMin(Photon self, Functor__Double_constDoubleArray object, double t1, double t2, double & tmin) -> double



        Find minimum of photonobject distance.

        Return the minimum of (*object)(this-> getCoord()) between t1 and t2.
        The date of this minimum is returned in tmin.

        Parameters:
        -----------

        object:  the distance to minimize is given by object->operator()().
        This method is in particular implemented by the subclasses of
        Astrobj::Standard.

        t1:  date

        t2:  date

        tmin:  on output, date correspondig to the minimum

        threshold:  stop searching for a minimum if a value < threshold is
        found (very often, we just want to find a date below the threshold,
        not the accurate minimum). 
        """
        return _core.Photon_findMin(self, *args)


    def findValue(self, object, value, tinside, toutside):
        """
        findValue(Photon self, Functor__Double_constDoubleArray object, double value, double tinside, double & toutside)



        Find date for which the photon is at a given distance from the object.

        Parameters:
        -----------

        object:   Object, must implement operator() (e.g. Astrobj::Standard,
        ThinDisk::Standard)

        value:  The value to find

        tinside:  A date for which
        object->Astrobj::operator()(Photon::getCoord()) is < value

        toutside:  On input: a date for which
        object->Astrobj::operator()(Photon::getCoord()) is > value. on output,
        (*object)(getCoord(toutside)) is < value, very close to value.
        toutside is closer to tinside on output than on input. 
        """
        return _core.Photon_findValue(self, object, value, tinside, toutside)


    def setParameters(self, fmp):
        """
        setParameters(Photon self, FactoryMessenger fmp)



        Main loop for parsing Properties from XML description.

        This function queries the FactoryMessenger for elements to parse, and
        tries to matche each element to a Property to set it  accordingly. Any
        class that tries to be buildable from XML must supply a subcontractor
        (for base classes such as Metric, Astrobj, Spectrum  and Spectrometer,
        it is done as a template that must be  specialized for each class).
        This subcontractor typically looks somewhat like this: Although this
        is discouraged, it is possible to override the following functions to
        customize how XML entities are parsed:    - setParameters() if low-
        level access to the      FactoryMessenger is required;    -
        setParameter(std::string name, std::string content,
        std::string unit)      to interpret an entity that does not match a
        Property      (e.g. alternative name);    -
        setParameter(Gyoto::Property const &p, std::string const &name,
        std::string const &content, std::string const &unit)      to change
        how a Property is interpreted. 
        """
        return _core.Photon_setParameters(self, fmp)


    def Subcontractor(arg1):
        """Subcontractor(FactoryMessenger arg1) -> Gyoto::SmartPointer< Gyoto::Photon >"""
        return _core.Photon_Subcontractor(arg1)

    Subcontractor = staticmethod(Subcontractor)

    def resetTransmission(self):
        """
        resetTransmission(Photon self)



        Set transmission to 1 for each channel as well as scalar transmission.

        """
        return _core.Photon_resetTransmission(self)


    def resetTransmissionMatrix(self):
        """
        resetTransmissionMatrix(Photon self)



        Set transmission matrix to identity matrix for each frequency. 
        """
        return _core.Photon_resetTransmissionMatrix(self)


    def getTransmissionMax(self):
        """
        getTransmissionMax(Photon self) -> double



        Get maximum transmission;.

        Get current maximum of all the transmissions,
        Photon::transmission_freqobs_ or one elements of the
        Photon::transmission_ array. 
        """
        return _core.Photon_getTransmissionMax(self)


    def getTransmission(self, *args):
        """
        getTransmission(Photon self, size_t i) -> double
        getTransmission(Photon self) -> double const *



        Get Photon::transmission_.

        getTansmission()[i] == getTransmission(size_t i) 
        """
        return _core.Photon_getTransmission(self, *args)


    def getTransmissionMatrix(self, *args):
        """
        getTransmissionMatrix(Photon self, size_t i) -> Eigen::Matrix4d
        getTransmissionMatrix(Photon self) -> Eigen::Matrix4d const *



        Get Photon::transmissionMatrix_.

        getTansmissionMatrix()[i] == getTransmissionMatrix(size_t i) 
        """
        return _core.Photon_getTransmissionMatrix(self, *args)


    def transmit(self, *args):
        """
        transmit(Photon self, size_t i, double t)
        transmit(Photon self, size_t i, Eigen::Matrix4d mat)



        Update transmission matrix in a given channel.

        getTransmissionMatrix(size_t i) *= mat.

        Parameters:
        -----------

        i:  channel number. -1 for Matrix Photon::transmissionMatrix_freqobs_.

        mat:  transmission Matrix of this fluid element. 
        """
        return _core.Photon_transmit(self, *args)


    def transfer(self, Inu, Qnu, Unu, Vnu, Onu):
        """
        transfer(Photon self, double * Inu, double * Qnu, double * Unu, double * Vnu, Eigen::Matrix4d * Onu)



        Perform one step of polarized radiative transfert and update
        transmission matrix. 
        """
        return _core.Photon_transfer(self, Inu, Qnu, Unu, Vnu, Onu)


    def __str__(self):
        """__str__(Photon self) -> std::string"""
        return _core.Photon___str__(self)

Photon_swigregister = _core.Photon_swigregister
Photon_swigregister(Photon)
Photon.properties = _core.cvar.Photon_properties
Photon.builtinPluginValue = _core.cvar.Photon_builtinPluginValue

def Photon_Subcontractor(arg2):
    """Photon_Subcontractor(FactoryMessenger arg2) -> Gyoto::SmartPointer< Gyoto::Photon >"""
    return _core.Photon_Subcontractor(arg2)


def getAstrobjRegister():
    """getAstrobjRegister() -> RegisterEntry"""
    return _core.getAstrobjRegister()

def getAstrobjSubcontractor(name, plugin, errmode=0):
    """
    getAstrobjSubcontractor(std::string name, vector_string plugin, int errmode=0) -> Gyoto::Astrobj::Subcontractor_t
    getAstrobjSubcontractor(std::string name, vector_string plugin) -> Gyoto::Astrobj::Subcontractor_t *
    """
    return _core.getAstrobjSubcontractor(name, plugin, errmode)

def initAstrobjRegister():
    """initAstrobjRegister()"""
    return _core.initAstrobjRegister()

def registerAstrobj(name, scp):
    """registerAstrobj(std::string name, Gyoto::Astrobj::Subcontractor_t * scp)"""
    return _core.registerAstrobj(name, scp)
class Astrobj(SmartPointee, Object):
    """


    Base class for astronomical object.

    See introduction in the Gyoto::Astrobj namespace.

    C++ includes: GyotoAstrobj.h 
    """

    __swig_setmethods__ = {}
    for _s in [SmartPointee, Object]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Astrobj, name, value)
    __swig_getmethods__ = {}
    for _s in [SmartPointee, Object]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Astrobj, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(Astrobj self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _core.Astrobj_getProperties(self)


    def plugins(self, *args):
        """
        plugins(Astrobj self, vector_string plugname)
        plugins(Astrobj self) -> vector_string
        """
        return _core.Astrobj_plugins(self, *args)


    def clone(self):
        """
        clone(Astrobj self) -> Astrobj



        Cloner.

        This method must be implemented by the various Astrobj::Generic
        subclasses in order to support cloning:

        Cloning is necessary for multi-threading, recommended for interaction
        with the Yorick plug-in etc.

        Implementing it is very straightforward, as long as the copy
        constructor Generic(const Generic& ) has been implemented: 
        """
        return _core.Astrobj_clone(self)

    __swig_destroy__ = _core.delete_Astrobj
    __del__ = lambda self: None

    def metric(self, *args):
        """
        metric(Astrobj self) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >
        metric(Astrobj self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)



        Set the Metric gg_. 
        """
        return _core.Astrobj_metric(self, *args)


    def deltaMax(self, coord):
        """
        deltaMax(Astrobj self, double [8] coord) -> double



        Get max step constraint for adaptive integration.

        Parameters:
        -----------

        coord:  position

        max step to find this object reliably 
        """
        return _core.Astrobj_deltaMax(self, coord)


    def rMax(self, *args):
        """
        rMax(Astrobj self) -> double
        rMax(Astrobj self) -> double
        rMax(Astrobj self, std::string const & unit) -> double
        rMax(Astrobj self, std::string const & unit) -> double
        rMax(Astrobj self, double val)
        rMax(Astrobj self, double val, std::string const & unit)



        Set maximal distance from center of coordinate system.

        Call Generic::rMax(double val) after converting val from unit to
        geometrical units.

        Parameters:
        -----------

        val:   rmax_ expressed in unit "unit";

        unit:  string... 
        """
        return _core.Astrobj_rMax(self, *args)


    def deltaMaxInsideRMax(self, *args):
        """
        deltaMaxInsideRMax(Astrobj self, double arg2)
        deltaMaxInsideRMax(Astrobj self) -> double
        deltaMaxInsideRMax(Astrobj self, double arg2, std::string const & arg3)
        deltaMaxInsideRMax(Astrobj self, std::string const & arg2) -> double
        """
        return _core.Astrobj_deltaMaxInsideRMax(self, *args)


    def opticallyThin(self, *args):
        """
        opticallyThin(Astrobj self, bool flag)
        opticallyThin(Astrobj self) -> bool



        Query whether object is optically thin.

        See opticallyThin(bool flag). 
        """
        return _core.Astrobj_opticallyThin(self, *args)


    def showshadow(self, *args):
        """
        showshadow(Astrobj self, bool flag)
        showshadow(Astrobj self) -> bool
        """
        return _core.Astrobj_showshadow(self, *args)


    def redshift(self, *args):
        """
        redshift(Astrobj self, bool flag)
        redshift(Astrobj self) -> bool
        """
        return _core.Astrobj_redshift(self, *args)


    def getDefaultQuantities(self):
        """
        getDefaultQuantities(Astrobj self) -> Gyoto::Quantity_t



        Which quantities to compute if know was requested.

        Return a Gyoto::Quantity_t suitable as input to
        Gyoto::Scenery::setRequestedQuantities() to set de default quantities
        to compute for this object. The default of these defaults
        GYOTO_QUANTITY_INTENSITY. 
        """
        return _core.Astrobj_getDefaultQuantities(self)


    def setParameters(self, fmp):
        """
        setParameters(Astrobj self, FactoryMessenger fmp)



        Main loop in Subcontractor_t function.

        The Subcontractor_t function for each Astrobj kind should look
        somewhat like this (templated as
        Gyoto::Astrobj::Subcontractor<MyKind>):

        Each object kind should implement setParameter(string name, string
        content, string unit) to interpret the individual XML elements.
        setParameters() can be overloaded in case the specific Astrobj class
        needs low level access to the FactoryMessenger. See
        UniformSphere::setParameters(). 
        """
        return _core.Astrobj_setParameters(self, fmp)


    def Impact(self, ph, index, data=None):
        """
        Impact(Astrobj self, Photon ph, size_t index, AstrobjProperties data=None) -> int
        Impact(Astrobj self, Photon ph, size_t index) -> int



        Does a photon at these coordinates impact the object?

        Impact() checks whether a Photon impacts the object between two
        integration steps of the photon's trajectory (those two steps are
        photon->getCoord(index, coord1) and photon->getCoord(index+1,
        coord2)). Impact returns 1 if the photon impacts the object between
        these two steps, else 0. In many cases of geometrically thick obects,
        the implementation Astrobj::Standard::Impact() will be fine.

        Impact will call Generic::processHitQuantities() (which is virtual and
        may be re-implemented) to compute observable properties on demand: if
        the data pointer is non-NULL, the object will look in it for pointers
        to properties which apply to its kind. If a pointer to a property
        known to this object is present, then the property is computed and
        store at the pointed-to address. For instance, all objects know the
        "intensity" property. If data->intensity != NULL, the instensity is
        computed and stored in *data->intensity.

        If data is non-NULL and only in this case, processHitQuantities() will
        also call ph->transmit() to update the transmissions of the Photon
        (see Photon::transmit(size_t, double)). This must not be done if data
        is NULL (see Astrobj::Complex::Impact() for an explanation).

        Impact() may not extend the ph Worldline. The only two dates that are
        guaranteed to be defined are at indices index and index+1.

        Parameters:
        -----------

        ph:   Gyoto::Photon aimed at the object;

        index:  Index of the last photon step;

        data:  Pointer to a structure to hold the observables at impact.

        1 if impact, 0 if not. 
        """
        return _core.Astrobj_Impact(self, ph, index, data)


    def processHitQuantities(self, ph, coord_ph_hit, coord_obj_hit, dt, data):
        """processHitQuantities(Astrobj self, Photon ph, vector_double coord_ph_hit, double const * coord_obj_hit, double dt, AstrobjProperties data)"""
        return _core.Astrobj_processHitQuantities(self, ph, coord_ph_hit, coord_obj_hit, dt, data)


    def emission(self, *args):
        """
        emission(Astrobj self, double nu_em, double dsem, vector_double coord_ph, double const [8] coord_obj=0) -> double
        emission(Astrobj self, double nu_em, double dsem, vector_double coord_ph) -> double
        emission(Astrobj self, double [] Inu, double const [] nu_em, size_t nbnu, double dsem, vector_double coord_ph, double const [8] coord_obj=0)
        emission(Astrobj self, double [] Inu, double const [] nu_em, size_t nbnu, double dsem, vector_double coord_ph)



        Obsolete, update your code. 
        """
        return _core.Astrobj_emission(self, *args)


    def radiativeQ(self, *args):
        """
        radiativeQ(Astrobj self, double [] Inu, double [] Taunu, double const [] nu_em, size_t nbnu, double dsem, vector_double coord_ph, double const [8] coord_obj=0)
        radiativeQ(Astrobj self, double [] Inu, double [] Taunu, double const [] nu_em, size_t nbnu, double dsem, vector_double coord_ph)
        radiativeQ(Astrobj self, double * Inu, double * Qnu, double * Unu, double * Vnu, Eigen::Matrix4d * Onu, double const * nuem, size_t nbnu, double dsem, vector_double cph, double const * co)



        Compute the increment of Stokes parameters and transmission matrix.
        Polarised version of RadiaveQ.

        First function to be called for radiative quantities. If exist, i.e.
        implemented in an Astrobj, return the Stokes parameters emitted by the
        small volume of length dsem.

        Warning : The basis used to determine the Stokes coefficients is
        different from the observer parallel transported polarisation basis.
        One should use getChi function to compute the angle between these two
        basis.

        The non polarized case must also be implemented in this function to
        avoid error.

        See exemple in SimplePolarStar.C.

        Parameters:
        -----------

        Inu[nbnu]:  Output increment of intensity (must be set to a previously
        allocated array of doubles)

        Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
        previously allocated array of doubles)

        Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
        previously allocated array of doubles)

        Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
        previously allocated array of doubles)

        Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
        previously allocated array of Matrix4d)

        nu_em[nbnu]:  Frequencies at emission

        nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

        dsem:  Length over which to integrate inside the object

        cph:   Photon coordinate

        co:  Emitter coordinate at current photon position

        Increment of the Stokes parameters (I,Q,U,V) and local Transmission
        matrix (O). 
        """
        return _core.Astrobj_radiativeQ(self, *args)


    def integrateEmission(self, *args):
        """
        integrateEmission(Astrobj self, double nu1, double nu2, double dsem, vector_double c_ph, double const [8] c_obj=0) -> double
        integrateEmission(Astrobj self, double nu1, double nu2, double dsem, vector_double c_ph) -> double
        integrateEmission(Astrobj self, double * I, double const * boundaries, size_t const * chaninds, size_t nbnu, double dsem, vector_double cph, double const * co)



        Obsolete, update your code. 
        """
        return _core.Astrobj_integrateEmission(self, *args)


    def transmission(self, nuem, dsem, coord_ph, coord_obj):
        """
        transmission(Astrobj self, double nuem, double dsem, vector_double coord_ph, double const [8] coord_obj) -> double



        Obsolete, update your code. 
        """
        return _core.Astrobj_transmission(self, nuem, dsem, coord_ph, coord_obj)


    def Omatrix(self, *args):
        """
        Omatrix(Astrobj self, double [4] alphanu, double [3] rnu, double Chi, double dsem) -> Eigen::Matrix4d
        Omatrix(Astrobj self, double alphaInu, double alphaQnu, double alphaUnu, double alphaVnu, double rQnu, double rUnu, double rVnu, double Chi, double dsem) -> Eigen::Matrix4d
        Omatrix(Astrobj self, double [4] alphanu, double [3] rnu, double sin2Chi, double cos2Chi, double dsem) -> Eigen::Matrix4d
        Omatrix(Astrobj self, double alphaInu, double alphaQnu, double alphaUnu, double alphaVnu, double rQnu, double rUnu, double rVnu, double sin2Chi, double cos2Chi, double dsem) -> Eigen::Matrix4d
        """
        return _core.Astrobj_Omatrix(self, *args)


    def Pmatrix(self, alphaInu, alphaQnu, alphaUnu, alphaVnu, rQnu, rUnu, rVnu, sin2Chi, cos2Chi, dsem):
        """Pmatrix(Astrobj self, double alphaInu, double alphaQnu, double alphaUnu, double alphaVnu, double rQnu, double rUnu, double rVnu, double sin2Chi, double cos2Chi, double dsem) -> Eigen::Matrix4d"""
        return _core.Astrobj_Pmatrix(self, alphaInu, alphaQnu, alphaUnu, alphaVnu, rQnu, rUnu, rVnu, sin2Chi, cos2Chi, dsem)


    def rotateJs(self, *args):
        """
        rotateJs(Astrobj self, double jInu, double jQnu, double jUnu, double jVnu, double sin2Chi, double cos2Chi) -> Eigen::Vector4d
        rotateJs(Astrobj self, double jInu, double jQnu, double jUnu, double jVnu, double Chi) -> Eigen::Vector4d
        """
        return _core.Astrobj_rotateJs(self, *args)


    def getChi(self, fourvect, cph, vel, elec=False):
        """
        getChi(Astrobj self, double const [4] fourvect, vector_double cph, double const [4] vel, bool elec=False) -> double
        getChi(Astrobj self, double const [4] fourvect, vector_double cph, double const [4] vel) -> double



        Get Chi angle. Return the angle between the parallel transported
        observer polarization basis (Ephi,Etheta) and the Stokes basis in the
        rest frame of the emitter defined by the 4-vector magnetic/electric
        field.

        Parameters:
        -----------

        fourvect:  4-vector magnetic/electric field depending on elec
        (false/true)

        cph:   Photon coordinate, must contain the Ephi and Etheta vectors
        i.e. size(cph)==16

        vel:  Fluid velocity at the photon coordinate 
        """
        return _core.Astrobj_getChi(self, fourvect, cph, vel, elec)


    def getSinCos2Chi(self, fourvect, cph, vel, sin2Chi, cos2Chi, elec=False):
        """
        getSinCos2Chi(Astrobj self, double const [4] fourvect, vector_double cph, double const [4] vel, double * sin2Chi, double * cos2Chi, bool elec=False)
        getSinCos2Chi(Astrobj self, double const [4] fourvect, vector_double cph, double const [4] vel, double * sin2Chi, double * cos2Chi)



        Get the cosinus and sinus of 2*Chi angle. Chi being the angle between
        the parallel transported observer polarization basis (Ephi,Etheta) and
        the Stokes basis in the rest frame of the emitter defined by the
        4-vector magnetic/electric field.

        Parameters:
        -----------

        fourvect:  4-vector magnetic/electric field depending on elec
        (false/true)

        cph:   Photon coordinate, must contain the Ephi and Etheta vectors
        i.e. size(cph)==16

        vel:  Fluid velocity at the photon coordinate 
        """
        return _core.Astrobj_getSinCos2Chi(self, fourvect, cph, vel, sin2Chi, cos2Chi, elec)


    def computeB4vect(self, B4vect, magneticConfig, co, cph):
        """
        computeB4vect(Astrobj self, double [4] B4vect, std::string const magneticConfig, double const [8] co, vector_double cph)



        Compute the magnetic field 4-vector at a given position and a given
        configuration

        Parameters:
        -----------

        B4vect:  the output 4-vector magnetic field

        magneticConfig:  string which determine the wanted configuration
        ('Radial', 'Azimuthal', 'Vertical')

        co:  coordinate of the object which also contain its velocity

        cph:  coordinate of the photon 
        """
        return _core.Astrobj_computeB4vect(self, B4vect, magneticConfig, co, cph)


    def computeB4vect_ipole(self, B4vect, magneticConfig, co, cph, spin):
        """computeB4vect_ipole(Astrobj self, double [4] B4vect, std::string const magneticConfig, double const [8] co, vector_double cph, double spin)"""
        return _core.Astrobj_computeB4vect_ipole(self, B4vect, magneticConfig, co, cph, spin)


    def interpolate(self, *args):
        """
        interpolate(Astrobj self, int const N, double *const array, double *const Xq, double **const X, int *const X_params, std::string const * cond_limits) -> double
        interpolate(Astrobj self, int const N, double *const array, double *const Xq, double **const X_params, std::string const * cond_limits) -> double



        N-dimensional linear interpolation function

        Parameters:
        -----------

        N:  number of dimensions

        array:  array that should be interpolated. This array has to be a 1D
        array with the first dimension evolving the slowest

        Xq:  query position at which the interpolation should be done. 1D
        array with N elements.

        X_params[N][3]:  2D array that contain the minimum value, the maximum
        value and the length of each axes. The axes will be assumed to be
        linearly spaced.

        cond_limits:  1D array of strings that set the boundary conditions
        that will be applied to each axes. 
        """
        return _core.Astrobj_interpolate(self, *args)


    def __init__(self, *args):
        """
        Generic(std::string nm) -> Astrobj
        Generic(std::string nm, vector_string plugin) -> Astrobj
        Generic(long address) -> Astrobj
        __init__(Gyoto::Astrobj::Generic self, Astrobj orig) -> Astrobj



        Copy constructor.

        Make a deep copy of an Astrobj::Generic instance 
        """
        this = _core.new_Astrobj(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __str__(self):
        """__str__(Astrobj self) -> std::string"""
        return _core.Astrobj___str__(self)

Astrobj_swigregister = _core.Astrobj_swigregister
Astrobj_swigregister(Astrobj)
Astrobj.properties = _core.cvar.Astrobj_properties
Astrobj.builtinPluginValue = _core.cvar.Astrobj_builtinPluginValue

class AstrobjProperties(SmartPointee):
    """


    Observable properties of an Astronomical object.

    The sort of properties one wants to measure on a ray-traced
    Gyoto::Photon which hits a Gyoto::Astrobj. Not all Astrobj are able to
    fill all of these properties.

    An instance of Properties essentially contains a bunch of pointers to
    memory areas where the observable quantities (see Quantity_t) should
    be stored.

    Astrobj::Generic::processHitQuantities() fills the various arrays upon
    request. A quantity is ignored if the corresponding pointer is NULL.

    Scenery::operator()() increments the Properties between each Photon
    using Properties::operator++().

    The main application (gyoto, the yorick plug-in, or your user
    application) is responsible for allocating the various arrays, filling
    the various members of Properties, and doing whatever meaninful with
    the arrays after they have been filled with values by the ray-tracing
    code (e.g. saving them to disk or displaying them).

    Also see Gyoto::Scenery and Gyoto::Quantity_t.

    C++ includes: GyotoAstrobj.h 
    """

    __swig_setmethods__ = {}
    for _s in [SmartPointee]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AstrobjProperties, name, value)
    __swig_getmethods__ = {}
    for _s in [SmartPointee]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AstrobjProperties, name)
    __repr__ = _swig_repr
    __swig_setmethods__["intensity"] = _core.AstrobjProperties_intensity_set
    __swig_getmethods__["intensity"] = _core.AstrobjProperties_intensity_get
    if _newclass:
        intensity = _swig_property(_core.AstrobjProperties_intensity_get, _core.AstrobjProperties_intensity_set)
    __swig_setmethods__["time"] = _core.AstrobjProperties_time_set
    __swig_getmethods__["time"] = _core.AstrobjProperties_time_get
    if _newclass:
        time = _swig_property(_core.AstrobjProperties_time_get, _core.AstrobjProperties_time_set)
    __swig_setmethods__["distance"] = _core.AstrobjProperties_distance_set
    __swig_getmethods__["distance"] = _core.AstrobjProperties_distance_get
    if _newclass:
        distance = _swig_property(_core.AstrobjProperties_distance_get, _core.AstrobjProperties_distance_set)
    __swig_setmethods__["first_dmin"] = _core.AstrobjProperties_first_dmin_set
    __swig_getmethods__["first_dmin"] = _core.AstrobjProperties_first_dmin_get
    if _newclass:
        first_dmin = _swig_property(_core.AstrobjProperties_first_dmin_get, _core.AstrobjProperties_first_dmin_set)
    __swig_setmethods__["first_dmin_found"] = _core.AstrobjProperties_first_dmin_found_set
    __swig_getmethods__["first_dmin_found"] = _core.AstrobjProperties_first_dmin_found_get
    if _newclass:
        first_dmin_found = _swig_property(_core.AstrobjProperties_first_dmin_found_get, _core.AstrobjProperties_first_dmin_found_set)
    __swig_setmethods__["redshift"] = _core.AstrobjProperties_redshift_set
    __swig_getmethods__["redshift"] = _core.AstrobjProperties_redshift_get
    if _newclass:
        redshift = _swig_property(_core.AstrobjProperties_redshift_get, _core.AstrobjProperties_redshift_set)
    __swig_setmethods__["nbcrosseqplane"] = _core.AstrobjProperties_nbcrosseqplane_set
    __swig_getmethods__["nbcrosseqplane"] = _core.AstrobjProperties_nbcrosseqplane_get
    if _newclass:
        nbcrosseqplane = _swig_property(_core.AstrobjProperties_nbcrosseqplane_get, _core.AstrobjProperties_nbcrosseqplane_set)
    __swig_setmethods__["spectrum"] = _core.AstrobjProperties_spectrum_set
    __swig_getmethods__["spectrum"] = _core.AstrobjProperties_spectrum_get
    if _newclass:
        spectrum = _swig_property(_core.AstrobjProperties_spectrum_get, _core.AstrobjProperties_spectrum_set)
    __swig_setmethods__["stokesQ"] = _core.AstrobjProperties_stokesQ_set
    __swig_getmethods__["stokesQ"] = _core.AstrobjProperties_stokesQ_get
    if _newclass:
        stokesQ = _swig_property(_core.AstrobjProperties_stokesQ_get, _core.AstrobjProperties_stokesQ_set)
    __swig_setmethods__["stokesU"] = _core.AstrobjProperties_stokesU_set
    __swig_getmethods__["stokesU"] = _core.AstrobjProperties_stokesU_get
    if _newclass:
        stokesU = _swig_property(_core.AstrobjProperties_stokesU_get, _core.AstrobjProperties_stokesU_set)
    __swig_setmethods__["stokesV"] = _core.AstrobjProperties_stokesV_set
    __swig_getmethods__["stokesV"] = _core.AstrobjProperties_stokesV_get
    if _newclass:
        stokesV = _swig_property(_core.AstrobjProperties_stokesV_get, _core.AstrobjProperties_stokesV_set)
    __swig_setmethods__["binspectrum"] = _core.AstrobjProperties_binspectrum_set
    __swig_getmethods__["binspectrum"] = _core.AstrobjProperties_binspectrum_get
    if _newclass:
        binspectrum = _swig_property(_core.AstrobjProperties_binspectrum_get, _core.AstrobjProperties_binspectrum_set)
    __swig_setmethods__["offset"] = _core.AstrobjProperties_offset_set
    __swig_getmethods__["offset"] = _core.AstrobjProperties_offset_get
    if _newclass:
        offset = _swig_property(_core.AstrobjProperties_offset_get, _core.AstrobjProperties_offset_set)
    __swig_setmethods__["impactcoords"] = _core.AstrobjProperties_impactcoords_set
    __swig_getmethods__["impactcoords"] = _core.AstrobjProperties_impactcoords_get
    if _newclass:
        impactcoords = _swig_property(_core.AstrobjProperties_impactcoords_get, _core.AstrobjProperties_impactcoords_set)
    __swig_setmethods__["user1"] = _core.AstrobjProperties_user1_set
    __swig_getmethods__["user1"] = _core.AstrobjProperties_user1_get
    if _newclass:
        user1 = _swig_property(_core.AstrobjProperties_user1_get, _core.AstrobjProperties_user1_set)
    __swig_setmethods__["user2"] = _core.AstrobjProperties_user2_set
    __swig_getmethods__["user2"] = _core.AstrobjProperties_user2_get
    if _newclass:
        user2 = _swig_property(_core.AstrobjProperties_user2_get, _core.AstrobjProperties_user2_set)
    __swig_setmethods__["user3"] = _core.AstrobjProperties_user3_set
    __swig_getmethods__["user3"] = _core.AstrobjProperties_user3_get
    if _newclass:
        user3 = _swig_property(_core.AstrobjProperties_user3_get, _core.AstrobjProperties_user3_set)
    __swig_setmethods__["user4"] = _core.AstrobjProperties_user4_set
    __swig_getmethods__["user4"] = _core.AstrobjProperties_user4_get
    if _newclass:
        user4 = _swig_property(_core.AstrobjProperties_user4_get, _core.AstrobjProperties_user4_set)
    __swig_setmethods__["user5"] = _core.AstrobjProperties_user5_set
    __swig_getmethods__["user5"] = _core.AstrobjProperties_user5_get
    if _newclass:
        user5 = _swig_property(_core.AstrobjProperties_user5_get, _core.AstrobjProperties_user5_set)
    __swig_setmethods__["intensity_converter_"] = _core.AstrobjProperties_intensity_converter__set
    __swig_getmethods__["intensity_converter_"] = _core.AstrobjProperties_intensity_converter__get
    if _newclass:
        intensity_converter_ = _swig_property(_core.AstrobjProperties_intensity_converter__get, _core.AstrobjProperties_intensity_converter__set)
    __swig_setmethods__["spectrum_converter_"] = _core.AstrobjProperties_spectrum_converter__set
    __swig_getmethods__["spectrum_converter_"] = _core.AstrobjProperties_spectrum_converter__get
    if _newclass:
        spectrum_converter_ = _swig_property(_core.AstrobjProperties_spectrum_converter__get, _core.AstrobjProperties_spectrum_converter__set)
    __swig_setmethods__["binspectrum_converter_"] = _core.AstrobjProperties_binspectrum_converter__set
    __swig_getmethods__["binspectrum_converter_"] = _core.AstrobjProperties_binspectrum_converter__get
    if _newclass:
        binspectrum_converter_ = _swig_property(_core.AstrobjProperties_binspectrum_converter__get, _core.AstrobjProperties_binspectrum_converter__set)
    __swig_setmethods__["alloc"] = _core.AstrobjProperties_alloc_set
    __swig_getmethods__["alloc"] = _core.AstrobjProperties_alloc_get
    if _newclass:
        alloc = _swig_property(_core.AstrobjProperties_alloc_get, _core.AstrobjProperties_alloc_set)

    def __init__(self, *args):
        """
        Properties() -> AstrobjProperties
        __init__(Gyoto::Astrobj::Properties self, double * arg2, double * arg3) -> AstrobjProperties



        < Set intensity and time pointers. 
        """
        this = _core.new_AstrobjProperties(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, nbnuobs=0):
        """
        init(AstrobjProperties self, size_t nbnuobs=0)
        init(AstrobjProperties self)



        Initialize observable quantities.

        The pointed-to values are initialized as follows (if the corresponding
        pointer is not NULL):

        intensity, firt_dmin_found, redshift, userN: 0

        time, distance, first_dmin: DBL_MAX

        for spectrum and binspectrum, nbnuobs values separated by offset in
        memory are initialized to 0

        for impactcoords, 16 contiguous values are initialized to DBL_MAX 
        """
        return _core.AstrobjProperties_init(self, nbnuobs)


    def increment(self):
        """increment(AstrobjProperties self) -> AstrobjProperties"""
        return _core.AstrobjProperties_increment(self)


    def __iadd__(self, offset):
        """__iadd__(AstrobjProperties self, ptrdiff_t offset) -> AstrobjProperties"""
        return _core.AstrobjProperties___iadd__(self, offset)


    def binSpectrumConverter(self, *args):
        """
        binSpectrumConverter(AstrobjProperties self, Gyoto::SmartPointer< Gyoto::Units::Converter > arg2)
        binSpectrumConverter(AstrobjProperties self, std::string arg2)
        binSpectrumConverter(AstrobjProperties self) -> Converter



        Set Properties::binspectrum_converter_. 
        """
        return _core.AstrobjProperties_binSpectrumConverter(self, *args)


    def intensityConverter(self, *args):
        """
        intensityConverter(AstrobjProperties self, Gyoto::SmartPointer< Gyoto::Units::Converter > arg2)
        intensityConverter(AstrobjProperties self, std::string arg2)
        intensityConverter(AstrobjProperties self) -> Converter



        Set Properties::intentity_converter_. 
        """
        return _core.AstrobjProperties_intensityConverter(self, *args)


    def spectrumConverter(self, *args):
        """
        spectrumConverter(AstrobjProperties self, Gyoto::SmartPointer< Gyoto::Units::Converter > arg2)
        spectrumConverter(AstrobjProperties self, std::string arg2)
        spectrumConverter(AstrobjProperties self) -> Converter



        Set Properties::spectrum_converter_. 
        """
        return _core.AstrobjProperties_spectrumConverter(self, *args)

    __swig_destroy__ = _core.delete_AstrobjProperties
    __del__ = lambda self: None
AstrobjProperties_swigregister = _core.AstrobjProperties_swigregister
AstrobjProperties_swigregister(AstrobjProperties)

class ThinDisk(Astrobj, Functor__Double_constDoubleArray):
    """


    Geometrically thin disks and rings.

    ThinDisk::setParameter() also takes care of calling
    Generic::setParameter().

    C++ includes: GyotoThinDisk.h 
    """

    __swig_setmethods__ = {}
    for _s in [Astrobj, Functor__Double_constDoubleArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ThinDisk, name, value)
    __swig_getmethods__ = {}
    for _s in [Astrobj, Functor__Double_constDoubleArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ThinDisk, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(ThinDisk self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _core.ThinDisk_getProperties(self)


    def plugins(self, *args):
        """
        plugins(ThinDisk self, vector_string plugname)
        plugins(ThinDisk self) -> vector_string
        """
        return _core.ThinDisk_plugins(self, *args)


    def clone(self):
        """
        clone(ThinDisk self) -> ThinDisk



        Cloner.

        This method must be implemented by the various Astrobj::Generic
        subclasses in order to support cloning:

        Cloning is necessary for multi-threading, recommended for interaction
        with the Yorick plug-in etc.

        Implementing it is very straightforward, as long as the copy
        constructor Generic(const Generic& ) has been implemented: 
        """
        return _core.ThinDisk_clone(self)

    __swig_destroy__ = _core.delete_ThinDisk
    __del__ = lambda self: None

    def innerRadius(self, *args):
        """
        innerRadius(ThinDisk self) -> double
        innerRadius(ThinDisk self, std::string const & arg2) -> double
        innerRadius(ThinDisk self, double arg2)
        innerRadius(ThinDisk self, double arg2, std::string const & arg3)



        Set rin_. 
        """
        return _core.ThinDisk_innerRadius(self, *args)


    def outerRadius(self, *args):
        """
        outerRadius(ThinDisk self) -> double
        outerRadius(ThinDisk self, std::string const & arg2) -> double
        outerRadius(ThinDisk self, double arg2)
        outerRadius(ThinDisk self, double arg2, std::string const & arg3)



        Set rout_. 
        """
        return _core.ThinDisk_outerRadius(self, *args)


    def thickness(self, *args):
        """
        thickness(ThinDisk self) -> double
        thickness(ThinDisk self, std::string const & arg2) -> double
        thickness(ThinDisk self, double arg2)
        thickness(ThinDisk self, double arg2, std::string const & arg3)



        Set thickness_. 
        """
        return _core.ThinDisk_thickness(self, *args)


    def dir(self, *args):
        """
        dir(ThinDisk self) -> int
        dir(ThinDisk self, int arg2)



        Set dir_. 
        """
        return _core.ThinDisk_dir(self, *args)


    def corotating(self, *args):
        """
        corotating(ThinDisk self) -> bool
        corotating(ThinDisk self, bool t)



        Get dir_==1. 
        """
        return _core.ThinDisk_corotating(self, *args)


    def velocityKind(self, *args):
        """
        velocityKind(ThinDisk self) -> std::string
        velocityKind(ThinDisk self, std::string const & arg2)



        Set VelocityKind. 
        """
        return _core.ThinDisk_velocityKind(self, *args)


    def __call__(self, coord):
        """__call__(ThinDisk self, double const [] coord) -> double"""
        return _core.ThinDisk___call__(self, coord)


    def projectedRadius(self, coord):
        """
        projectedRadius(ThinDisk self, double const [] coord) -> double



        Projected radius of position coord on the equatorial plane. 
        """
        return _core.ThinDisk_projectedRadius(self, coord)


    def sphericalPhi(self, coord):
        """
        sphericalPhi(ThinDisk self, double const [] coord) -> double



        Longitude. 
        """
        return _core.ThinDisk_sphericalPhi(self, coord)


    def getVelocity(self, pos, vel):
        """
        getVelocity(ThinDisk self, double const [4] pos, double [4] vel)



        Get fluid 4-velocity at point.

        Fill vel with the 4-vector velocity of the fluid at 4-position pos.
        getVelocity() should work at some distance from the equatorial plane.
        The default implementation calls Metric::Generic::circularVelocity().

        Parameters:
        -----------

        pos:  4-position at which to compute velocity;

        vel:  4-velocity at pos. 
        """
        return _core.ThinDisk_getVelocity(self, pos, vel)


    def Impact(self, ph, index, data=None):
        """
        Impact(ThinDisk self, Photon ph, size_t index, AstrobjProperties data=None) -> int
        Impact(ThinDisk self, Photon ph, size_t index) -> int



        Does a photon at these coordinates impact the object?

        Impact() checks whether a Photon impacts the object between two
        integration steps of the photon's trajectory (those two steps are
        photon->getCoord(index, coord1) and photon->getCoord(index+1,
        coord2)). Impact returns 1 if the photon impacts the object between
        these two steps, else 0. In many cases of geometrically thick obects,
        the implementation Astrobj::Standard::Impact() will be fine.

        Impact will call Generic::processHitQuantities() (which is virtual and
        may be re-implemented) to compute observable properties on demand: if
        the data pointer is non-NULL, the object will look in it for pointers
        to properties which apply to its kind. If a pointer to a property
        known to this object is present, then the property is computed and
        store at the pointed-to address. For instance, all objects know the
        "intensity" property. If data->intensity != NULL, the instensity is
        computed and stored in *data->intensity.

        If data is non-NULL and only in this case, processHitQuantities() will
        also call ph->transmit() to update the transmissions of the Photon
        (see Photon::transmit(size_t, double)). This must not be done if data
        is NULL (see Astrobj::Complex::Impact() for an explanation).

        Impact() may not extend the ph Worldline. The only two dates that are
        guaranteed to be defined are at indices index and index+1.

        Parameters:
        -----------

        ph:   Gyoto::Photon aimed at the object;

        index:  Index of the last photon step;

        data:  Pointer to a structure to hold the observables at impact.

        1 if impact, 0 if not. 
        """
        return _core.ThinDisk_Impact(self, ph, index, data)


    def __init__(self, *args):
        """
        __init__(Gyoto::Astrobj::ThinDisk self, std::string kind) -> ThinDisk
        __init__(Gyoto::Astrobj::ThinDisk self) -> ThinDisk
        __init__(Gyoto::Astrobj::ThinDisk self, ThinDisk orig) -> ThinDisk
        __init__(Gyoto::Astrobj::ThinDisk self, Astrobj base) -> ThinDisk
        __init__(Gyoto::Astrobj::ThinDisk self, long address) -> ThinDisk



        Copy constructor. 
        """
        this = _core.new_ThinDisk(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
ThinDisk_swigregister = _core.ThinDisk_swigregister
ThinDisk_swigregister(ThinDisk)
ThinDisk.properties = _core.cvar.ThinDisk_properties
ThinDisk.builtinPluginValue = _core.cvar.ThinDisk_builtinPluginValue

class StandardAstrobj(Astrobj, Functor__Double_constDoubleArray):
    """


    Astronomical objects defined bya a potential/distance.

    Many geometrically thick objects can be defined by the value of a
    function of the 4 coordinates, and their emission can often be defined
    in terms of an emission law and of a transmission law.

    This is a base class for this standard case which simplifies a lot
    writting new Astrobjs.

    It is either to implement a sub-class of Astrobj::Standard than a sub-
    class of Astrobj::Generic. In particular, there is no need to
    implement the Generic::Impact() function. Instead, one needs to
    implement a few much simpler functions and most of the complex ray-
    tracing algorithms and heuristics is implemented in
    Standard::Impact(). It is recommended to read first the introduction
    in the Gyoto::Astrobj namespace documentation.

    The geometrical shape of a Gyoto::Astrobj::Standard object is yielded
    by a function of the 4 position vector. This function is implemented
    as operator()(). The velocity field of the fluid is implemented in the
    getVelocity() method. The emission(), integrateEmission() and
    transmission() methods implement the radiative transfer primitives for
    this object. Finally, you may choose to reimplement
    processHitQuantities() and Impact(), but this should not be necessary
    (that is the all point of the Standard class).

    Like any other Astrobj::Generic sub-classes, an Astrobj::Standard
    subclass should register an Astrobj::Subcontractor_t function using
    the Astrobj::Register() function. See also Writing plug-ins for Gyoto
    .

    C++ includes: GyotoStandardAstrobj.h 
    """

    __swig_setmethods__ = {}
    for _s in [Astrobj, Functor__Double_constDoubleArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StandardAstrobj, name, value)
    __swig_getmethods__ = {}
    for _s in [Astrobj, Functor__Double_constDoubleArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StandardAstrobj, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(StandardAstrobj self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _core.StandardAstrobj_getProperties(self)


    def plugins(self, *args):
        """
        plugins(StandardAstrobj self, vector_string plugname)
        plugins(StandardAstrobj self) -> vector_string
        """
        return _core.StandardAstrobj_plugins(self, *args)

    __swig_destroy__ = _core.delete_StandardAstrobj
    __del__ = lambda self: None

    def safetyValue(self, *args):
        """
        safetyValue(StandardAstrobj self, double val)
        safetyValue(StandardAstrobj self) -> double



        Get Standard::safety_value_. 
        """
        return _core.StandardAstrobj_safetyValue(self, *args)


    def deltaInObj(self, *args):
        """
        deltaInObj(StandardAstrobj self) -> double
        deltaInObj(StandardAstrobj self, double val)



        Set Generic::delta_inobj_. 
        """
        return _core.StandardAstrobj_deltaInObj(self, *args)


    def Impact(self, ph, index, data=None):
        """
        Impact(StandardAstrobj self, Photon ph, size_t index, AstrobjProperties data=None) -> int
        Impact(StandardAstrobj self, Photon ph, size_t index) -> int



        Does a photon at these coordinates impact the object?

        Impact() checks whether a Photon impacts the object between two
        integration steps of the photon's trajectory (those two steps are
        photon->getCoord(index, coord1) and photon->getCoord(index+1,
        coord2)). Impact returns 1 if the photon impacts the object between
        these two steps, else 0. In many cases of geometrically thick obects,
        the implementation Astrobj::Standard::Impact() will be fine.

        Impact will call Generic::processHitQuantities() (which is virtual and
        may be re-implemented) to compute observable properties on demand: if
        the data pointer is non-NULL, the object will look in it for pointers
        to properties which apply to its kind. If a pointer to a property
        known to this object is present, then the property is computed and
        store at the pointed-to address. For instance, all objects know the
        "intensity" property. If data->intensity != NULL, the instensity is
        computed and stored in *data->intensity.

        If data is non-NULL and only in this case, processHitQuantities() will
        also call ph->transmit() to update the transmissions of the Photon
        (see Photon::transmit(size_t, double)). This must not be done if data
        is NULL (see Astrobj::Complex::Impact() for an explanation).

        Impact() may not extend the ph Worldline. The only two dates that are
        guaranteed to be defined are at indices index and index+1.

        Parameters:
        -----------

        ph:   Gyoto::Photon aimed at the object;

        index:  Index of the last photon step;

        data:  Pointer to a structure to hold the observables at impact.

        1 if impact, 0 if not. 
        """
        return _core.StandardAstrobj_Impact(self, ph, index, data)


    def __call__(self, coord):
        """__call__(StandardAstrobj self, double const [4] coord) -> double"""
        return _core.StandardAstrobj___call__(self, coord)


    def getVelocity(self, pos, vel):
        """
        getVelocity(StandardAstrobj self, double const [4] pos, double [4] vel)



        Fluid velocity field.

        Fill vel with the 4-vector velocity of the fluid at 4-position pos.

        Parameters:
        -----------

        pos:  4-position at which to compute velocity;

        vel:  4-velocity at pos. 
        """
        return _core.StandardAstrobj_getVelocity(self, pos, vel)


    def giveDelta(self, coord):
        """
        giveDelta(StandardAstrobj self, double [8] coord) -> double



        Maximum inside object.

        Gives the requested integration stept (in coordinate time t) between
        two neighbooring points along a portion of geodesic inside an astrobj;
        the current implementation only considers a constant delta, equal to
        Standard::deltaInobj()

        Parameters:
        -----------

        coord:  input coordinate at whicht is given 
        """
        return _core.StandardAstrobj_giveDelta(self, coord)


    def __init__(self, *args):
        """
        Standard(Astrobj base) -> StandardAstrobj
        __init__(Gyoto::Astrobj::Standard self, long address) -> StandardAstrobj



        Copy constructor.

        Make a deep copy of an Astrobj::Standard instance 
        """
        this = _core.new_StandardAstrobj(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
StandardAstrobj_swigregister = _core.StandardAstrobj_swigregister
StandardAstrobj_swigregister(StandardAstrobj)
StandardAstrobj.properties = _core.cvar.StandardAstrobj_properties
StandardAstrobj.builtinPluginValue = _core.cvar.StandardAstrobj_builtinPluginValue


def getMetricRegister():
    """getMetricRegister() -> RegisterEntry"""
    return _core.getMetricRegister()

def getMetricSubcontractor(name, plugin, errmode=0):
    """
    getMetricSubcontractor(std::string name, vector_string plugin, int errmode=0) -> Gyoto::Metric::Subcontractor_t
    getMetricSubcontractor(std::string name, vector_string plugin) -> Gyoto::Metric::Subcontractor_t *



    Query the Metric register.

    Query the Metric register to get the Metric::Subcontractor_t
    correspondig to a given kind name. This function is normally called
    only from the Factory. If plugin is specified, only a subcontractor
    matching both name and plugin will be returned, loading the plug-in if
    necessary. If plugin is the empty string, then the first subcontractor
    matching name will be returned, and the name of the plug-in it belongs
    to will be returned in plugin upon output.

    Parameters:
    -----------

    name:  e.g. "KerrBL"

    plugin:  e.g. "stdplug".

    errmode:  int=0. If errmode==0, failure to find a registered Metric by
    that name is an error. Else, simply return NULL pointer in that case.

    pointer to the corresponding subcontractor. 
    """
    return _core.getMetricSubcontractor(name, plugin, errmode)

def registerMetric(kind, scp):
    """
    registerMetric(std::string kind, Gyoto::Metric::Subcontractor_t * scp)



    Make a Metric kind known to the Factory.

    Register a new Metric::Generic sub-class so that the Gyoto::Factory
    knows it.

    Parameters:
    -----------

    kind:  The kind name which identifies this object type in an XML file,
    as in < Metric kind="name">

    scp:  A pointer to the subcontractor, which will communicate with the
    Gyoto::Factory to build an instance of the class from its XML
    description 
    """
    return _core.registerMetric(kind, scp)

def initMetricRegister():
    """
    initMetricRegister()



    Empty the Metric register.

    This must be called once. It is called by Gyoto::Register::init(). 
    """
    return _core.initMetricRegister()
class Metric(SmartPointee, Object, Teller):
    """


    Base class for metrics.

    Example: class Gyoto::Metric::KerrBL

    See Gyoto::Metric for an introduction.

    C++ includes: GyotoMetric.h 
    """

    __swig_setmethods__ = {}
    for _s in [SmartPointee, Object, Teller]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Metric, name, value)
    __swig_getmethods__ = {}
    for _s in [SmartPointee, Object, Teller]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Metric, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(Metric self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _core.Metric_getProperties(self)


    def plugins(self, *args):
        """
        plugins(Metric self, vector_string plugname)
        plugins(Metric self) -> vector_string
        """
        return _core.Metric_plugins(self, *args)


    def getRefCount(self):
        """getRefCount(Metric self) -> int"""
        return _core.Metric_getRefCount(self)

    __swig_destroy__ = _core.delete_Metric
    __del__ = lambda self: None

    def clone(self):
        """
        clone(Metric self) -> Metric



        Virtual copy constructor. 
        """
        return _core.Metric_clone(self)


    def coordKind(self):
        """
        coordKind(Metric self) -> int



        Get coordinate kind. 
        """
        return _core.Metric_coordKind(self)


    def mass(self, *args):
        """
        mass(Metric self, double const arg2)
        mass(Metric self, double const arg2, std::string const & unit)
        mass(Metric self) -> double
        mass(Metric self, std::string const & unit) -> double



        Get mass used in unitLength() 
        """
        return _core.Metric_mass(self, *args)


    def unitLength(self, *args):
        """
        unitLength(Metric self) -> double
        unitLength(Metric self, std::string const & unit) -> double



        unitLength expressed in specified unit 
        """
        return _core.Metric_unitLength(self, *args)


    def getRmb(self):
        """
        getRmb(Metric self) -> double



        Returns the marginally bound radius Should be implemented in derived
        classes if useful If called on the base class, returns an error 
        """
        return _core.Metric_getRmb(self)


    def getRms(self):
        """
        getRms(Metric self) -> double



        Returns the marginally stable (ISCO) radius Should be implemented in
        derived classes if useful If called on the base class, returns an
        error 
        """
        return _core.Metric_getRms(self)


    def getSpecificAngularMomentum(self, rr):
        """
        getSpecificAngularMomentum(Metric self, double rr) -> double



        Returns the specific angular momentum l=-u_phi/u_t Should be
        implemented in derived classes if useful If called on the base class,
        returns an error 
        """
        return _core.Metric_getSpecificAngularMomentum(self, rr)


    def getPotential(self, pos, l_cst):
        """
        getPotential(Metric self, double const [4] pos, double l_cst) -> double



        Returns potential W=-ln(|u_t|) for a cst specific angular momentum
        l_cst Should be implemented in derived classes if useful If called on
        the base class, returns an error 
        """
        return _core.Metric_getPotential(self, pos, l_cst)


    def deltaMin(self, *args):
        """
        deltaMin(Metric self) -> double
        deltaMin(Metric self, double h1)



        Set delta_min_ 
        """
        return _core.Metric_deltaMin(self, *args)


    def deltaMax(self, *args):
        """
        deltaMax(Metric self) -> double
        deltaMax(Metric self, double const [8] pos, double delta_max_external) -> double
        deltaMax(Metric self, double h1)



        Set delta_max_ 
        """
        return _core.Metric_deltaMax(self, *args)


    def deltaMaxOverR(self, *args):
        """
        deltaMaxOverR(Metric self) -> double
        deltaMaxOverR(Metric self, double t)



        Set delta_max_over_r_. 
        """
        return _core.Metric_deltaMaxOverR(self, *args)


    def keplerian(self, *args):
        """
        keplerian(Metric self) -> bool
        keplerian(Metric self, bool arg2)



        Set keplerian_. 
        """
        return _core.Metric_keplerian(self, *args)


    def cartesianVelocity(self, coord, vel):
        """
        cartesianVelocity(Metric self, double const [8] coord, double [3] vel)



        Compute xprime, yprime and zprime from 8-coordinates. 
        """
        return _core.Metric_cartesianVelocity(self, coord, vel)


    def SysPrimeToTdot(self, coord, v):
        """
        SysPrimeToTdot(Metric self, double const [4] coord, double const [3] v) -> double



        Compute tdot as a function of dr/dt, dtheta/dt and dphi/dt. Everything
        is in geometrical units.

        Parameters:
        -----------

        coord:  4-position (geometrical units);

        v:  3-velocity dx1/dx0, dx2/dx0, dx3/dx0;

        tdot = dx0/dtau. 
        """
        return _core.Metric_SysPrimeToTdot(self, coord, v)


    def nullifyCoord(self, *args):
        """
        nullifyCoord(Metric self, double [8] coord)
        nullifyCoord(Metric self, double [8] coord, double & tdot2)



        Set tdot (coord[4]) such that coord is light-like and return other
        possible tdot.

        Set coord[4] so that the 4-velocity coord[4:7] is lightlike, i.e. of
        norm 0. There may be up to two solutions. coord[4] is set to the
        hightest. The lowest can be retrieved in tdot2. Everything is
        expressed in geometrical units.

        Parameters:
        -----------

        coord:  8-position, coord[4] will be set according to the other
        elements;

        tdot2:  will be set to the smallest solution 
        """
        return _core.Metric_nullifyCoord(self, *args)


    def normalizeFourVel(self, *args):
        """
        normalizeFourVel(Metric self, double [8] coord)
        normalizeFourVel(Metric self, double const [4] pos, double [4] fourvel)



        Normalize fourvelvel to -1.

        First computes threevel as xiprime=xidot/x0dot for i in {1, 2, 3},
        then computes x0dot using SyPrimeToTdot, then computes again xidot as
        xidot=xiprime*x0dot.

        Parameters:
        -----------

        pos:  4-position;

        fourvel:  4-velocity, will be renormalized. 
        """
        return _core.Metric_normalizeFourVel(self, *args)


    def ScalarProd(self, pos, u1, u2):
        """
        ScalarProd(Metric self, double const [4] pos, double const [4] u1, double const [4] u2) -> double



        Scalar product.

        Compute the scalarproduct of the two quadrivectors u1 and u2 in this
        Metric, at point pos expressed in coordinate system sys.

        Parameters:
        -----------

        pos:  4-position;

        u1:  1st quadrivector;

        u2:  2nd quadrivector;

        u1*u2 
        """
        return _core.Metric_ScalarProd(self, pos, u1, u2)


    def norm(self, pos, u1):
        """
        norm(Metric self, double const [4] pos, double const [4] u1) -> double



        Scalar product.

        Compute the norm of the quadrivector u1 in this Metric, at point pos
        expressed in coordinate system sys.

        Parameters:
        -----------

        pos:  4-position;

        u1:  quadrivector;

        ||u1|| 
        """
        return _core.Metric_norm(self, pos, u1)


    def multiplyFourVect(self, vect, a):
        """
        multiplyFourVect(Metric self, double [4] vect, double a)



        multiply vector by scalar 
        """
        return _core.Metric_multiplyFourVect(self, vect, a)


    def addFourVect(self, u1, u2):
        """
        addFourVect(Metric self, double [4] u1, double const [4] u2)



        add second vector to first one 
        """
        return _core.Metric_addFourVect(self, u1, u2)


    def projectFourVect(self, pos, u1, u2):
        """
        projectFourVect(Metric self, double const [4] pos, double [4] u1, double const [4] u2)



        project u1 orthogonally to u2 at pos 
        """
        return _core.Metric_projectFourVect(self, pos, u1, u2)


    def dualOneForm(self, IN_ARRAY1_1, IN_ARRAY1_2):
        """
        dualOneForm(Metric self, double const [4] IN_ARRAY1_1, double const [4] IN_ARRAY1_2)



        Computes dual 1-form Compute the dual 1-form of 4-vector.

        Parameters:
        -----------

        IN_ARRAY1_1:  4-position;

        IN_ARRAY1_2:  quadrivector;

        ARGOUT_ARRAY1:  output 1-form 
        """
        return _core.Metric_dualOneForm(self, IN_ARRAY1_1, IN_ARRAY1_2)


    def observerTetrad(self, *args):
        """
        observerTetrad(Metric self, unsigned int obskind, double const [4] pos, double [4] fourvel, double [4] screen1, double [4] screen2, double [4] screen3)
        observerTetrad(Metric self, double const [4] pos, double [4] fourvel, double [4] screen1, double [4] screen2, double [4] screen3)



        Computes the orthonormal local tetrad of the observer.

        Parameters:
        -----------

        pos:  position,

        fourvel:  observer 4-velocity (norm -1)

        screen1:  first vector in the screen plane

        screen2:  second vector in the screen plane

        screen3:  vector normal to the screen 
        """
        return _core.Metric_observerTetrad(self, *args)


    def GramSchmidt(self, pos, u0, u1, u2, u3):
        """
        GramSchmidt(Metric self, double const [4] pos, double [4] u0, double [4] u1, double [4] u2, double [4] u3)



        Apply Gram-Schmidt orthonormalization to a basis.

        On input, u0 to u3 must be four non-zero norm, independent 4-vectors.
        On output, they will form an orthonormal basis.

        Parameters:
        -----------

        pos:  position,

        u0:  basis vector

        u1:  basis vector

        u2:  basis vector

        u3:  basis vector 
        """
        return _core.Metric_GramSchmidt(self, pos, u0, u1, u2, u3)


    def gmunu(self, *args):
        """
        gmunu(Metric self, double const [4] x, int mu, int nu) -> double
        gmunu(Metric self, double const [4] IN_ARRAY1)



        Metric coefficients.

        The default implementation calls double gmunu(const double * x, int
        mu, int nu) const.

        Parameters:
        -----------

        ARGOUT_ARRAY2:  (g) 4x4 array to store the coeefficients

        IN_ARRAY1:  (x) 4-position at which to compute the coefficients;

        Metric coefficient g, at point x 
        """
        return _core.Metric_gmunu(self, *args)


    def gmunu_up(self, *args):
        """
        gmunu_up(Metric self, double const [4] x, int mu, int nu) -> double
        gmunu_up(Metric self, double const [4] IN_ARRAY1)



        Metric contravariant coefficients.

        The default implementation inverts the covariant coefficients matrix.

        """
        return _core.Metric_gmunu_up(self, *args)


    def jacobian(self, IN_ARRAY1):
        """
        jacobian(Metric self, double const [4] IN_ARRAY1)



        Derivatives of the metric covariant coefficients.

        The default implementation evaluates them numerically. The gmunu
        matrix is assumed to be symmetrical but no other assumptions are made
        at the moment. 
        """
        return _core.Metric_jacobian(self, IN_ARRAY1)


    def gmunu_up_and_jacobian(self, IN_ARRAY1):
        """
        gmunu_up_and_jacobian(Metric self, double const [4] IN_ARRAY1)



        gmunu_up() and jacobian() in one go 
        """
        return _core.Metric_gmunu_up_and_jacobian(self, IN_ARRAY1)


    def computeNBeta(self, coord, NN, beta):
        """
        computeNBeta(Metric self, double const [4] coord, double & NN, double [3] beta)



        Computes lapse scalar and shift vector at coord. 
        """
        return _core.Metric_computeNBeta(self, coord, NN, beta)


    def myrk4(self, line, coord, h, res):
        """
        myrk4(Metric self, Worldline line, vector_double coord, double h, vector_double res) -> int



        Obsolete, update your code. 
        """
        return _core.Metric_myrk4(self, line, coord, h, res)


    def myrk4_adaptive(self, *args):
        """
        myrk4_adaptive(Metric self, Worldline line, vector_double coord, double lastnorm, double normref, vector_double coordnew, double h0, double & h1, double deltamax) -> int
        myrk4_adaptive(Metric self, Worldline line, vector_double coord, double lastnorm, double normref, vector_double coordnew, double h0, double & h1) -> int



        Obsolete, update your code. 
        """
        return _core.Metric_myrk4_adaptive(self, *args)


    def isStopCondition(self, coord):
        """
        isStopCondition(Metric self, double const [8] coord) -> int



        Check whether integration should stop.

        The integrating loop will ask this the Metric through this method
        whether or not it is happy to continue the integration. Typically, the
        Metric should answer 0 when everything is fine, 1 when too close to
        the event horizon, inside the BH...

        Parameters:
        -----------

        coord:  8-coordinate vector to check. 
        """
        return _core.Metric_isStopCondition(self, coord)


    def diff(self, x, dxdt, mass):
        """diff(Metric self, vector_double x, vector_double dxdt, double mass) -> int"""
        return _core.Metric_diff(self, x, dxdt, mass)


    def diff31(self, x, dxdt, mass):
        """
        diff31(Metric self, vector_double x, vector_double dxdt, double mass) -> int



        F function such as dx/dt=F(x,cst) for 3+1 case. 
        """
        return _core.Metric_diff31(self, x, dxdt, mass)


    def setParticleProperties(self, line, coord):
        """
        setParticleProperties(Metric self, Worldline line, double const [8] coord)



        Set Metric-specific constants of motion. Used e.g. in KerrBL. 
        """
        return _core.Metric_setParticleProperties(self, line, coord)


    def circularVelocity(self, *args):
        """
        circularVelocity(Metric self, double const [4] pos, double [4] vel, double dir=1.)
        circularVelocity(Metric self, double const [4] pos, double [4] vel)
        circularVelocity(Metric self, double const [4] IN_ARRAY1)



        Yield circular velocity at a given position.

        Give the velocity of a massive particle in circular orbit at the given
        position projected onto the equatorial plane. Such a velocity may not
        exist everywhere (or anywhere) for a given metric. This method is
        intended to be used by Astrobj classes such as Torus or ThinDisk.

        If keplerian_ is set to true, this method should return the Keplerian
        velcity instead (derived classes should ensure this, see
        KerrBL::circularVelocity() for instance).

        The default implementation throws an error if keplerian_ is set to
        false.

        Parameters:
        -----------

        pos:  input: position,

        vel:  output: velocity,

        dir:  1 for corotating, -1 for counterrotating. 
        """
        return _core.Metric_circularVelocity(self, *args)


    def zamoVelocity(self, *args):
        """
        zamoVelocity(Metric self, double const [4] pos, double [4] vel)
        zamoVelocity(Metric self, double const [4] IN_ARRAY1)



        Yield ZAMO velocity at a given position.

        Give the velocity of a zero angular momentul observer (whatever is
        closest to "at rest"). The default implementation simply projects
        (1, 0, 0, 0) othogonally along ephi and normalizes it, thus ensuring
        that vel is orthogonal to ephi.

        Parameters:
        -----------

        pos:  input: position,

        vel:  output: velocity, 
        """
        return _core.Metric_zamoVelocity(self, *args)


    def christoffel(self, *args):
        """
        christoffel(Metric self, double const [4] coord, int const alpha, int const mu, int const nu) -> double
        christoffel(Metric self, double [4][4][4] dst, double const [4] coord) -> int
        christoffel(Metric self, double const [4] IN_ARRAY1)



        Chistoffel symbol.

        Value of Christoffel symbol at point (x1, x2, x3).

        1 on error, 0 otherwise 
        """
        return _core.Metric_christoffel(self, *args)


    def __init__(self, *args):
        """
        Generic(std::string nm) -> Metric
        Generic(std::string nm, vector_string plugin) -> Metric
        Generic(long address) -> Metric
        __init__(Gyoto::Metric::Generic self, Metric orig) -> Metric



        Copy constructor. 
        """
        this = _core.new_Metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __str__(self):
        """__str__(Metric self) -> std::string"""
        return _core.Metric___str__(self)

Metric_swigregister = _core.Metric_swigregister
Metric_swigregister(Metric)
Metric.properties = _core.cvar.Metric_properties
Metric.builtinPluginValue = _core.cvar.Metric_builtinPluginValue


def getSpectrumRegister():
    """getSpectrumRegister() -> RegisterEntry"""
    return _core.getSpectrumRegister()

def registerSpectrum(kind, scp):
    """
    registerSpectrum(std::string kind, Gyoto::Spectrum::Subcontractor_t * scp)



    Make a Spectrum kind known to the Factory.

    Register a new Spectrum::Generic sub-class so that the Gyoto::Factory
    knows it.

    Parameters:
    -----------

    kind:  The kind name which identifies this object type in an XML file,
    as in < Spectrum kind="name">

    scp:  A pointer to the subcontractor, which will communicate with the
    Gyoto::Factory to build an instance of the class from its XML
    description 
    """
    return _core.registerSpectrum(kind, scp)

def getSpectrumSubcontractor(name, plugins, errmode=0):
    """
    getSpectrumSubcontractor(std::string name, vector_string plugins, int errmode=0) -> Gyoto::Spectrum::Subcontractor_t
    getSpectrumSubcontractor(std::string name, vector_string plugins) -> Gyoto::Spectrum::Subcontractor_t *



    Query the Spectrum register.

    Query the Spectrum register to get the Metric::Subcontractor_t
    correspondig to a given kind name. This function is normally called
    only from the Factory. If plugin is specified, only a subcontractor
    matching both name and plugin will be returned, loading the plug-in if
    necessary. If plugin is the empty string, then the first subcontractor
    matching name will be returned, and the name of the plug-in it belongs
    to will be returned in plugin upon output.

    Parameters:
    -----------

    name:  e.g. "PowerLaw"

    plugin:  e.g. "stdplug".

    errmode:  int=0. If errmode==0, failure to find a registered Spectrum
    by that name is an error. Else, simply return NULL pointer in that
    case.

    pointer to the corresponding subcontractor. 
    """
    return _core.getSpectrumSubcontractor(name, plugins, errmode)

def initSpectrumRegister():
    """
    initSpectrumRegister()



    Empty the Spectrum register.

    This must be called once. It is called by Gyoto::Register::init(). 
    """
    return _core.initSpectrumRegister()
class Spectrum(SmartPointee, Object):
    """


    Spectrum emitted by an Astrobj.

    Light emitted by e.g. a Star

    C++ includes: GyotoSpectrum.h 
    """

    __swig_setmethods__ = {}
    for _s in [SmartPointee, Object]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Spectrum, name, value)
    __swig_getmethods__ = {}
    for _s in [SmartPointee, Object]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Spectrum, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(Spectrum self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _core.Spectrum_getProperties(self)


    def plugins(self, *args):
        """
        plugins(Spectrum self, vector_string plugname)
        plugins(Spectrum self) -> vector_string
        """
        return _core.Spectrum_plugins(self, *args)


    def clone(self):
        """
        clone(Spectrum self) -> Spectrum



        Cloner. 
        """
        return _core.Spectrum_clone(self)

    __swig_destroy__ = _core.delete_Spectrum
    __del__ = lambda self: None

    def __call__(self, *args):
        """
        __call__(Spectrum self, double nu) -> double
        __call__(Spectrum self, double nu, double opacity, double ds) -> double
        """
        return _core.Spectrum___call__(self, *args)


    def integrate(self, *args):
        """
        integrate(Spectrum self, double nu1, double nu2) -> double
        integrate(Spectrum self, double nu1, double nu2, Spectrum opacity, double ds) -> double



        Integrate optically thin I_nu.

        See operator()(double nu, double opacity, double ds) const

        Parameters:
        -----------

        nu1:  nu2:  boundaries for the integration

        opacity:  the frequency-dependent opacity law given as a pointer to a
        Gyoto::Spectrum::Generic sub-class instance

        ds:  the element length for spatial integration

        I, the integral of I_nu between nu1 and nu2 
        """
        return _core.Spectrum_integrate(self, *args)


    def __init__(self, *args):
        """
        Generic(std::string nm) -> Spectrum
        Generic(std::string nm, vector_string plugin) -> Spectrum
        Generic(long address) -> Spectrum
        __init__(Gyoto::Spectrum::Generic self, Spectrum orig) -> Spectrum
        """
        this = _core.new_Spectrum(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __str__(self):
        """__str__(Spectrum self) -> std::string"""
        return _core.Spectrum___str__(self)

Spectrum_swigregister = _core.Spectrum_swigregister
Spectrum_swigregister(Spectrum)
Spectrum.properties = _core.cvar.Spectrum_properties
Spectrum.builtinPluginValue = _core.cvar.Spectrum_builtinPluginValue


def getSpectrometerRegister():
    """getSpectrometerRegister() -> RegisterEntry"""
    return _core.getSpectrometerRegister()

def getSpectrometerSubcontractor(name, plugins, errmode=0):
    """
    getSpectrometerSubcontractor(std::string name, vector_string plugins, int errmode=0) -> Gyoto::Spectrometer::Subcontractor_t
    getSpectrometerSubcontractor(std::string name, vector_string plugins) -> Gyoto::Spectrometer::Subcontractor_t *



    Query the Spectrometer register.

    Get the Spectrometer::Subcontractor_t correspondig to a given kind
    name. This function is normally called only from the Gyoto::Factory.
    If plugin is specified, only a subcontractor matching both name and
    plugin will be returned, loading the plug-in if necessary. If plugin
    is the empty string, then the first subcontractor matching name will
    be returned, and the name of the plug-in it belongs to will be
    returned in plugin upon output.

    Parameters:
    -----------

    name:  Name of the subclass to build, e.g. "Complex" or "wave".

    plugin:  e.g. "stdplug".

    errmode[in]:  If name is not registered, getSubcontractor() return
    NULL errmode==1, throws a Gyoto::Error if errmode==0.

    pointer to the corresponding subcontractor. 
    """
    return _core.getSpectrometerSubcontractor(name, plugins, errmode)

def initSpectrometerRegister():
    """
    initSpectrometerRegister()



    Initialize the Spectrometer register This must be called once. It
    initializes Register_ and registers the standard kinds ( Uniform and
    Complex). 
    """
    return _core.initSpectrometerRegister()

def registerSpectrometer(name, scp):
    """
    registerSpectrometer(std::string name, Gyoto::Spectrometer::Subcontractor_t * scp)



    Register a new Spectrometer kind.

    Register a new Spectrometer::Generic sub-class so that the
    Gyoto::Factory knows it.

    Parameters:
    -----------

    name:  The kind name which identifies this object type in an XML file,
    as in < Spectrometer kind="name">. For clarity, this should be the
    same as the value of kindid_ for this object, but it is not mandatory.

    scp:  A pointer to the subcontractor, which will communicate with the
    Gyoto::Factory to build an instance of the class from its XML
    description. If all parameters can be set using setParameter(), this
    can be: 
    """
    return _core.registerSpectrometer(name, scp)
class Spectrometer(SmartPointee, Object, Teller):
    """


    Base class for spectrometers.

    Example: class Gyoto::Spectrometer::Uniform

    See Gyoto::Spectrometer for an introduction.

    Generic inherits from Gyoto::SmartPointee so that it is possible to
    create a SmartPointer to a Spectrometer.

    It also inherits from Gyoto::Hook::Teller. This allows a consistent
    implementation of Spectrometer::Complex (in particular). Any method
    which mutates a Spectrometer should call tellListeners().

    C++ includes: GyotoSpectrometer.h 
    """

    __swig_setmethods__ = {}
    for _s in [SmartPointee, Object, Teller]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Spectrometer, name, value)
    __swig_getmethods__ = {}
    for _s in [SmartPointee, Object, Teller]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Spectrometer, name)
    __repr__ = _swig_repr
    __swig_setmethods__["nsamples_"] = _core.Spectrometer_nsamples__set
    __swig_getmethods__["nsamples_"] = _core.Spectrometer_nsamples__get
    if _newclass:
        nsamples_ = _swig_property(_core.Spectrometer_nsamples__get, _core.Spectrometer_nsamples__set)
    __swig_setmethods__["nboundaries_"] = _core.Spectrometer_nboundaries__set
    __swig_getmethods__["nboundaries_"] = _core.Spectrometer_nboundaries__get
    if _newclass:
        nboundaries_ = _swig_property(_core.Spectrometer_nboundaries__get, _core.Spectrometer_nboundaries__set)
    __swig_setmethods__["boundaries_"] = _core.Spectrometer_boundaries__set
    __swig_getmethods__["boundaries_"] = _core.Spectrometer_boundaries__get
    if _newclass:
        boundaries_ = _swig_property(_core.Spectrometer_boundaries__get, _core.Spectrometer_boundaries__set)
    __swig_setmethods__["chanind_"] = _core.Spectrometer_chanind__set
    __swig_getmethods__["chanind_"] = _core.Spectrometer_chanind__get
    if _newclass:
        chanind_ = _swig_property(_core.Spectrometer_chanind__get, _core.Spectrometer_chanind__set)
    __swig_setmethods__["midpoints_"] = _core.Spectrometer_midpoints__set
    __swig_getmethods__["midpoints_"] = _core.Spectrometer_midpoints__get
    if _newclass:
        midpoints_ = _swig_property(_core.Spectrometer_midpoints__get, _core.Spectrometer_midpoints__set)
    __swig_setmethods__["widths_"] = _core.Spectrometer_widths__set
    __swig_getmethods__["widths_"] = _core.Spectrometer_widths__get
    if _newclass:
        widths_ = _swig_property(_core.Spectrometer_widths__get, _core.Spectrometer_widths__set)

    def getProperties(self):
        """
        getProperties(Spectrometer self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _core.Spectrometer_getProperties(self)


    def plugins(self, *args):
        """
        plugins(Spectrometer self, vector_string plugname)
        plugins(Spectrometer self) -> vector_string
        """
        return _core.Spectrometer_plugins(self, *args)


    def clone(self):
        """
        clone(Spectrometer self) -> Spectrometer



        Clone an instance.

        Use this to get a deep copy of an instance;

        Most implementations will use the copy constructor: 
        """
        return _core.Spectrometer_clone(self)

    __swig_destroy__ = _core.delete_Spectrometer
    __del__ = lambda self: None

    def kindid(self, *args):
        """
        kindid(Spectrometer self) -> Gyoto::Spectrometer::kind_t
        kindid(Spectrometer self, Gyoto::Spectrometer::kind_t arg2)



        Set Generic::kindid_.

        This should rarely be used as the Generic::kindid_ attribute usually
        is set in the constructor and doesn't change after that.

        Always set to the address of a static variable, not to a temporary.
        Usually your class should have a static member for that purpose: 
        """
        return _core.Spectrometer_kindid(self, *args)


    def nSamples(self):
        """
        nSamples(Spectrometer self) -> size_t



        Get Generic::nsamples_. 
        """
        return _core.Spectrometer_nSamples(self)


    def getNBoundaries(self):
        """
        getNBoundaries(Spectrometer self) -> size_t



        Get Generic::nboundaries_. 
        """
        return _core.Spectrometer_getNBoundaries(self)


    def getMidpoints(self, *args):
        """
        getMidpoints(Spectrometer self) -> double const
        getMidpoints(Spectrometer self, double [] data, std::string unit)



        Copy Generic::midpoints_, converting to unit.

        Parameters:
        -----------

        data:  an array of Generic::nsamples_ doubles to fill with result

        unit:  a string 
        """
        return _core.Spectrometer_getMidpoints(self, *args)


    def getChannelBoundaries(self, *args):
        """
        getChannelBoundaries(Spectrometer self, double [] data, std::string unit)
        getChannelBoundaries(Spectrometer self) -> double const *



        Get Generic::boundaries_. 
        """
        return _core.Spectrometer_getChannelBoundaries(self, *args)


    def getChannelIndices(self):
        """
        getChannelIndices(Spectrometer self) -> size_t const *



        Get Generic::chanind_. 
        """
        return _core.Spectrometer_getChannelIndices(self)


    def getWidths(self, *args):
        """
        getWidths(Spectrometer self) -> double const
        getWidths(Spectrometer self, double [] data, std::string unit)



        Copy Generic::widths_, converting to unit.

        Think carefully before using: widths are often used to convert
        spectral flux density to flux. If flux density is per Herz, you don't
        need to convert widths.

        Parameters:
        -----------

        data:  an array of Generic::nboundaries_ doubles to fill with result

        unit:  a string 
        """
        return _core.Spectrometer_getWidths(self, *args)


    def __init__(self, *args):
        """
        Generic(std::string nm) -> Spectrometer
        Generic(std::string nm, vector_string plugin) -> Spectrometer
        Generic(long address) -> Spectrometer
        __init__(Gyoto::Spectrometer::Generic self, Spectrometer orig) -> Spectrometer



        Copy constructor.

        Takes care of (deep) copying all the members known to the base class.

        """
        this = _core.new_Spectrometer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __str__(self):
        """__str__(Spectrometer self) -> std::string"""
        return _core.Spectrometer___str__(self)

Spectrometer_swigregister = _core.Spectrometer_swigregister
Spectrometer_swigregister(Spectrometer)
Spectrometer.properties = _core.cvar.Spectrometer_properties
Spectrometer.builtinPluginValue = _core.cvar.Spectrometer_builtinPluginValue

class myCplxSpectroIdxExcept(_object):
    """Proxy of C++ myCplxSpectroIdxExcept class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, myCplxSpectroIdxExcept, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, myCplxSpectroIdxExcept, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(myCplxSpectroIdxExcept self) -> myCplxSpectroIdxExcept"""
        this = _core.new_myCplxSpectroIdxExcept()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_myCplxSpectroIdxExcept
    __del__ = lambda self: None
myCplxSpectroIdxExcept_swigregister = _core.myCplxSpectroIdxExcept_swigregister
myCplxSpectroIdxExcept_swigregister(myCplxSpectroIdxExcept)

class ComplexSpectrometer(Spectrometer, Listener):
    """


    Complex spectrometer object.

    A Gyoto::Spectrometer::Generic whic contain several
    Gyoto::Spectrometer::Generic instances. It is essentially a
    SmartPointer<Spectrometer::Generic> array, which some methods arround.
    Indeed, the operator[](size_t i) method is implemented to retrieve the
    i-th element.

    In an XML description, the < Spectrometer> section is unique, its kind
    is "Complex". Each sub-spectrometer then appears as a
    <SubSpectrometer> subsection. For instance, to compute 10 channels ovr
    the K infrared band plus 10 channels in the high energy domain:

    C++ includes: GyotoComplexSpectrometer.h 
    """

    __swig_setmethods__ = {}
    for _s in [Spectrometer, Listener]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ComplexSpectrometer, name, value)
    __swig_getmethods__ = {}
    for _s in [Spectrometer, Listener]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ComplexSpectrometer, name)
    __repr__ = _swig_repr

    def isThreadSafe(self):
        """
        isThreadSafe(ComplexSpectrometer self) -> bool



        Whether this class is thread-safe.

        Return True if this object is thread-safe, i.e. if an instance and its
        clone can be used in parallel threads (in the context of
        Scenery::raytrace()). Known objects which are not thread-safe include
        Lorene metrics and everything from the Python plug-in.

        The default implementation considers that the class itself is thread
        safe and recurses into the declared properties to check whether they
        are safe too. Classes that abide to the Object/Property paradigm and
        are themselves thread-safe have nothing special to do.

        Objects that clone children in their copy constructor that are not
        declared as properties must take these children into account.

        Classes that are never thread-safe must declare it. It acn be easily
        done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
        GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. 
        """
        return _core.ComplexSpectrometer_isThreadSafe(self)


    def clone(self):
        """
        clone(ComplexSpectrometer self) -> ComplexSpectrometer



        Clone an instance.

        Use this to get a deep copy of an instance;

        Most implementations will use the copy constructor: 
        """
        return _core.ComplexSpectrometer_clone(self)

    __swig_destroy__ = _core.delete_ComplexSpectrometer
    __del__ = lambda self: None

    def append(self, element):
        """
        append(ComplexSpectrometer self, Gyoto::SmartPointer< Gyoto::Spectrometer::Generic > element)



        Add element at the end of the array.

        If the Spectrometer::Complex itself does not have a metric already
        assigned, it takes it from the new element. Else, it sets the metric
        in the new element to its own. This ensures that all elements use the
        same metric (this heuristic is not entirely fool-proof, it's safer to
        set the metric directly in the Spectrometer::Complex). 
        """
        return _core.ComplexSpectrometer_append(self, element)


    def remove(self, i):
        """
        remove(ComplexSpectrometer self, size_t i)



        Remove i-th element from the array. 
        """
        return _core.ComplexSpectrometer_remove(self, i)


    def getCardinal(self):
        """
        getCardinal(ComplexSpectrometer self) -> size_t



        Get the number of elements in the array. 
        """
        return _core.ComplexSpectrometer_getCardinal(self)


    def tell(self, msg):
        """
        tell(ComplexSpectrometer self, Teller msg)



        This is how a Teller tells.

        A teller will basically call listener->tell(this).

        Parameters:
        -----------

        msg:  Teller* the Teller who is telling... Useful if the Listener
        listens to several Tellers. 
        """
        return _core.ComplexSpectrometer_tell(self, msg)


    def fillElement(self, fmp):
        """
        fillElement(ComplexSpectrometer self, FactoryMessenger fmp)



        Fill in the XML entity.

        Loops on elements_[i]-> fillElement(); 
        """
        return _core.ComplexSpectrometer_fillElement(self, fmp)


    def setParameters(self, fmp):
        """
        setParameters(ComplexSpectrometer self, FactoryMessenger fmp)



        Main loop in the (templated) subcontractor.

        In the case of Spectrometer::Complex, the setParameter() API is not
        sufficient: setParameters() needs access to the FactoryMessenger to
        instantiate children for the SubSpectrometers. 
        """
        return _core.ComplexSpectrometer_setParameters(self, fmp)


    def __getitem__(self, i):
        """__getitem__(ComplexSpectrometer self, size_t i) -> Gyoto::SmartPointer< Gyoto::Spectrometer::Generic >"""
        return _core.ComplexSpectrometer___getitem__(self, i)


    def __setitem__(self, i, p):
        """__setitem__(ComplexSpectrometer self, int i, Spectrometer p)"""
        return _core.ComplexSpectrometer___setitem__(self, i, p)


    def __init__(self, *args):
        """
        Complex() -> ComplexSpectrometer
        Complex(ComplexSpectrometer arg2) -> ComplexSpectrometer
        Complex(Spectrometer base) -> ComplexSpectrometer
        __init__(Gyoto::Spectrometer::Complex self, long address) -> ComplexSpectrometer



        Copy constructor. 
        """
        this = _core.new_ComplexSpectrometer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
ComplexSpectrometer_swigregister = _core.ComplexSpectrometer_swigregister
ComplexSpectrometer_swigregister(ComplexSpectrometer)
ComplexSpectrometer.Kind = _core.cvar.ComplexSpectrometer_Kind

class UniformSpectrometer(Spectrometer):
    """


    Uniformly spaced spectrometers.

    Spectral channels are contiguous and uniformly spaced in either
    wavelength, frequency or log10 of either. Gyoto::Spectrometer::Uniform
    is registered four times in the factory: as kind="wave",
    "wavelog", "freq" and "freqlog". Example XML entity:

    The content of the entity yields the band pass expressed in "unit"
    or in log10(unit).

    C++ includes: GyotoUniformSpectrometer.h 
    """

    __swig_setmethods__ = {}
    for _s in [Spectrometer]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UniformSpectrometer, name, value)
    __swig_getmethods__ = {}
    for _s in [Spectrometer]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, UniformSpectrometer, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(UniformSpectrometer self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _core.UniformSpectrometer_getProperties(self)


    def plugins(self, *args):
        """
        plugins(UniformSpectrometer self, vector_string plugname)
        plugins(UniformSpectrometer self) -> vector_string
        """
        return _core.UniformSpectrometer_plugins(self, *args)


    def clone(self):
        """
        clone(UniformSpectrometer self) -> Spectrometer



        Cloner. 
        """
        return _core.UniformSpectrometer_clone(self)

    __swig_destroy__ = _core.delete_UniformSpectrometer
    __del__ = lambda self: None

    def kindid(self, *args):
        """
        kindid(UniformSpectrometer self) -> Gyoto::Spectrometer::kind_t
        kindid(UniformSpectrometer self, Gyoto::Spectrometer::kind_t arg2)
        kindid(UniformSpectrometer self, Gyoto::Spectrometer::kind_t arg2)



        Get kindid_.

        You can check whether the Spectrometer sp is of a given kind MyKind
        with something like:

        See Uniform::WaveKind, Uniform::WaveLogKind, Uniform::FreqKind,
        Uniform::FreqLogKind and Complex::Kind. 
        """
        return _core.UniformSpectrometer_kindid(self, *args)


    def kind(self, *args):
        """
        kind(UniformSpectrometer self, std::string const & name)
        kind(UniformSpectrometer self) -> std::string



        Get kind_. 
        """
        return _core.UniformSpectrometer_kind(self, *args)


    def nSamples(self, *args):
        """
        nSamples(UniformSpectrometer self) -> size_t
        nSamples(UniformSpectrometer self, size_t n)



        Get Generic::nsamples_. 
        """
        return _core.UniformSpectrometer_nSamples(self, *args)


    def band(self, *args):
        """
        band(UniformSpectrometer self, vector_double nu)
        band(UniformSpectrometer self, vector_double nu, std::string const & unit)
        band(UniformSpectrometer self) -> vector_double
        band(UniformSpectrometer self, std::string const & unit) -> vector_double
        band(UniformSpectrometer self, double [2] nu)
        band(UniformSpectrometer self, double [2] nu, std::string const & unit, std::string const & kind)
        band(UniformSpectrometer self, double [] nu, std::string const & unit)
        """
        return _core.UniformSpectrometer_band(self, *args)


    def getBand(self):
        """
        getBand(UniformSpectrometer self) -> double const *



        Get Uniform::band_. 
        """
        return _core.UniformSpectrometer_getBand(self)


    def fillProperty(self, fmp, p):
        """
        fillProperty(UniformSpectrometer self, FactoryMessenger fmp, Property p)



        Output a single Property to XML.

        The base implementation decides what to do based on the p.type. The
        format matches how setParameters() an setParameter() would interpret
        the XML descition.

        Overriding this method should be avoided, but makes sense in some
        cases (for instance Screen::fillProperty() selects a different unit
        for Distance based on its magnitude, so that stellar sizes are
        expressed in solar radii while smaller sizes can be expressed in
        meters and larger sizes in parsecs).

        Overriding implementation should fall-back on calling the
        implementation in the direct parent class: 
        """
        return _core.UniformSpectrometer_fillProperty(self, fmp, p)


    def setParameters(self, fmp):
        """
        setParameters(UniformSpectrometer self, FactoryMessenger fmp)



        Main loop for parsing Properties from XML description.

        This function queries the FactoryMessenger for elements to parse, and
        tries to matche each element to a Property to set it  accordingly. Any
        class that tries to be buildable from XML must supply a subcontractor
        (for base classes such as Metric, Astrobj, Spectrum  and Spectrometer,
        it is done as a template that must be  specialized for each class).
        This subcontractor typically looks somewhat like this: Although this
        is discouraged, it is possible to override the following functions to
        customize how XML entities are parsed:    - setParameters() if low-
        level access to the      FactoryMessenger is required;    -
        setParameter(std::string name, std::string content,
        std::string unit)      to interpret an entity that does not match a
        Property      (e.g. alternative name);    -
        setParameter(Gyoto::Property const &p, std::string const &name,
        std::string const &content, std::string const &unit)      to change
        how a Property is interpreted. 
        """
        return _core.UniformSpectrometer_setParameters(self, fmp)


    def __init__(self, *args):
        """
        Uniform() -> UniformSpectrometer
        Uniform(size_t nsamples, double band_min, double band_max, Gyoto::Spectrometer::kind_t kind) -> UniformSpectrometer
        Uniform(UniformSpectrometer arg2) -> UniformSpectrometer
        Uniform(Spectrometer base) -> UniformSpectrometer
        __init__(Gyoto::Spectrometer::Uniform self, long address) -> UniformSpectrometer



        Copy constructor. 
        """
        this = _core.new_UniformSpectrometer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
UniformSpectrometer_swigregister = _core.UniformSpectrometer_swigregister
UniformSpectrometer_swigregister(UniformSpectrometer)
UniformSpectrometer.properties = _core.cvar.UniformSpectrometer_properties
UniformSpectrometer.builtinPluginValue = _core.cvar.UniformSpectrometer_builtinPluginValue
UniformSpectrometer.WaveKind = _core.cvar.UniformSpectrometer_WaveKind
UniformSpectrometer.WaveLogKind = _core.cvar.UniformSpectrometer_WaveLogKind
UniformSpectrometer.FreqKind = _core.cvar.UniformSpectrometer_FreqKind
UniformSpectrometer.FreqLogKind = _core.cvar.UniformSpectrometer_FreqLogKind


def debug(*args):
    """
    debug(int mode)
    debug() -> int
    """
    return _core.debug(*args)

def verbose(*args):
    """
    verbose(int mode)
    verbose() -> int
    """
    return _core.verbose(*args)

def convert(x, nelem, mass_sun, distance_kpc, unit):
    """convert(double *const x, std::size_t const nelem, double const mass_sun, double const distance_kpc, std::string const unit)"""
    return _core.convert(x, nelem, mass_sun, distance_kpc, unit)

def atof(str):
    """atof(char const * str) -> double"""
    return _core.atof(str)

def help(class_name):
    """help(std::string class_name)"""
    return _core.help(class_name)

def split(src, delim):
    """split(std::string const & src, std::string const & delim) -> vector_string"""
    return _core.split(src, delim)

def bessi0(xx):
    """bessi0(double xx) -> double"""
    return _core.bessi0(xx)

def bessi1(xx):
    """bessi1(double xx) -> double"""
    return _core.bessi1(xx)

def bessk0(xx):
    """bessk0(double xx) -> double"""
    return _core.bessk0(xx)

def bessk1(xx):
    """bessk1(double xx) -> double"""
    return _core.bessk1(xx)

def bessk(nn, xx):
    """bessk(int nn, double xx) -> double"""
    return _core.bessk(nn, xx)

def hypergeom(kappaIndex, thetae):
    """hypergeom(double kappaIndex, double thetae) -> double"""
    return _core.hypergeom(kappaIndex, thetae)

def cartesianToSpherical(cpos, spos):
    """cartesianToSpherical(double const [3] cpos, double [3] spos)"""
    return _core.cartesianToSpherical(cpos, spos)

def sphericalToCartesian(spos, cpos):
    """sphericalToCartesian(double const [3] spos, double [3] cpos)"""
    return _core.sphericalToCartesian(spos, cpos)

def matrix4Invert(IN_ARRAY2):
    """matrix4Invert(double const [4][4] IN_ARRAY2)"""
    return _core.matrix4Invert(IN_ARRAY2)

def matrix4CircularInvert(IN_ARRAY2):
    """matrix4CircularInvert(double const [4][4] IN_ARRAY2)"""
    return _core.matrix4CircularInvert(IN_ARRAY2)
XERCES_INCLUDE_WCHAR_H = _core.XERCES_INCLUDE_WCHAR_H
class Factory(_object):
    """


    XML input/output.

    The Factory is responsible from building objects from their XML
    description, and from saving an XML description of existing objects.
    Since the Factory doesn't know how to build the variety of objects
    available in Gyoto and in external plug-ins, the Factory orders
    Metric, Astrobj and Spectrum objects from registered subcontractors
    (see SmartPointee::Subcontractor_t). The factory an the various
    subcontractors communicate through a FactoryMessenger.

    To read an XML file, you simply create an instance of the Factory with
    a filename, and get whichever object type you are interested in: or,
    for a single object and without checking the kind ( kind()) first:

    Writing an object to a file is even easier. Assuming "object" below
    is a Gyoto::SmartPointer<class> where "class" is one of Scenery,
    Metric::Generic, Astrobj::Generic, Spectrum::Generic, Screen, Photon
    or Spectrometer:

    or, for short:

    You can also directly display the object to stdout:

    C++ includes: GyotoFactory.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Factory, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Factory, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Gyoto::Factory self, char * filename) -> Factory
        __init__(Gyoto::Factory self, Gyoto::SmartPointer< Gyoto::Scenery > sc) -> Factory
        __init__(Gyoto::Factory self, Gyoto::SmartPointer< Gyoto::Metric::Generic > gg) -> Factory
        __init__(Gyoto::Factory self, Gyoto::SmartPointer< Gyoto::Astrobj::Generic > ao) -> Factory
        __init__(Gyoto::Factory self, Gyoto::SmartPointer< Gyoto::Spectrum::Generic > sp) -> Factory
        __init__(Gyoto::Factory self, Gyoto::SmartPointer< Gyoto::Screen > screen) -> Factory
        __init__(Gyoto::Factory self, Gyoto::SmartPointer< Gyoto::Photon > photon) -> Factory
        __init__(Gyoto::Factory self, Gyoto::SmartPointer< Gyoto::Spectrometer::Generic > Spectrometer) -> Factory



        Constructor for saving (or printing) a Spectrometer. 
        """
        this = _core.new_Factory(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_Factory
    __del__ = lambda self: None

    def kind(self):
        """
        kind(Factory self) -> std::string const



        Get Factory::kind_. 
        """
        return _core.Factory_kind(self)


    def scenery(self):
        """
        scenery(Factory self) -> Gyoto::SmartPointer< Gyoto::Scenery >



        Find Scenery element, instantiate it and get it.

        Scenery must be the root element. scenery() will call metric(),
        astrobj() and screen(). 
        """
        return _core.Factory_scenery(self)


    def photon(self):
        """
        photon(Factory self) -> Gyoto::SmartPointer< Gyoto::Photon >



        Find Photon element, instantiate it and get it.

        Photon may be either the root element or directly within the root
        element. 
        """
        return _core.Factory_photon(self)


    def spectrum(self):
        """
        spectrum(Factory self) -> Gyoto::SmartPointer< Gyoto::Spectrum::Generic >



        Find Photon element, instantiate it and get it.

        Photon may be either the root element or directly within the root
        element. 
        """
        return _core.Factory_spectrum(self)


    def spectrometer(self):
        """
        spectrometer(Factory self) -> Gyoto::SmartPointer< Gyoto::Spectrometer::Generic >



        Find Spectrometer element, instantiate it and get it.

        Spectrometer may be either the root element or directly within the
        root element. 
        """
        return _core.Factory_spectrometer(self)


    def write(self, fname=None):
        """
        write(Factory self, char const *const fname=None)
        write(Factory self)



        Write constructed XML representation to file. 
        """
        return _core.Factory_write(self, fname)


    def format(self):
        """
        format(Factory self) -> std::string



        Get constructed XML representation as std::string. 
        """
        return _core.Factory_format(self)


    def metric(self, *args):
        """
        metric(Factory self) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >
        metric(Factory self, Gyoto::SmartPointer< Gyoto::Metric::Generic > gg, xercesc::DOMElement * el)



        Set Metric for this document.

        If called several times for the same document, the metric
        SmartPointers must point to the same instance or an error will be
        thrown using Gyoto::throwError(). 
        """
        return _core.Factory_metric(self, *args)


    def astrobj(self, *args):
        """
        astrobj(Factory self) -> Gyoto::SmartPointer< Gyoto::Astrobj::Generic >
        astrobj(Factory self, Gyoto::SmartPointer< Gyoto::Astrobj::Generic > ao, xercesc::DOMElement * el)



        Set Astrobj for this document.

        If called several times for the same document, the astrobj
        SmartPointers must point to the same instance or an error will be
        thrown using Gyoto::throwError(). 
        """
        return _core.Factory_astrobj(self, *args)


    def screen(self, *args):
        """
        screen(Factory self) -> Gyoto::SmartPointer< Gyoto::Screen >
        screen(Factory self, Gyoto::SmartPointer< Gyoto::Screen > scr, xercesc::DOMElement * el)



        Set Screen for this document.

        If called several times for the same document, the screen
        SmartPointers must point to the same instance or an error will be
        thrown using Gyoto::throwError(). 
        """
        return _core.Factory_screen(self, *args)


    def setContent(self, content, el):
        """
        setContent(Factory self, std::string content, xercesc::DOMElement * el)



        Set text content of XML element. 
        """
        return _core.Factory_setContent(self, content, el)


    def setParameter(self, *args):
        """
        setParameter(Factory self, std::string name, xercesc::DOMElement * pel)
        setParameter(Factory self, std::string name, double value, xercesc::DOMElement * pel)
        setParameter(Factory self, std::string name, int value, xercesc::DOMElement * pel)
        setParameter(Factory self, std::string name, unsigned int value, xercesc::DOMElement * pel)
        setParameter(Factory self, std::string name, long value, xercesc::DOMElement * pel)
        setParameter(Factory self, std::string name, unsigned long value, xercesc::DOMElement * pel)
        setParameter(Factory self, std::string name, std::string value, xercesc::DOMElement * pel)
        setParameter(Factory self, std::string name, double [] val, size_t nelem, xercesc::DOMElement * pel, Gyoto::FactoryMessenger ** child=None)
        setParameter(Factory self, std::string name, double [] val, size_t nelem, xercesc::DOMElement * pel)
        setParameter(Factory self, std::string name, vector_double val, xercesc::DOMElement * pel, Gyoto::FactoryMessenger ** child=None)
        setParameter(Factory self, std::string name, vector_double val, xercesc::DOMElement * pel)
        setParameter(Factory self, std::string name, vector_unsigned_long val, xercesc::DOMElement * pel, Gyoto::FactoryMessenger ** child=None)
        setParameter(Factory self, std::string name, vector_unsigned_long val, xercesc::DOMElement * pel)
        """
        return _core.Factory_setParameter(self, *args)


    def fullPath(self, relpath):
        """
        fullPath(Factory self, std::string relpath) -> std::string



        Transform relative path into absolute path.

        relpath is interpreted as follows:

        If it starts with "/", it is interpreted as an absolute path and is
        returned as is.

        If it is prefixed with "`pwd`/", the rest of relpath is interpreted
        as relative to the current working directory, i.e. fullPath() tries to
        mimic how the shell would expand relpath into an absolute path.

        In any other circumstance, relpath is interpreted to relative to the
        directory where the XML file resides.

        Parameters:
        -----------

        relpath:  Path specification.

        Absolute path to same file. 
        """
        return _core.Factory_fullPath(self, relpath)


    def getScenery(self):
        """getScenery(Factory self) -> Gyoto::SmartPointer< Gyoto::Scenery >"""
        return _core.Factory_getScenery(self)


    def getPhoton(self):
        """getPhoton(Factory self) -> Gyoto::SmartPointer< Gyoto::Photon >"""
        return _core.Factory_getPhoton(self)

Factory_swigregister = _core.Factory_swigregister
Factory_swigregister(Factory)

class FactoryMessenger(_object):
    """


    Factory / SmartPointee::Subcontractor_t interface.

    A FactoryMessenger instance is like an employee passing messages
    between its employer (the Factory) and a subcontractor (a function of
    the SmartPointee::Subcontractor_t type).

    The FactoryMessenger also communicate with the fillElement method of
    some classes ( Astrobj::Generic::fillElement(),
    Metric::Generic::fillElement(), Spectrum::Generic::fillElement()).

    A subcontractor function typically loops calling getNextParameter() to
    read all the parameters provided for it in an XML file. If BASE is one
    of Astrobj, Metric or Spectrum, and MyClass is an implementation of
    BASE::Generic, the subcontractor static member function often looks
    like this:

    Other get* methods are provided to cope with more complex syntax (e.g.
    when XML attributes are used, as in <ParameterName
    attribute="attrvalue">ParameterValue</ParameterName>

    Conversely, the Factory asks certain Gyoto classes through their
    fillElement() method how they should be printed or saved to an XML
    file. Those fillElement() methods use the FactoryMessenger::set*()
    methods (in particular setParameter()) as well as, occasionally,
    makeChild() to describe themselves to the Factory.

    C++ includes: GyotoFactoryMessenger.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FactoryMessenger, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FactoryMessenger, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Gyoto::FactoryMessenger self, Factory arg2, xercesc::DOMElement * arg3) -> FactoryMessenger
        __init__(Gyoto::FactoryMessenger self, FactoryMessenger parent, std::string arg3) -> FactoryMessenger



        Constructor called before fillElement. 
        """
        this = _core.new_FactoryMessenger(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def reset(self):
        """
        reset(FactoryMessenger self)



        Get back to first parameter. 
        """
        return _core.FactoryMessenger_reset(self)


    def photon(self):
        """
        photon(FactoryMessenger self) -> Gyoto::SmartPointer< Gyoto::Photon >



        Build and get the Photon described in this XML file.

        An Gyoto XML file may contain at most a single Photon section and it
        may be present about anywhere in the XML tree. Individual
        subcontractors should not try to interpret this section directly, but
        should call photon() to find and interpret the Photon section. 
        """
        return _core.FactoryMessenger_photon(self)


    def getNextParameter(self, name, content, unit=None):
        """
        getNextParameter(FactoryMessenger self, std::string * name, std::string * content, std::string * unit=None) -> int
        getNextParameter(FactoryMessenger self, std::string * name, std::string * content) -> int



        Get name and value of next parameter.

        On each call, return a pair name-content of one of the children_.
        Usually, "name" is the name of a parameter and "content" is the
        string representation of the corresponding value. For instance:

        Parameters:
        -----------

        name:  upon output, name of the child

        content:  of the child

        unit=:  propertty of the child

        1 if there remains parameters to retrieve, 0 otherwise. 
        """
        return _core.FactoryMessenger_getNextParameter(self, name, content, unit)


    def getSelfAttribute(self, attrname):
        """
        getSelfAttribute(FactoryMessenger self, std::string attrname) -> std::string



        Get attribute of FactoryMessenger::element_.

        For instance a Spectrometer description looks like this and the
        Spectrometer builder uses getSelfAttribute() to retrieve the
        attributes "kind" and "nsamples".

        Parameters:
        -----------

        attrname:  name of the attribute

        attrvalue 
        """
        return _core.FactoryMessenger_getSelfAttribute(self, attrname)


    def getAttribute(self, attrname):
        """
        getAttribute(FactoryMessenger self, std::string attrname) -> std::string



        Get attribute of a last retrieved parameter.

        For instance

        Parameters:
        -----------

        attrname:  name of the attribute

        attrvalue 
        """
        return _core.FactoryMessenger_getAttribute(self, attrname)


    def getFullContent(self):
        """
        getFullContent(FactoryMessenger self) -> std::string



        Get full content of element_.

        In exceptional circumstances, it may be necessary to get the entire
        text content of the topmost element FactoryMessenger::element_ instead
        or getting only the individual FactoryMessenger::children_ .

        For instance a Spectrometer description looks like this: and the
        Spectrometer builder uses getFullContent() to retrieve the spectral
        boundaries (2.0e-6 and 2.4e-6 here). 
        """
        return _core.FactoryMessenger_getFullContent(self)


    def getChild(self):
        """
        getChild(FactoryMessenger self) -> FactoryMessenger



        Get another FactoryMessenger instance initialized to current child.

        If one of the FactoryMessenger::children_ is complex (for instance the
        complete description of a Gyoto::Spectrum), it is possible to
        initialize a new FactoryMessenger and call the correct subcontractor:
        The child is allocated with new and must be deleted after use. 
        """
        return _core.FactoryMessenger_getChild(self)


    def fullPath(self, relpath):
        """
        fullPath(FactoryMessenger self, std::string relpath) -> std::string



        Transform path into full path specification.

        This function takes a relative path (e.g. ../foo/bar.data) and
        transforms it into a full path (starting with "/"). It is not
        guaranteed to be portable (we assume that the path separator is "/"
        and that absolute paths start with "/").

        Parameters:
        -----------

        relpath:  path relative to the directory where the XML file on which
        the Factory works is located.

        fullpath at full path specification to the same point pon the file-
        system. 
        """
        return _core.FactoryMessenger_fullPath(self, relpath)


    def metric(self, *args):
        """
        metric(FactoryMessenger self) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >
        metric(FactoryMessenger self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)



        Set the Metric.

        At most one Metric section may be present in a give Gyoto XML file.

        When an object's fillElement() method is called, if this object is
        connected to a Metric, it should call metric() with this Metric. Very
        often, the Metric will already have been set previously. The Factory
        will check that all the objects in the hierarchy are attached to the
        same Metric instance, and save this instance only once. Trying to set
        the Metric to something else than the already set Metric instance is
        an error condition.

        To make things clearer: Assume "scenery" is a fully filled Scenery.
        scenery->fillElement(messenger) will call:

        The Factory will then call screen_->fillElement(child_messenger) and
        obj_->fillElement(child_messenger), each of which will also call
        metric(). If the same Metric is connected to the Astrobj, to the
        Screen and to the Scenery, all is well. Else, you have a bug to fix.

        """
        return _core.FactoryMessenger_metric(self, *args)


    def astrobj(self, *args):
        """
        astrobj(FactoryMessenger self) -> Gyoto::SmartPointer< Gyoto::Astrobj::Generic >
        astrobj(FactoryMessenger self, Gyoto::SmartPointer< Gyoto::Astrobj::Generic > arg2)



        Set the Astrobj.

        Same as metric(), but for the Astrobj. 
        """
        return _core.FactoryMessenger_astrobj(self, *args)


    def screen(self, *args):
        """
        screen(FactoryMessenger self) -> Gyoto::SmartPointer< Gyoto::Screen >
        screen(FactoryMessenger self, Gyoto::SmartPointer< Gyoto::Screen > arg2)



        Set the Screen.

        Same as metric(), but for the Screen. 
        """
        return _core.FactoryMessenger_screen(self, *args)


    def setParameter(self, *args):
        """
        setParameter(FactoryMessenger self, std::string name)
        setParameter(FactoryMessenger self, std::string name, double value)
        setParameter(FactoryMessenger self, std::string name, long value)
        setParameter(FactoryMessenger self, std::string name, unsigned int value)
        setParameter(FactoryMessenger self, std::string name, unsigned long value)
        setParameter(FactoryMessenger self, std::string name, int value)
        setParameter(FactoryMessenger self, std::string name, std::string value)
        setParameter(FactoryMessenger self, std::string name, double [] val, size_t n, Gyoto::FactoryMessenger ** child=None)
        setParameter(FactoryMessenger self, std::string name, double [] val, size_t n)
        setParameter(FactoryMessenger self, std::string name, vector_double val, Gyoto::FactoryMessenger ** child=None)
        setParameter(FactoryMessenger self, std::string name, vector_double val)
        setParameter(FactoryMessenger self, std::string name, vector_unsigned_long val, Gyoto::FactoryMessenger ** child=None)
        setParameter(FactoryMessenger self, std::string name, vector_unsigned_long val)



        Output a vector of parameters. 
        """
        return _core.FactoryMessenger_setParameter(self, *args)


    def setSelfAttribute(self, *args):
        """
        setSelfAttribute(FactoryMessenger self, std::string attrname, std::string value)
        setSelfAttribute(FactoryMessenger self, std::string attrname, unsigned long value)
        setSelfAttribute(FactoryMessenger self, std::string attrname, unsigned int value)
        setSelfAttribute(FactoryMessenger self, std::string attrname, double value)



        Set attribute in FactoryMessenger::element_.

        See setSelfAttribute(std::string attrname, std::string value) 
        """
        return _core.FactoryMessenger_setSelfAttribute(self, *args)


    def setFullContent(self, value):
        """
        setFullContent(FactoryMessenger self, std::string value)



        Low level, prefer setParameter()

        Exceptionnaly, a class instance may be best described by setting the
        entire content of the corresponding element than by setting a bunch of
        "parameters". This is the case of the spectrometer, which sets a
        couple of attributes and reserves the full content for the spectral
        boundaries (see Spectrometer::fillElement()). 
        """
        return _core.FactoryMessenger_setFullContent(self, value)


    def makeChild(self, name):
        """
        makeChild(FactoryMessenger self, std::string name) -> FactoryMessenger



        Create child FactoryMessenger.

        To be used from fillElement() methods. For instance, the
        Star::fillElement() method calls makeChild() to save the Star's
        Spectrum and Opacity members somewhat like this:

        The child messenger is allocated with new, you need to delete it after
        use. 
        """
        return _core.FactoryMessenger_makeChild(self, name)


    def parseArray(*args):
        """
        parseArray(std::string src, double [] dst, size_t max_tokens) -> size_t
        parseArray(std::string src) -> vector_double
        """
        return _core.FactoryMessenger_parseArray(*args)

    parseArray = staticmethod(parseArray)

    def parseArrayULong(src):
        """parseArrayULong(std::string src) -> vector_unsigned_long"""
        return _core.FactoryMessenger_parseArrayULong(src)

    parseArrayULong = staticmethod(parseArrayULong)
    __swig_destroy__ = _core.delete_FactoryMessenger
    __del__ = lambda self: None
FactoryMessenger_swigregister = _core.FactoryMessenger_swigregister
FactoryMessenger_swigregister(FactoryMessenger)

def FactoryMessenger_parseArray(*args):
    """
    parseArray(std::string src, double [] dst, size_t max_tokens) -> size_t
    FactoryMessenger_parseArray(std::string src) -> vector_double
    """
    return _core.FactoryMessenger_parseArray(*args)

def FactoryMessenger_parseArrayULong(src):
    """FactoryMessenger_parseArrayULong(std::string src) -> vector_unsigned_long"""
    return _core.FactoryMessenger_parseArrayULong(src)

class ARRAY_double_2(_object):
    """Proxy of C++ boost::array<(double,2)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ARRAY_double_2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ARRAY_double_2, name)
    __repr__ = _swig_repr

    def __getitem__(self, c):
        """__getitem__(ARRAY_double_2 self, size_t c) -> double"""
        return _core.ARRAY_double_2___getitem__(self, c)


    def __init__(self):
        """__init__(boost::array<(double,2)> self) -> ARRAY_double_2"""
        this = _core.new_ARRAY_double_2()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_ARRAY_double_2
    __del__ = lambda self: None
ARRAY_double_2_swigregister = _core.ARRAY_double_2_swigregister
ARRAY_double_2_swigregister(ARRAY_double_2)

class ARRAY_size_t_2(_object):
    """Proxy of C++ boost::array<(size_t,2)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ARRAY_size_t_2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ARRAY_size_t_2, name)
    __repr__ = _swig_repr

    def __getitem__(self, c):
        """__getitem__(ARRAY_size_t_2 self, size_t c) -> size_t"""
        return _core.ARRAY_size_t_2___getitem__(self, c)


    def __init__(self):
        """__init__(boost::array<(size_t,2)> self) -> ARRAY_size_t_2"""
        this = _core.new_ARRAY_size_t_2()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_ARRAY_size_t_2
    __del__ = lambda self: None
ARRAY_size_t_2_swigregister = _core.ARRAY_size_t_2_swigregister
ARRAY_size_t_2_swigregister(ARRAY_size_t_2)

class Coord1dSet(_object):
    """


    Set of 1-d coordinates: indices or angles.

    Acts like a container (array-like) of either size_t (pixel coordinate)
    or double (angle) values. This container can be iterated-through using
    the operator++(), derefenced using the operator*() (if containing
    pixel coordinates) or angle() (in containing angles).

    C++ includes: GyotoScreen.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Coord1dSet, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Coord1dSet, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_getmethods__["kind"] = _core.Coord1dSet_kind_get
    if _newclass:
        kind = _swig_property(_core.Coord1dSet_kind_get)

    def begin(self):
        """
        begin(Coord1dSet self)



        Reset specifier to point to the first value. 
        """
        return _core.Coord1dSet_begin(self)


    def valid(self):
        """
        valid(Coord1dSet self) -> bool



        True if pointing to something, false if end has been reached. 
        """
        return _core.Coord1dSet_valid(self)


    def size(self):
        """
        size(Coord1dSet self) -> size_t



        Number of values in this container. 
        """
        return _core.Coord1dSet_size(self)


    def __ref__(self):
        """__ref__(Coord1dSet self) -> size_t"""
        return _core.Coord1dSet___ref__(self)


    def angle(self):
        """
        angle(Coord1dSet self) -> double



        Get double value currently pointed to. 
        """
        return _core.Coord1dSet_angle(self)


    def increment(self):
        """increment(Coord1dSet self) -> Coord1dSet"""
        return _core.Coord1dSet_increment(self)


    def value(self):
        """value(Coord1dSet self) -> size_t"""
        return _core.Coord1dSet_value(self)

    __swig_destroy__ = _core.delete_Coord1dSet
    __del__ = lambda self: None
Coord1dSet_swigregister = _core.Coord1dSet_swigregister
Coord1dSet_swigregister(Coord1dSet)

class Coord2dSet(_object):
    """


    Class to specify a set of points on the Screen.

    Container (array-like) holding several 2D points. Can be a 2D grid of
    pixel coordinates or a vector of floating-point (alpha, delta) pairs,
    for instance.

    C++ includes: GyotoScreen.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Coord2dSet, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Coord2dSet, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_getmethods__["kind"] = _core.Coord2dSet_kind_get
    if _newclass:
        kind = _swig_property(_core.Coord2dSet_kind_get)

    def increment(self):
        """increment(Coord2dSet self) -> Coord2dSet"""
        return _core.Coord2dSet_increment(self)


    def __ref__(self):
        """__ref__(Coord2dSet self) -> ARRAY_size_t_2"""
        return _core.Coord2dSet___ref__(self)


    def angles(self):
        """
        angles(Coord2dSet self) -> ARRAY_double_2



        Get angle coordinates. 
        """
        return _core.Coord2dSet_angles(self)


    def begin(self):
        """
        begin(Coord2dSet self)



        Reset pointer. 
        """
        return _core.Coord2dSet_begin(self)


    def valid(self):
        """
        valid(Coord2dSet self) -> bool



        Whether the end has not been passed. 
        """
        return _core.Coord2dSet_valid(self)


    def size(self):
        """
        size(Coord2dSet self) -> size_t



        Number of positions contained. 
        """
        return _core.Coord2dSet_size(self)

    __swig_destroy__ = _core.delete_Coord2dSet
    __del__ = lambda self: None
Coord2dSet_swigregister = _core.Coord2dSet_swigregister
Coord2dSet_swigregister(Coord2dSet)

class Grid(Coord2dSet):
    """


    Class containing 2D-points organized in a grid.

    C++ includes: GyotoScreen.h 
    """

    __swig_setmethods__ = {}
    for _s in [Coord2dSet]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Grid, name, value)
    __swig_getmethods__ = {}
    for _s in [Coord2dSet]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Grid, name)
    __repr__ = _swig_repr

    def __init__(self, iset, jset, p=None):
        """
        __init__(Grid self, Coord1dSet iset, Coord1dSet jset, char const *const p=None) -> Grid
        __init__(Grid self, Coord1dSet iset, Coord1dSet jset) -> Grid
        """
        this = _core.new_Grid(iset, jset, p)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def increment(self):
        """increment(Grid self) -> Coord2dSet"""
        return _core.Grid_increment(self)


    def __ref__(self):
        """__ref__(Grid self) -> ARRAY_size_t_2"""
        return _core.Grid___ref__(self)


    def begin(self):
        """
        begin(Grid self)



        Reset pointer. 
        """
        return _core.Grid_begin(self)


    def valid(self):
        """
        valid(Grid self) -> bool



        Whether the end has not been passed. 
        """
        return _core.Grid_valid(self)


    def size(self):
        """
        size(Grid self) -> size_t



        Number of positions contained. 
        """
        return _core.Grid_size(self)

    __swig_destroy__ = _core.delete_Grid
    __del__ = lambda self: None
Grid_swigregister = _core.Grid_swigregister
Grid_swigregister(Grid)

class Bucket(Coord2dSet):
    """


    Class containing arbitrary 2D-points.

    ispec_ and jspec_ must be the same size.

    C++ includes: GyotoScreen.h 
    """

    __swig_setmethods__ = {}
    for _s in [Coord2dSet]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Bucket, name, value)
    __swig_getmethods__ = {}
    for _s in [Coord2dSet]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Bucket, name)
    __repr__ = _swig_repr

    def __init__(self, iset, jset):
        """__init__(Bucket self, Coord1dSet iset, Coord1dSet jset) -> Bucket"""
        this = _core.new_Bucket(iset, jset)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def increment(self):
        """increment(Bucket self) -> Coord2dSet"""
        return _core.Bucket_increment(self)


    def angles(self):
        """
        angles(Bucket self) -> ARRAY_double_2



        Get angle coordinates. 
        """
        return _core.Bucket_angles(self)


    def __ref__(self):
        """__ref__(Bucket self) -> ARRAY_size_t_2"""
        return _core.Bucket___ref__(self)


    def begin(self):
        """
        begin(Bucket self)



        Reset pointer. 
        """
        return _core.Bucket_begin(self)


    def valid(self):
        """
        valid(Bucket self) -> bool



        Whether the end has not been passed. 
        """
        return _core.Bucket_valid(self)


    def size(self):
        """
        size(Bucket self) -> size_t



        Number of positions contained. 
        """
        return _core.Bucket_size(self)

    __swig_destroy__ = _core.delete_Bucket
    __del__ = lambda self: None
Bucket_swigregister = _core.Bucket_swigregister
Bucket_swigregister(Bucket)

class Empty(Coord2dSet):
    """


    A dummy, empty 2D set.

    C++ includes: GyotoScreen.h 
    """

    __swig_setmethods__ = {}
    for _s in [Coord2dSet]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Empty, name, value)
    __swig_getmethods__ = {}
    for _s in [Coord2dSet]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Empty, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(Empty self) -> Empty"""
        this = _core.new_Empty()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def increment(self):
        """increment(Empty self) -> Coord2dSet"""
        return _core.Empty_increment(self)


    def begin(self):
        """
        begin(Empty self)



        Reset pointer. 
        """
        return _core.Empty_begin(self)


    def valid(self):
        """
        valid(Empty self) -> bool



        Whether the end has not been passed. 
        """
        return _core.Empty_valid(self)


    def size(self):
        """
        size(Empty self) -> size_t



        Number of positions contained. 
        """
        return _core.Empty_size(self)

    __swig_destroy__ = _core.delete_Empty
    __del__ = lambda self: None
Empty_swigregister = _core.Empty_swigregister
Empty_swigregister(Empty)

class Range(Coord1dSet):
    """


    1D coordinated specifier for a range

    C++ includes: GyotoScreen.h 
    """

    __swig_setmethods__ = {}
    for _s in [Coord1dSet]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Range, name, value)
    __swig_getmethods__ = {}
    for _s in [Coord1dSet]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Range, name)
    __repr__ = _swig_repr

    def __init__(self, mi, ma, d):
        """
        __init__(Range self, size_t mi, size_t ma, size_t d) -> Range



        Specify min, max and step of this range. 
        """
        this = _core.new_Range(mi, ma, d)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def begin(self):
        """
        begin(Range self)



        Reset specifier to point to the first value. 
        """
        return _core.Range_begin(self)


    def valid(self):
        """
        valid(Range self) -> bool



        True if pointing to something, false if end has been reached. 
        """
        return _core.Range_valid(self)


    def size(self):
        """
        size(Range self) -> size_t



        Number of values in this container. 
        """
        return _core.Range_size(self)


    def increment(self):
        """increment(Range self) -> Coord1dSet"""
        return _core.Range_increment(self)


    def __ref__(self):
        """__ref__(Range self) -> size_t"""
        return _core.Range___ref__(self)

    __swig_destroy__ = _core.delete_Range
    __del__ = lambda self: None
Range_swigregister = _core.Range_swigregister
Range_swigregister(Range)

class Indices(Coord1dSet):
    """


    1D specifier for an arbitrary pixel coordinate set.

    C++ includes: GyotoScreen.h 
    """

    __swig_setmethods__ = {}
    for _s in [Coord1dSet]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Indices, name, value)
    __swig_getmethods__ = {}
    for _s in [Coord1dSet]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Indices, name)
    __repr__ = _swig_repr

    def begin(self):
        """
        begin(Indices self)



        Reset specifier to point to the first value. 
        """
        return _core.Indices_begin(self)


    def valid(self):
        """
        valid(Indices self) -> bool



        True if pointing to something, false if end has been reached. 
        """
        return _core.Indices_valid(self)


    def size(self):
        """
        size(Indices self) -> size_t



        Number of values in this container. 
        """
        return _core.Indices_size(self)


    def increment(self):
        """increment(Indices self) -> Coord1dSet"""
        return _core.Indices_increment(self)


    def __ref__(self):
        """__ref__(Indices self) -> size_t"""
        return _core.Indices___ref__(self)


    def index(self):
        """
        index(Indices self) -> size_t



        Get index of value currently pointed to.

        Starts at 0 and is implemented each time operator++ is called.
        Depending on the implementation, this may be a real index or computed
        on demand. 
        """
        return _core.Indices_index(self)


    def __init__(self, *args):
        """
        __init__(Indices self, size_t * carray, size_t nel) -> Indices
        __init__(Indices self, size_t DIM1) -> Indices
        """
        this = _core.new_Indices(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_Indices
    __del__ = lambda self: None
Indices_swigregister = _core.Indices_swigregister
Indices_swigregister(Indices)

class Angles(Coord1dSet):
    """


    1D specifier for an arbitrary angle coordinate set.

    C++ includes: GyotoScreen.h 
    """

    __swig_setmethods__ = {}
    for _s in [Coord1dSet]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Angles, name, value)
    __swig_getmethods__ = {}
    for _s in [Coord1dSet]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Angles, name)
    __repr__ = _swig_repr

    def begin(self):
        """
        begin(Angles self)



        Reset specifier to point to the first value. 
        """
        return _core.Angles_begin(self)


    def valid(self):
        """
        valid(Angles self) -> bool



        True if pointing to something, false if end has been reached. 
        """
        return _core.Angles_valid(self)


    def size(self):
        """
        size(Angles self) -> size_t



        Number of values in this container. 
        """
        return _core.Angles_size(self)


    def increment(self):
        """increment(Angles self) -> Coord1dSet"""
        return _core.Angles_increment(self)


    def angle(self):
        """
        angle(Angles self) -> double



        Get double value currently pointed to. 
        """
        return _core.Angles_angle(self)


    def __init__(self, *args):
        """
        __init__(Angles self, double * carray, size_t nel) -> Angles
        __init__(Angles self, size_t DIM1) -> Angles
        """
        this = _core.new_Angles(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_Angles
    __del__ = lambda self: None
Angles_swigregister = _core.Angles_swigregister
Angles_swigregister(Angles)

class RepeatAngle(Coord1dSet):
    """


    1D specifier for an angle that is repeated.

    C++ includes: GyotoScreen.h 
    """

    __swig_setmethods__ = {}
    for _s in [Coord1dSet]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RepeatAngle, name, value)
    __swig_getmethods__ = {}
    for _s in [Coord1dSet]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RepeatAngle, name)
    __repr__ = _swig_repr

    def __init__(self, val, sz):
        """__init__(RepeatAngle self, double val, size_t sz) -> RepeatAngle"""
        this = _core.new_RepeatAngle(val, sz)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def begin(self):
        """
        begin(RepeatAngle self)



        Reset specifier to point to the first value. 
        """
        return _core.RepeatAngle_begin(self)


    def valid(self):
        """
        valid(RepeatAngle self) -> bool



        True if pointing to something, false if end has been reached. 
        """
        return _core.RepeatAngle_valid(self)


    def size(self):
        """
        size(RepeatAngle self) -> size_t



        Number of values in this container. 
        """
        return _core.RepeatAngle_size(self)


    def increment(self):
        """increment(RepeatAngle self) -> Coord1dSet"""
        return _core.RepeatAngle_increment(self)


    def angle(self):
        """
        angle(RepeatAngle self) -> double



        Get double value currently pointed to. 
        """
        return _core.RepeatAngle_angle(self)

    __swig_destroy__ = _core.delete_RepeatAngle
    __del__ = lambda self: None
RepeatAngle_swigregister = _core.RepeatAngle_swigregister
RepeatAngle_swigregister(RepeatAngle)

class Property(_object):
    """


    Property that can be set and got using standard methods.

    The Property API makes it easy to declare the parameters that can be
    set in a class.

    Developpers who simply write classes (deriving from Astrobj::Generic,
    , Metric::Generic, Spectrum::Generic) need not know the inners of the
    Property class and interact with it only using macros to declare the
    parameters they need to read from XML.

    To make use of the Property framework, a class must derive from
    Gyoto::Object and use the GYOTO_OBJECT in a public section of the
    class declaration (i.e. in the .h file). Then, in the corresponding .C
    file, the GYOTO_PROPERTY_* macros are used as follows (note the
    absence of punctuation after the macros):

    In the above, GYOTO_PROPERTY_START starts the definition of the static
    member MyClass::properties. Each GYOTO_PROPERTY_<type> macro declares
    a new property. GYOTO_PROPERTY_END ends the definition of the property
    list, with an optional pointer to the parent's class Property list,
    and defines the MyClass::getProperties() method.

    The underlying accessors must always be defined, both to set and to
    get the property. For the sake of simplicity, only a limited number of
    data types are allowed: double: see GYOTO_PROPERTY_DOUBLE,
    GYOTO_PROPERTY_DOUBLE_UNIT;

    long: see GYOTO_PROPERTY_LONG;

    unsigned long: see GYOTO_PROPERTY_UNSIGNED_LONG (a.k.a. size_t: see
    GYOTO_PROPERTY_SIZE_T, this may break on architectures where size_t is
    not the same as unsigned long);

    bool: see GYOTO_PROPERTY_BOOL;

    std::vector<double>: see GYOTO_PROPERTY_VECTOR_DOUBLE and
    GYOTO_PROPERTY_VECTOR_DOUBLE_UNIT;

    std::vector<unsigned long>: see GYOTO_PROPERTY_VECTOR_UNSIGNED_LONG;

    Gyoto::SmartPointers to various base classes: Screen, Metric::Generic,
    Astrobj::Generic, Spectrum::Generic and Spectrometer::Generic. See
    GYOTO_PROPERTY_METRIC, GYOTO_PROPERTY_SCREEN, GYOTO_PROPERTY_ASTROBJ,
    GYOTO_PROPERTY_SPECTRUM and GYOTO_PROPERTY_SPECTROMETER.

    For the floating point data-types (double and vector<double>), two
    additional accessors supporting units can be provided. The accessors
    must have the same name and have specific prototypes, see the various
    function pointer typedefs, e.g. set_double_t and get_double_t.

    The type used in these accessors may not be the same as the type of
    the underlying class member. For instance, to read an array, it was
    chosen to use the std::vector<type> type because it is easy to read
    such a vector from XML and to thus determine dynamically the number of
    elements provided. But this type is slow, so it is expected that the
    class member will rather be a C-style array (double arr[]) or
    something else entirely. It is not forbidden to have a set of high-
    level accessors for the Property interface on top of lower-level, more
    efficient accessors to be used in compiled, static code:

    In this example, assuming MyClass is based directly on Object and
    member_ is the only parameter to read from XML, the Property list may
    be defined as:

    Again, nothing more is required to read and write ArrayMember from XML
    and from Yorick.

    C++ includes: GyotoProperty.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Property, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Property, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    double_t = _core.Property_double_t
    long_t = _core.Property_long_t
    unsigned_long_t = _core.Property_unsigned_long_t
    size_t_t = _core.Property_size_t_t
    bool_t = _core.Property_bool_t
    string_t = _core.Property_string_t
    filename_t = _core.Property_filename_t
    vector_double_t = _core.Property_vector_double_t
    vector_unsigned_long_t = _core.Property_vector_unsigned_long_t
    metric_t = _core.Property_metric_t
    screen_t = _core.Property_screen_t
    astrobj_t = _core.Property_astrobj_t
    spectrum_t = _core.Property_spectrum_t
    spectrometer_t = _core.Property_spectrometer_t
    empty_t = _core.Property_empty_t
    __swig_setmethods__["name"] = _core.Property_name_set
    __swig_getmethods__["name"] = _core.Property_name_get
    if _newclass:
        name = _swig_property(_core.Property_name_get, _core.Property_name_set)
    __swig_setmethods__["name_false"] = _core.Property_name_false_set
    __swig_getmethods__["name_false"] = _core.Property_name_false_get
    if _newclass:
        name_false = _swig_property(_core.Property_name_false_get, _core.Property_name_false_set)
    __swig_setmethods__["type"] = _core.Property_type_set
    __swig_getmethods__["type"] = _core.Property_type_get
    if _newclass:
        type = _swig_property(_core.Property_type_get, _core.Property_type_set)
    __swig_setmethods__["setter"] = _core.Property_setter_set
    __swig_getmethods__["setter"] = _core.Property_setter_get
    if _newclass:
        setter = _swig_property(_core.Property_setter_get, _core.Property_setter_set)
    __swig_setmethods__["getter"] = _core.Property_getter_set
    __swig_getmethods__["getter"] = _core.Property_getter_get
    if _newclass:
        getter = _swig_property(_core.Property_getter_get, _core.Property_getter_set)
    __swig_setmethods__["setter_unit"] = _core.Property_setter_unit_set
    __swig_getmethods__["setter_unit"] = _core.Property_setter_unit_get
    if _newclass:
        setter_unit = _swig_property(_core.Property_setter_unit_get, _core.Property_setter_unit_set)
    __swig_setmethods__["getter_unit"] = _core.Property_getter_unit_set
    __swig_getmethods__["getter_unit"] = _core.Property_getter_unit_get
    if _newclass:
        getter_unit = _swig_property(_core.Property_getter_unit_get, _core.Property_getter_unit_set)
    __swig_setmethods__["doc"] = _core.Property_doc_set
    __swig_getmethods__["doc"] = _core.Property_doc_get
    if _newclass:
        doc = _swig_property(_core.Property_doc_get, _core.Property_doc_set)

    def __nonzero__(self):
        return _core.Property___nonzero__(self)
    __bool__ = __nonzero__


    __swig_getmethods__["parent"] = _core.Property_parent_get
    if _newclass:
        parent = _swig_property(_core.Property_parent_get)

    def typeFromString(stype):
        """typeFromString(std::string stype) -> Gyoto::Property::type_e"""
        return _core.Property_typeFromString(stype)

    typeFromString = staticmethod(typeFromString)
    __swig_destroy__ = _core.delete_Property
    __del__ = lambda self: None
Property_swigregister = _core.Property_swigregister
Property_swigregister(Property)

def Property_typeFromString(stype):
    """Property_typeFromString(std::string stype) -> Gyoto::Property::type_e"""
    return _core.Property_typeFromString(stype)


def getSystem():
    """getSystem() -> ut_system *"""
    return _core.getSystem()

def Init():
    """
    Init()



    Load and initialize all (non-context-sensitive) units.

    If udunits is used (preprocessor macro HAVE_UDUNITS), Init()
    initializes the ut_system used throughout Gyoto and maps a few
    additional units to the unit system. 
    """
    return _core.Init()

def ToMeters(value, unit, gg=0):
    """
    ToMeters(double value, std::string const & unit, Gyoto::SmartPointer< Gyoto::Metric::Generic > const & gg=0) -> double
    ToMeters(double value, std::string const & unit) -> double



    Convert from arbitrary length unit to meters.

    Convert value from unit represented by "unit" to meters.

    If gg is provided (and not NULL), use it to interpret the string
    "geometrical" as representing gg->
    Gyoto::Metric::Generic::unitLength().

    ToMeters() will also convert time, frequency and energy units to
    meters (as in frequency -> wavelength).

    Parameters:
    -----------

    value:  (double) the value to convert, expressed according to "unit"

    unit:  (std::string) the "unit" from which to convert, e.g. "km",
    "sunradius" or "geometrical". More units are supported if Gyoto
    was compiled with udunits support.

    gg:  (const Gyoto::SmartPointer<Gyoto::Metric::Generic> &, NULL if not
    specified) optional metric to interpret "geometrical".

    value, expressed in meters. 
    """
    return _core.ToMeters(value, unit, gg)

def FromMeters(value, unit, gg=0):
    """
    FromMeters(double value, std::string const & unit, Gyoto::SmartPointer< Gyoto::Metric::Generic > const & gg=0) -> double
    FromMeters(double value, std::string const & unit) -> double



    Convert to arbitrary length unit from meters.

    Convert value to unit represented by "unit" from meters.

    If gg is provided (and not NULL), use it to interpret the string
    "geometrical" as representing gg->
    Gyoto::Metric::Generic::unitLength().

    ToMeters() will also convert to time, frequency and energy units (as
    in wavelength -> frequency).

    Parameters:
    -----------

    value:  (double) the value to convert, expressed in meters.

    unit:  (std::string) the "unit" to which to convert, e.g. "km",
    "sunradius" or "geometrical". More units are supported if Gyoto
    was compiled with udunits support.

    gg:  (const Gyoto::SmartPointer<Gyoto::Metric::Generic> &, NULL if not
    specified) optional metric to interpret "geometrical".

    value, expressed in "unit". 
    """
    return _core.FromMeters(value, unit, gg)

def ToSeconds(value, unit, gg=0):
    """
    ToSeconds(double value, std::string const & unit, Gyoto::SmartPointer< Gyoto::Metric::Generic > const & gg=0) -> double
    ToSeconds(double value, std::string const & unit) -> double



    Convert from arbitrary time unit to seconds.

    Convert value from unit represented by "unit" to seconds.

    If gg is provided (and not NULL), use it to interpret the string
    "geometrical_time" as representing gg->
    Gyoto::Metric::Generic::unitLength()/GYOTO_C.

    Parameters:
    -----------

    value:  (double) the value to convert, expressed according to "unit"

    unit:  (std::string) the "unit" from which to convert, e.g. "s",
    "yr" or "geometrical_time". More units are supported if Gyoto was
    compiled with udunits support.

    gg:  (const Gyoto::SmartPointer<Gyoto::Metric::Generic> &, NULL if not
    specified) optional metric to interpret "geometrical".

    value, expressed in seconds. 
    """
    return _core.ToSeconds(value, unit, gg)

def FromSeconds(value, unit, gg=0):
    """
    FromSeconds(double value, std::string const & unit, Gyoto::SmartPointer< Gyoto::Metric::Generic > const & gg=0) -> double
    FromSeconds(double value, std::string const & unit) -> double



    Convert to arbitrary time unit from seconds.

    Convert value to unit represented by "unit" from seconds.

    If gg is provided (and not NULL), use it to interpret the string
    "geometrical_time" as representing gg->
    Gyoto::Metric::Generic::unitLength()/GYOTO_C.

    Parameters:
    -----------

    value:  (double) the value to convert, expressed in seconds.

    unit:  (std::string) the "unit" to which to convert, e.g. "s",
    "yr" or "geometrical_time". More units are supported if Gyoto was
    compiled with udunits support.

    gg:  (const Gyoto::SmartPointer<Gyoto::Metric::Generic> &, NULL if not
    specified) optional metric to interpret "geometrical".

    value, expressed in "unit". 
    """
    return _core.FromSeconds(value, unit, gg)

def ToKilograms(value, unit):
    """
    ToKilograms(double value, std::string const & unit) -> double



    Convert from arbitrary mass unit to kilograms.

    Convert value from unit represented by "unit" to kilograms.

    Parameters:
    -----------

    value:  (double) the value to convert, expressed according to "unit"

    unit:  (std::string) the "unit" from which to convert, e.g. "g",
    "kg" or "sunmass". More units are supported if Gyoto was compiled
    with udunits support.

    value, expressed in kilograms. 
    """
    return _core.ToKilograms(value, unit)

def FromKilograms(value, unit):
    """
    FromKilograms(double value, std::string const & unit) -> double



    Convert to arbitrary mass unit from kilograms.

    Convert value from unit represented by "unit" from kilograms.

    Parameters:
    -----------

    value:  (double) the value to convert, expressed inkilograms.

    unit:  (std::string) the "unit" to which to convert, e.g. "g",
    "kg" or "sunmass". More units are supported if Gyoto was compiled
    with udunits support.

    value, expressed in "unit". 
    """
    return _core.FromKilograms(value, unit)

def ToGeometrical(value, unit, gg):
    """
    ToGeometrical(double value, std::string const & unit, Gyoto::SmartPointer< Gyoto::Metric::Generic > const & gg) -> double



    Convert from arbitrary length unit to geometrical units.

    Convert value from unit represented by "unit" to geometrical units.

    Parameters:
    -----------

    value:  (double) the value to convert, expressed according to
    "unit".

    unit:  (std::string) the "unit" from which to convert, e.g. "km",
    "sunradius" or "geometrical". More units are supported if Gyoto
    was compiled with udunits support.

    gg:  (const Gyoto::SmartPointer<Gyoto::Metric::Generic> &) metric to
    interpret "geometrical".

    value, expressed in geometrical units. 
    """
    return _core.ToGeometrical(value, unit, gg)

def FromGeometrical(value, unit, gg):
    """
    FromGeometrical(double value, std::string const & unit, Gyoto::SmartPointer< Gyoto::Metric::Generic > const & gg) -> double



    Convert to arbitrary length unit from geometrical units.

    Convert value to unit represented by "unit" from geometrical units.

    Parameters:
    -----------

    value:  (double) the value to convert, expressed in geometrical units.

    unit:  (std::string) the "unit" to which to convert, e.g. "km",
    "sunradius" or "geometrical". More units are supported if Gyoto
    was compiled with udunits support.

    gg:  (const Gyoto::SmartPointer<Gyoto::Metric::Generic> &) metric to
    interpret "geometrical".

    value, expressed in "unit". 
    """
    return _core.FromGeometrical(value, unit, gg)

def ToGeometricalTime(value, unit, gg):
    """
    ToGeometricalTime(double value, std::string const & unit, Gyoto::SmartPointer< Gyoto::Metric::Generic > const & gg) -> double



    Convert from arbitrary time unit to geometrical units.

    Parameters:
    -----------

    value:  (double) the value to convert, expressed according to
    "unit".

    unit:  (std::string) the "unit" from which to convert, e.g. "s",
    "kyr" or "geometrical_time". More units are supported if Gyoto was
    compiled with udunits support.

    gg:  (const Gyoto::SmartPointer<Gyoto::Metric::Generic> &) metric to
    interpret "geometrical_time".

    value, expressed in geometrical (time) units. 
    """
    return _core.ToGeometricalTime(value, unit, gg)

def FromGeometricalTime(value, unit, gg):
    """
    FromGeometricalTime(double value, std::string const & unit, Gyoto::SmartPointer< Gyoto::Metric::Generic > const & gg) -> double



    Convert to arbitrary time unit from geometrical units.

    Parameters:
    -----------

    value:  (double) the value to convert, expressed in geometrical units.

    unit:  (std::string) the "unit" to which to convert, e.g. "yr",
    "s" or "geometrical_time". More units are supported if Gyoto was
    compiled with udunits support.

    gg:  (const Gyoto::SmartPointer<Gyoto::Metric::Generic> &) metric to
    interpret "geometrical_time".

    value, expressed in "unit". 
    """
    return _core.FromGeometricalTime(value, unit, gg)

def ToHerz(value, unit):
    """
    ToHerz(double value, std::string const & unit) -> double



    Convert from arbitrary frequency unit to Herz.

    ToHerz will also convert from length and energy units (such as
    "eV").

    Parameters:
    -----------

    value:  (double) the value to convert, expressed according to
    "unit".

    unit:  (std::string) the "unit" from which to convert, e.g. "MHz",
    "keV"

    value, expressed in "Hz". 
    """
    return _core.ToHerz(value, unit)

def FromHerz(value, unit):
    """
    FromHerz(double value, std::string const & unit) -> double



    Convert to arbitrary frequency unit from Herz.

    FromHerz will also convert to length and energy units (such as
    "eV").

    Parameters:
    -----------

    value:  (double) the value to convert, expressed according in "Hz".

    unit:  (std::string) the "unit" from which to convert, e.g. "MHz",
    "keV"

    value, expressed in "units". 
    """
    return _core.FromHerz(value, unit)

def areConvertible(unit1, unit2):
    """areConvertible(Unit unit1, Unit unit2) -> bool"""
    return _core.areConvertible(unit1, unit2)
class Unit(SmartPointee):
    """Proxy of C++ Gyoto::Units::Unit class."""

    __swig_setmethods__ = {}
    for _s in [SmartPointee]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Unit, name, value)
    __swig_getmethods__ = {}
    for _s in [SmartPointee]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Unit, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Gyoto::Units::Unit self, std::string const & unit) -> Unit
        __init__(Gyoto::Units::Unit self, char const *const unit) -> Unit
        """
        this = _core.new_Unit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_Unit
    __del__ = lambda self: None

    def To(self, val, from_unit):
        """To(Unit self, double val, Unit from_unit) -> double"""
        return _core.Unit_To(self, val, from_unit)


    def From(self, val, to_unit):
        """From(Unit self, double val, Unit to_unit) -> double"""
        return _core.Unit_From(self, val, to_unit)


    def __str__(self):
        """__str__(Unit self) -> std::string"""
        return _core.Unit___str__(self)

Unit_swigregister = _core.Unit_swigregister
Unit_swigregister(Unit)

class Converter(SmartPointee):
    """Proxy of C++ Gyoto::Units::Converter class."""

    __swig_setmethods__ = {}
    for _s in [SmartPointee]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Converter, name, value)
    __swig_getmethods__ = {}
    for _s in [SmartPointee]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Converter, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Gyoto::Units::Converter self) -> Converter
        __init__(Gyoto::Units::Converter self, Unit arg2, Unit to) -> Converter
        """
        this = _core.new_Converter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_Converter
    __del__ = lambda self: None

    def reset(self, *args):
        """
        reset(Converter self)
        reset(Converter self, Unit arg2, Unit to)
        """
        return _core.Converter_reset(self, *args)


    def __call__(self, value):
        """__call__(Converter self, double value) -> double"""
        return _core.Converter___call__(self, value)

Converter_swigregister = _core.Converter_swigregister
Converter_swigregister(Converter)

class GridData2D(_object):
    """


    Class for reading data stored in a 2D grid.

    C++ includes: GyotoFitsRW.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GridData2D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GridData2D, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Gyoto::GridData2D self) -> GridData2D
        __init__(Gyoto::GridData2D self, GridData2D arg2) -> GridData2D



        Copy constructor. 
        """
        this = _core.new_GridData2D(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def clone(self):
        """clone(GridData2D self) -> GridData2D"""
        return _core.GridData2D_clone(self)

    __swig_destroy__ = _core.delete_GridData2D
    __del__ = lambda self: None

    def rmin(self, *args):
        """
        rmin(GridData2D self, double rmn)
        rmin(GridData2D self) -> double
        """
        return _core.GridData2D_rmin(self, *args)


    def rmax(self, *args):
        """
        rmax(GridData2D self, double rmx)
        rmax(GridData2D self) -> double
        """
        return _core.GridData2D_rmax(self, *args)


    def nr(self, *args):
        """
        nr(GridData2D self, size_t nn)
        nr(GridData2D self) -> size_t
        """
        return _core.GridData2D_nr(self, *args)


    def dr(self, *args):
        """
        dr(GridData2D self, double dd)
        dr(GridData2D self) -> double
        """
        return _core.GridData2D_dr(self, *args)


    def phimin(self, *args):
        """
        phimin(GridData2D self, double phimn)
        phimin(GridData2D self) -> double
        """
        return _core.GridData2D_phimin(self, *args)


    def phimax(self, *args):
        """
        phimax(GridData2D self, double phimx)
        phimax(GridData2D self) -> double
        """
        return _core.GridData2D_phimax(self, *args)


    def dphi(self, *args):
        """
        dphi(GridData2D self, double dd)
        dphi(GridData2D self) -> double
        """
        return _core.GridData2D_dphi(self, *args)


    def tmin(self, *args):
        """
        tmin(GridData2D self, double tmn)
        tmin(GridData2D self) -> double
        """
        return _core.GridData2D_tmin(self, *args)


    def tmax(self, *args):
        """
        tmax(GridData2D self, double tmx)
        tmax(GridData2D self) -> double
        """
        return _core.GridData2D_tmax(self, *args)


    def nt(self, *args):
        """
        nt(GridData2D self, size_t nn)
        nt(GridData2D self) -> size_t
        """
        return _core.GridData2D_nt(self, *args)


    def nphi(self, *args):
        """
        nphi(GridData2D self, size_t nn)
        nphi(GridData2D self) -> size_t
        """
        return _core.GridData2D_nphi(self, *args)


    def fitsReadHDU(self, fptr, extname, dest, length=0):
        """
        fitsReadHDU(GridData2D self, fitsfile * fptr, std::string extname, double *& dest, size_t length=0) -> std::vector< size_t,std::allocator< size_t > >
        fitsReadHDU(GridData2D self, fitsfile * fptr, std::string extname, double *& dest) -> std::vector< size_t,std::allocator< size_t > >
        """
        return _core.GridData2D_fitsReadHDU(self, fptr, extname, dest, length)


    def fitsCreate(self, filename):
        """fitsCreate(GridData2D self, std::string filename) -> fitsfile *"""
        return _core.GridData2D_fitsCreate(self, filename)


    def fitsClose(self, fptr):
        """fitsClose(GridData2D self, fitsfile * fptr)"""
        return _core.GridData2D_fitsClose(self, fptr)


    def fitsWriteHDU(self, fptr, extname, src, length=0):
        """
        fitsWriteHDU(GridData2D self, fitsfile * fptr, std::string extname, double * src, size_t length=0)
        fitsWriteHDU(GridData2D self, fitsfile * fptr, std::string extname, double * src)
        """
        return _core.GridData2D_fitsWriteHDU(self, fptr, extname, src, length)


    def getIndices(self, i, tt, phi, rr, time_array=None):
        """
        getIndices(GridData2D self, size_t [3] i, double const tt, double const phi, double const rr, double *const time_array=None)
        getIndices(GridData2D self, size_t [3] i, double const tt, double const phi, double const rr)
        """
        return _core.GridData2D_getIndices(self, i, tt, phi, rr, time_array)


    def interpolate(self, tt, phi, rr, array, time_array=None):
        """
        interpolate(GridData2D self, double tt, double phi, double rr, double *const array, double *const time_array=None) -> double
        interpolate(GridData2D self, double tt, double phi, double rr, double *const array) -> double
        """
        return _core.GridData2D_interpolate(self, tt, phi, rr, array, time_array)

GridData2D_swigregister = _core.GridData2D_swigregister
GridData2D_swigregister(GridData2D)

class FitsRW(_object):
    """Proxy of C++ Gyoto::FitsRW class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FitsRW, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FitsRW, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Gyoto::FitsRW self) -> FitsRW
        __init__(Gyoto::FitsRW self, FitsRW arg2) -> FitsRW



        Copy constructor. 
        """
        this = _core.new_FitsRW(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def clone(self):
        """clone(FitsRW self) -> FitsRW"""
        return _core.FitsRW_clone(self)

    __swig_destroy__ = _core.delete_FitsRW
    __del__ = lambda self: None

    def numin(self, *args):
        """
        numin(FitsRW self, double numn)
        numin(FitsRW self) -> double
        """
        return _core.FitsRW_numin(self, *args)


    def numax(self, *args):
        """
        numax(FitsRW self, double numx)
        numax(FitsRW self) -> double
        """
        return _core.FitsRW_numax(self, *args)


    def nnu(self, *args):
        """
        nnu(FitsRW self, size_t nn)
        nnu(FitsRW self) -> size_t
        """
        return _core.FitsRW_nnu(self, *args)


    def tmin(self, *args):
        """
        tmin(FitsRW self, double tmn)
        tmin(FitsRW self) -> double
        """
        return _core.FitsRW_tmin(self, *args)


    def tmax(self, *args):
        """
        tmax(FitsRW self, double tmx)
        tmax(FitsRW self) -> double
        """
        return _core.FitsRW_tmax(self, *args)


    def nt(self, *args):
        """
        nt(FitsRW self, size_t nn)
        nt(FitsRW self) -> size_t
        """
        return _core.FitsRW_nt(self, *args)


    def dt(self, *args):
        """
        dt(FitsRW self, double dd)
        dt(FitsRW self) -> double
        """
        return _core.FitsRW_dt(self, *args)


    def fitsCreate(self, filename):
        """fitsCreate(FitsRW self, std::string filename) -> fitsfile *"""
        return _core.FitsRW_fitsCreate(self, filename)


    def fitsClose(self, fptr):
        """fitsClose(FitsRW self, fitsfile * fptr)"""
        return _core.FitsRW_fitsClose(self, fptr)


    def fitsWriteHDU(self, fptr, extname, src):
        """fitsWriteHDU(FitsRW self, fitsfile * fptr, std::string extname, double * src)"""
        return _core.FitsRW_fitsWriteHDU(self, fptr, extname, src)


    def fitsWriteParams(self, fptr, n_e, theta, kappa, BB, t_inj):
        """fitsWriteParams(FitsRW self, fitsfile * fptr, double n_e, double theta, double kappa, double BB, double t_inj)"""
        return _core.FitsRW_fitsWriteParams(self, fptr, n_e, theta, kappa, BB, t_inj)


    def fitsReadHDU(self, fptr, extname, dest):
        """fitsReadHDU(FitsRW self, fitsfile * fptr, std::string extname, double *& dest) -> std::vector< size_t,std::allocator< size_t > >"""
        return _core.FitsRW_fitsReadHDU(self, fptr, extname, dest)


    def getIndices(self, i, nu, tt, freq_array):
        """getIndices(FitsRW self, size_t [2] i, double const nu, double const tt, double *const freq_array)"""
        return _core.FitsRW_getIndices(self, i, nu, tt, freq_array)


    def interpolate(self, nu, tt, array, freq_array):
        """interpolate(FitsRW self, double nu, double tt, double *const array, double *const freq_array) -> double"""
        return _core.FitsRW_interpolate(self, nu, tt, array, freq_array)

FitsRW_swigregister = _core.FitsRW_swigregister
FitsRW_swigregister(FitsRW)

# This file is compatible with both classic and new-style classes.


