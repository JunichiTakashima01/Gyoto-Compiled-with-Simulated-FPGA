# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""The Gyoto standard plug-in"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_std')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_std')
    _std = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_std', [dirname(__file__)])
        except ImportError:
            import _std
            return _std
        try:
            _mod = imp.load_module('_std', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _std = swig_import_helper()
    del swig_import_helper
else:
    import _std
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

import gyoto.core
class UniformSphere(gyoto.core.StandardAstrobj):
    """


    Optically thick or thin, spherical objects.

    Gyoto::Astrobj::UniformSphere is an abstract type from which uniform,
    spherical objects inherit (in particular, the Gyoto::Astrobj::Star and
    Gyoto::Astrobj::FixedStar classes).

    These objects are coordinate-spherical: they comprise all the points
    within a given radius from a centre. The distance is the usual
    Euclidian distance in a Cartesian coordinate system which is trivially
    determined by the coordinate system in which the Metric is expressed.

    The sphere is in solid motion: all the points have the same
    4-velocity. The centre of the sphere may move. This motion and the
    velocity are provided by the derived classes through the
    getCartesian() and getVelocity() methods.

    The spheres can be optically thick or optically thin. In the optically
    thin case, the opacity law provided as a Gyoto::Spectrum also sets
    both the emissivity. Another Gyoto::Spectrum provides the emission law
    of the source, which is uniform.

    Gyoto::Astrobj::UniformSphere::setParameters() take care of
    interpreting the XML elements describing the parameters of the sphere:
    setGenericParameters() also takes care of calling setParameter().

    C++ includes: GyotoUniformSphere.h 
    """

    __swig_setmethods__ = {}
    for _s in [gyoto.core.StandardAstrobj]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UniformSphere, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.StandardAstrobj]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, UniformSphere, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(UniformSphere self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.UniformSphere_getProperties(self)


    def plugins(self, *args):
        """
        plugins(UniformSphere self, vector_string plugname)
        plugins(UniformSphere self) -> vector_string
        """
        return _std.UniformSphere_plugins(self, *args)

    __swig_destroy__ = _std.delete_UniformSphere
    __del__ = lambda self: None

    def className(self):
        """
        className(UniformSphere self) -> std::string



        "UniformSphere" 
        """
        return _std.UniformSphere_className(self)


    def className_l(self):
        """
        className_l(UniformSphere self) -> std::string



        "uniformsphere" 
        """
        return _std.UniformSphere_className_l(self)


    def spectrum(self, *args):
        """
        spectrum(UniformSphere self, Gyoto::SmartPointer< Gyoto::Spectrum::Generic > arg2)
        spectrum(UniformSphere self) -> Gyoto::SmartPointer< Gyoto::Spectrum::Generic >



        Get spectrum_. 
        """
        return _std.UniformSphere_spectrum(self, *args)


    def opacity(self, *args):
        """
        opacity(UniformSphere self, Gyoto::SmartPointer< Gyoto::Spectrum::Generic > arg2)
        opacity(UniformSphere self) -> Gyoto::SmartPointer< Gyoto::Spectrum::Generic >



        Get opacity_. 
        """
        return _std.UniformSphere_opacity(self, *args)


    def radius(self, *args):
        """
        radius(UniformSphere self) -> double
        radius(UniformSphere self, double arg2)
        radius(UniformSphere self, std::string const & arg2) -> double
        radius(UniformSphere self, double arg2, std::string const & arg3)



        Set radius_ in specified unit. 
        """
        return _std.UniformSphere_radius(self, *args)


    def deltaMaxOverRadius(self, *args):
        """
        deltaMaxOverRadius(UniformSphere self) -> double
        deltaMaxOverRadius(UniformSphere self, double f)



        Set dltmor_. 
        """
        return _std.UniformSphere_deltaMaxOverRadius(self, *args)


    def deltaMaxOverDistance(self, *args):
        """
        deltaMaxOverDistance(UniformSphere self) -> double
        deltaMaxOverDistance(UniformSphere self, double f)



        Set dltmod_. 
        """
        return _std.UniformSphere_deltaMaxOverDistance(self, *args)


    def isotropic(self, *args):
        """
        isotropic(UniformSphere self) -> bool
        isotropic(UniformSphere self, bool arg2)
        """
        return _std.UniformSphere_isotropic(self, *args)


    def alpha(self, *args):
        """
        alpha(UniformSphere self) -> double
        alpha(UniformSphere self, double arg2)
        """
        return _std.UniformSphere_alpha(self, *args)


    def __call__(self, coord):
        """__call__(UniformSphere self, double const [4] coord) -> double"""
        return _std.UniformSphere___call__(self, coord)


    def deltaMax(self, coord):
        """
        deltaMax(UniformSphere self, double * coord) -> double



        Get max step constraint for adaptive integration.

        Parameters:
        -----------

        coord:  position

        max step to find this object reliably 
        """
        return _std.UniformSphere_deltaMax(self, coord)


    def __init__(self, *args):
        """
        __init__(Gyoto::Astrobj::UniformSphere self, Astrobj base) -> UniformSphere
        __init__(Gyoto::Astrobj::UniformSphere self, long address) -> UniformSphere



        Copy constructor. 
        """
        this = _std.new_UniformSphere(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
UniformSphere_swigregister = _std.UniformSphere_swigregister
UniformSphere_swigregister(UniformSphere)
cvar = _std.cvar
UniformSphere.properties = _std.cvar.UniformSphere_properties
UniformSphere.builtinPluginValue = _std.cvar.UniformSphere_builtinPluginValue

class myCplxIdxExcept(_object):
    """Proxy of C++ myCplxIdxExcept class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, myCplxIdxExcept, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, myCplxIdxExcept, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(myCplxIdxExcept self) -> myCplxIdxExcept"""
        this = _std.new_myCplxIdxExcept()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _std.delete_myCplxIdxExcept
    __del__ = lambda self: None
myCplxIdxExcept_swigregister = _std.myCplxIdxExcept_swigregister
myCplxIdxExcept_swigregister(myCplxIdxExcept)

class ComplexAstrobj(gyoto.core.Astrobj):
    """


    Complex astronomical object.

    A Gyoto::Astrobj::Generic whic contain several Gyoto::Astrobj::Generic
    instances. It is essentially a SmartPointer<Astrobj::Generic> array,
    which some methods around. Indeed, the operator[](size_t i) method is
    implemented to retrieve the i-th element.

    In an XML description, the < Astrobj> section must be unique, its kind
    is "Complex". Each sub-astrobj then appears as a <SubAstrobj>
    subsection:

    C++ includes: GyotoComplexAstrobj.h 
    """

    __swig_setmethods__ = {}
    for _s in [gyoto.core.Astrobj]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ComplexAstrobj, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.Astrobj]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ComplexAstrobj, name)
    __repr__ = _swig_repr

    def isThreadSafe(self):
        """
        isThreadSafe(ComplexAstrobj self) -> bool



        Whether this class is thread-safe.

        Return True if this object is thread-safe, i.e. if an instance and its
        clone can be used in parallel threads (in the context of
        Scenery::raytrace()). Known objects which are not thread-safe include
        Lorene metrics and everything from the Python plug-in.

        The default implementation considers that the class itself is thread
        safe and recurses into the declared properties to check whether they
        are safe too. Classes that abide to the Object/Property paradigm and
        are themselves thread-safe have nothing special to do.

        Objects that clone children in their copy constructor that are not
        declared as properties must take these children into account.

        Classes that are never thread-safe must declare it. It acn be easily
        done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
        GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. 
        """
        return _std.ComplexAstrobj_isThreadSafe(self)


    def clone(self):
        """
        clone(ComplexAstrobj self) -> ComplexAstrobj



        "Virtual" copy constructor 
        """
        return _std.ComplexAstrobj_clone(self)


    def deltaMax(self, coord):
        """
        deltaMax(ComplexAstrobj self, double [8] coord) -> double



        Get max step constraint for adaptive integration.

        Parameters:
        -----------

        coord:  position

        max step to find this object reliably 
        """
        return _std.ComplexAstrobj_deltaMax(self, coord)


    def rMax(self):
        """
        rMax(ComplexAstrobj self) -> double



        Set maximal distance from center of coordinate system.

        Call Generic::rMax(double val) after converting val from unit to
        geometrical units.

        Parameters:
        -----------

        val:   rmax_ expressed in unit "unit";

        unit:  string... 
        """
        return _std.ComplexAstrobj_rMax(self)

    __swig_destroy__ = _std.delete_ComplexAstrobj
    __del__ = lambda self: None

    def append(self, element):
        """
        append(ComplexAstrobj self, Gyoto::SmartPointer< Gyoto::Astrobj::Generic > element)



        Add element at the end of the array.

        If the Astrobj::Complex itself does not have a metric already
        assigned, it takes it from the new element. Else, it sets the metric
        in the new element to its own. This ensures that all elements use the
        same metric (this heuristic is not entirely fool-proof, it's safer to
        set the metric directly in the Astrobj::Complex). 
        """
        return _std.ComplexAstrobj_append(self, element)


    def remove(self, i):
        """
        remove(ComplexAstrobj self, size_t i)



        Remove i-th element from the array. 
        """
        return _std.ComplexAstrobj_remove(self, i)


    def getCardinal(self):
        """
        getCardinal(ComplexAstrobj self) -> size_t



        Get the number of elements in the array. 
        """
        return _std.ComplexAstrobj_getCardinal(self)


    def metric(self, *args):
        """
        metric(ComplexAstrobj self) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >
        metric(ComplexAstrobj self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)
        metric(ComplexAstrobj self, Gyoto::SmartPointer< Gyoto::Metric::Generic > gg)



        Get the Metric gg_. 
        """
        return _std.ComplexAstrobj_metric(self, *args)


    def fillElement(self, fmp):
        """
        fillElement(ComplexAstrobj self, FactoryMessenger fmp)



        Fill the XML element for this Object.

        The base implementation simply calls fillProperty() for each Property
        defined for the Object.

        Derived classes should avoid overriding fillElement(). It may make
        sense occasionally, e.g. to make sure that the metric is output first.

        To customize how a given Property is rendered, it is better to
        override fillProperty().

        If this method is overridden, the implementation should in general
        call fillElement() on the direct base. 
        """
        return _std.ComplexAstrobj_fillElement(self, fmp)


    def setParameters(self, fmp):
        """
        setParameters(ComplexAstrobj self, FactoryMessenger fmp)



        Main loop in Subcontractor_t function.

        The Subcontractor_t function for each Astrobj kind should look
        somewhat like this (templated as
        Gyoto::Astrobj::Subcontractor<MyKind>):

        Each object kind should implement setParameter(string name, string
        content, string unit) to interpret the individual XML elements.
        setParameters() can be overloaded in case the specific Astrobj class
        needs low level access to the FactoryMessenger. See
        UniformSphere::setParameters(). 
        """
        return _std.ComplexAstrobj_setParameters(self, fmp)


    def Impact(self, ph, index, data=None):
        """
        Impact(ComplexAstrobj self, Photon ph, size_t index, AstrobjProperties data=None) -> int
        Impact(ComplexAstrobj self, Photon ph, size_t index) -> int



        Call Impact() for each of the elements.

        Astrobj::Complex::Impact( Gyoto::Photon* ph, size_t index,
        Astrobj::Properties *data) calls the specific implementation of
        Astrobj::Generic::Impact() for each of its elements twice: the first
        time, data is set to NULL so that Astrobj::Complex::Impact() only
        knows whether each object is hit by the Photon. If no object is hit,
        return. If a single object is hit, call Impact() again only for this
        object, passing data this time. If several objects are hit, the
        Photon's trajectory is refined so that the step is at most step_max_
        and the Impact() methods for each of the hit objects are called again
        for each step, passing data. It is therefore important that the
        transmission of the Photon is not touched by Impact() when data==NULL.

        """
        return _std.ComplexAstrobj_Impact(self, ph, index, data)


    def __getitem__(self, i):
        """__getitem__(ComplexAstrobj self, size_t i) -> Gyoto::SmartPointer< Gyoto::Astrobj::Generic >"""
        return _std.ComplexAstrobj___getitem__(self, i)


    def __setitem__(self, i, p):
        """__setitem__(ComplexAstrobj self, int i, Astrobj p)"""
        return _std.ComplexAstrobj___setitem__(self, i, p)


    def __init__(self, *args):
        """
        Complex() -> ComplexAstrobj
        Complex(ComplexAstrobj arg2) -> ComplexAstrobj
        Complex(Astrobj base) -> ComplexAstrobj
        __init__(Gyoto::Astrobj::Complex self, long address) -> ComplexAstrobj



        Copy constructor. 
        """
        this = _std.new_ComplexAstrobj(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
ComplexAstrobj_swigregister = _std.ComplexAstrobj_swigregister
ComplexAstrobj_swigregister(ComplexAstrobj)

class Star(UniformSphere, gyoto.core.Worldline):
    """


    Mass-less, spherical object following a timelike geodesic.

    Gyoto can compute the Star's orbit in a Gyoto::Metric and perform ray-
    tracing on this target. The XML description of a Star looks like:

    Star supports exactly the union of the parameters supported by
    Gyoto::Astrobj::UniformSphere and Gyoto::Worldline.

    The Metric element can be of any kind. This Metric sets the coordinate
    system.

    The Star is a coordinate sphere of radius Radius in solid motion.

    Position sets the initial 4-coordinate of the centre of the sphere.
    Velocity contains its initial 3-velocity (the time derivatives of the
    3 space coordinates).

    Like many Astrobj::Generic impementations, a Star can be OpticallyThin
    or OpticallyThick.

    Spectrum and Opacity (if OpticallyThin) are the descriptions of two
    Gyoto::Spectrum::Generic sub-classes.

    C++ includes: GyotoStar.h 
    """

    __swig_setmethods__ = {}
    for _s in [UniformSphere, gyoto.core.Worldline]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Star, name, value)
    __swig_getmethods__ = {}
    for _s in [UniformSphere, gyoto.core.Worldline]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Star, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(Star self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.Star_getProperties(self)


    def plugins(self, *args):
        """
        plugins(Star self, vector_string plugname)
        plugins(Star self) -> vector_string
        """
        return _std.Star_plugins(self, *args)


    def clone(self):
        """
        clone(Star self) -> Star



        Cloner.

        This method must be implemented by the various Astrobj::Generic
        subclasses in order to support cloning:

        Cloning is necessary for multi-threading, recommended for interaction
        with the Yorick plug-in etc.

        Implementing it is very straightforward, as long as the copy
        constructor Generic(const Generic& ) has been implemented: 
        """
        return _std.Star_clone(self)

    __swig_destroy__ = _std.delete_Star
    __del__ = lambda self: None

    def className(self):
        """
        className(Star self) -> std::string



        "Star" 
        """
        return _std.Star_className(self)


    def className_l(self):
        """
        className_l(Star self) -> std::string



        "star" 
        """
        return _std.Star_className_l(self)


    def metric(self, *args):
        """
        metric(Star self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)
        metric(Star self) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >



        Get the Metric gg_. 
        """
        return _std.Star_metric(self, *args)


    def getMass(self):
        """
        getMass(Star self) -> double



        Return 1.

        The mass of a Star is always 1. Stars do not perturb the metric. The
        only relevant point is that Stars are massive particules, their exact
        mass is of no importance. 
        """
        return _std.Star_getMass(self)


    def rMax(self, *args):
        """
        rMax(Star self) -> double
        rMax(Star self, std::string const & unit) -> double
        rMax(Star self, std::string const & unit) -> double
        rMax(Star self, double val)
        rMax(Star self, double val, std::string const & unit)
        rMax(Star self) -> double



        Set maximal distance from center of coordinate system.

        Call Generic::rMax(double val) after converting val from unit to
        geometrical units.

        Parameters:
        -----------

        val:   rmax_ expressed in unit "unit";

        unit:  string... 
        """
        return _std.Star_rMax(self, *args)


    def setInitialCondition(self, coord):
        """
        setInitialCondition(Star self, double const [8] coord)



        Set or re-set the initial condition prior to integration.

        Parameters:
        -----------

        gg:   Gyoto::SmartPointer to the Gyoto::Metric in this universe;

        coord:  8 element array containing the initial condition, i.e. the
        4-position and the 4-velocity of the Photon at the receiving end;

        dir:  direction: 1 for future, -1 for past. 
        """
        return _std.Star_setInitialCondition(self, coord)


    def setParameter(self, name, content, unit):
        """
        setParameter(Star self, std::string name, std::string content, std::string unit) -> int



        Set parameter by Property (and name)

        This function is used when parsing an XML description, if Property (
        p) of this name is found (i.e. either p.name or p.name_false is equal
        to name). Implementation should fall-back on calling the direct's
        parent implementation:

        Parameters:
        -----------

        p:   Property that matches name ( p.name == name or p.name_false ==
        name)

        name:  XML name of the parameter (XML entity)

        content:  string representation of the value

        unit:  string representation of the unit 
        """
        return _std.Star_setParameter(self, name, content, unit)


    def setParameters(self, fmp):
        """
        setParameters(Star self, FactoryMessenger fmp)



        Main loop in Subcontractor_t function.

        The Subcontractor_t function for each Astrobj kind should look
        somewhat like this (templated as
        Gyoto::Astrobj::Subcontractor<MyKind>):

        Each object kind should implement setParameter(string name, string
        content, string unit) to interpret the individual XML elements.
        setParameters() can be overloaded in case the specific Astrobj class
        needs low level access to the FactoryMessenger. See
        UniformSphere::setParameters(). 
        """
        return _std.Star_setParameters(self, fmp)


    def fillProperty(self, fmp, p):
        """
        fillProperty(Star self, FactoryMessenger fmp, Property p)



        Output a single Property to XML.

        The base implementation decides what to do based on the p.type. The
        format matches how setParameters() an setParameter() would interpret
        the XML descition.

        Overriding this method should be avoided, but makes sense in some
        cases (for instance Screen::fillProperty() selects a different unit
        for Distance based on its magnitude, so that stellar sizes are
        expressed in solar radii while smaller sizes can be expressed in
        meters and larger sizes in parsecs).

        Overriding implementation should fall-back on calling the
        implementation in the direct parent class: 
        """
        return _std.Star_fillProperty(self, fmp, p)


    def _delta(self, *args):
        """
        _delta(Star self, double const delta)
        _delta(Star self, double arg2, std::string const & unit)
        _delta(Star self) -> double
        _delta(Star self, std::string const & unit) -> double
        """
        return _std.Star__delta(self, *args)


    def _tMin(self, *args):
        """
        _tMin(Star self, double const tmin)
        _tMin(Star self, double arg2, std::string const & unit)
        _tMin(Star self) -> double
        _tMin(Star self, std::string const & unit) -> double
        """
        return _std.Star__tMin(self, *args)


    def _adaptive(self, *args):
        """
        _adaptive(Star self, bool mode)
        _adaptive(Star self) -> bool
        """
        return _std.Star__adaptive(self, *args)


    def _secondary(self, *args):
        """
        _secondary(Star self, bool sec)
        _secondary(Star self) -> bool
        """
        return _std.Star__secondary(self, *args)


    def _integ31(self, *args):
        """
        _integ31(Star self, bool sec)
        _integ31(Star self) -> bool
        """
        return _std.Star__integ31(self, *args)


    def _parallelTransport(self, *args):
        """
        _parallelTransport(Star self, bool sec)
        _parallelTransport(Star self) -> bool
        """
        return _std.Star__parallelTransport(self, *args)


    def _maxiter(self, *args):
        """
        _maxiter(Star self, size_t miter)
        _maxiter(Star self) -> size_t
        """
        return _std.Star__maxiter(self, *args)


    def _integrator(self, *args):
        """
        _integrator(Star self, std::string const & type)
        _integrator(Star self) -> std::string
        """
        return _std.Star__integrator(self, *args)


    def _deltaMin(self, *args):
        """
        _deltaMin(Star self) -> double
        _deltaMin(Star self, double h1)
        """
        return _std.Star__deltaMin(self, *args)


    def _absTol(self, *args):
        """
        _absTol(Star self, double arg2)
        _absTol(Star self) -> double
        """
        return _std.Star__absTol(self, *args)


    def _maxCrossEqplane(self, *args):
        """
        _maxCrossEqplane(Star self, double arg2)
        _maxCrossEqplane(Star self) -> double
        """
        return _std.Star__maxCrossEqplane(self, *args)


    def _relTol(self, *args):
        """
        _relTol(Star self, double arg2)
        _relTol(Star self) -> double
        """
        return _std.Star__relTol(self, *args)


    def _deltaMax(self, *args):
        """
        _deltaMax(Star self, double h1)
        _deltaMax(Star self) -> double
        """
        return _std.Star__deltaMax(self, *args)


    def _deltaMaxOverR(self, *args):
        """
        _deltaMaxOverR(Star self) -> double
        _deltaMaxOverR(Star self, double t)
        """
        return _std.Star__deltaMaxOverR(self, *args)


    def _initCoord(self, *args):
        """
        _initCoord(Star self) -> vector_double
        _initCoord(Star self, vector_double f)
        """
        return _std.Star__initCoord(self, *args)


    def _metric(self, *args):
        """
        _metric(Star self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)
        _metric(Star self) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >
        """
        return _std.Star__metric(self, *args)


    def deltaMax(self, *args):
        """
        deltaMax(Star self) -> double
        deltaMax(Star self, double const [8] pos, double delta_max_external) -> double
        deltaMax(Star self, double h1)
        deltaMax(Star self, double * coord) -> double



        Get max step constraint for adaptive integration.

        Parameters:
        -----------

        coord:  position

        max step to find this object reliably 
        """
        return _std.Star_deltaMax(self, *args)


    def getVelocity(self, pos, vel):
        """
        getVelocity(Star self, double const [4] pos, double [4] vel)



        Yield velocity of the center of the sphere. 
        """
        return _std.Star_getVelocity(self, pos, vel)


    def radiativeQ(self, Inu, Qnu, Unu, Vnu, Onu, nuem, nbnu, dsem, cph, co):
        """radiativeQ(Star self, double * Inu, double * Qnu, double * Unu, double * Vnu, Eigen::Matrix4d * Onu, double const * nuem, size_t nbnu, double dsem, vector_double cph, double const * co)"""
        return _std.Star_radiativeQ(self, Inu, Qnu, Unu, Vnu, Onu, nuem, nbnu, dsem, cph, co)


    def __init__(self, *args):
        """
        __init__(Gyoto::Astrobj::Star self, Gyoto::SmartPointer< Gyoto::Metric::Generic > gg, double radius, double const [4] pos, double const [3] v) -> Star
        __init__(Gyoto::Astrobj::Star self) -> Star
        __init__(Gyoto::Astrobj::Star self, Star orig) -> Star
        __init__(Gyoto::Astrobj::Star self, Astrobj base) -> Star
        __init__(Gyoto::Astrobj::Star self, long address) -> Star



        Copy constructor. 
        """
        this = _std.new_Star(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
Star_swigregister = _std.Star_swigregister
Star_swigregister(Star)
Star.properties = _std.cvar.Star_properties
Star.builtinPluginValue = _std.cvar.Star_builtinPluginValue

class StarTrace(Star):
    """


    Like a Star that would be on all points of its orbit at all time.

    StarTrace inherits all the members and methods from Star. It has two
    additional members, tmin_ and tmax_, which specify the time interval
    of the Star's orbit that is to be considerred illuminated.

    A StarTrace is not (necessarily) continuous: the Star is considerred
    to be present at all the locations computed by xFill(), meaning that
    if the integration step is large compared to radius_, the object will
    be a collection of discrete blobs. To ensure continuity, one should
    use a non-adaptive step and specify a reasonable step. Computation is
    also faster in optically thick mode.

    C++ includes: GyotoStarTrace.h 
    """

    __swig_setmethods__ = {}
    for _s in [Star]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StarTrace, name, value)
    __swig_getmethods__ = {}
    for _s in [Star]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StarTrace, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(StarTrace self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.StarTrace_getProperties(self)


    def plugins(self, *args):
        """
        plugins(StarTrace self, vector_string plugname)
        plugins(StarTrace self) -> vector_string
        """
        return _std.StarTrace_plugins(self, *args)


    def clone(self):
        """
        clone(StarTrace self) -> StarTrace



        Cloner.

        This method must be implemented by the various Astrobj::Generic
        subclasses in order to support cloning:

        Cloning is necessary for multi-threading, recommended for interaction
        with the Yorick plug-in etc.

        Implementing it is very straightforward, as long as the copy
        constructor Generic(const Generic& ) has been implemented: 
        """
        return _std.StarTrace_clone(self)

    __swig_destroy__ = _std.delete_StarTrace
    __del__ = lambda self: None

    def xAllocate(self, *args):
        """
        xAllocate(StarTrace self)
        xAllocate(StarTrace self, size_t arg2)



        Allocate x0, x1 etc. with a specified size.

        Parameters:
        -----------

        size:  : number of cells in each array x0, x1 etc. 
        """
        return _std.StarTrace_xAllocate(self, *args)


    def xAllocateXYZ(self):
        """
        xAllocateXYZ(StarTrace self)



        Allocate x_, y_, z_. 
        """
        return _std.StarTrace_xAllocateXYZ(self)


    def xExpand(self, *args):
        """
        xExpand(StarTrace self, double *& x, int dir)
        xExpand(StarTrace self, int arg2) -> size_t



        Expand x0, x1 etc... to hold more elements.

        Double the size of arrays x0, x1 etc. and copy old version of the
        array in the first half if dir =1 and in the second half if dir =-1.

        Parameters:
        -----------

        dir:  : 1 to expand after last element, -1 to expand before first
        element

        ind : if dir=1, new index of old last element, if dir=-1, new index of
        old first element 
        """
        return _std.StarTrace_xExpand(self, *args)


    def computeXYZ(self, *args):
        """
        computeXYZ(StarTrace self, size_t i)
        computeXYZ(StarTrace self)



        Compute (and cache) x_, y_ and z_. 
        """
        return _std.StarTrace_computeXYZ(self, *args)


    def setInitCoord(self, *args):
        """
        setInitCoord(StarTrace self, double const [8] coord, int dir, double const [4] Ephi, double const [4] Etheta)
        setInitCoord(StarTrace self, double const [4] pos, double const [3] vel, int dir=0)
        setInitCoord(StarTrace self, double const [4] pos, double const [3] vel)
        setInitCoord(StarTrace self, double const [8] coord, int dir=0)
        setInitCoord(StarTrace self, double const [8] coord)



        Set initial coordinate.

        Parameters:
        -----------

        pos:  initial 4-position

        vel:  initial 3-velocity

        dir:  direction of integration 
        """
        return _std.StarTrace_setInitCoord(self, *args)


    def metric(self, *args):
        """
        metric(StarTrace self) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >
        metric(StarTrace self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)
        metric(StarTrace self, Gyoto::SmartPointer< Gyoto::Metric::Generic > gg)



        Get the Metric gg_. 
        """
        return _std.StarTrace_metric(self, *args)


    def xStore(self, ind, coord, tau):
        """
        xStore(StarTrace self, size_t ind, vector_double coord, double tau)



        Obsolete, update your code. 
        """
        return _std.StarTrace_xStore(self, ind, coord, tau)


    def className(self):
        """
        className(StarTrace self) -> std::string



        "StarTrace" 
        """
        return _std.StarTrace_className(self)


    def className_l(self):
        """
        className_l(StarTrace self) -> std::string



        "startrace" 
        """
        return _std.StarTrace_className_l(self)


    def TMin(self, *args):
        """
        TMin(StarTrace self) -> double
        TMin(StarTrace self, double arg2)



        Set tmin_. 
        """
        return _std.StarTrace_TMin(self, *args)


    def TMax(self, *args):
        """
        TMax(StarTrace self) -> double
        TMax(StarTrace self, double arg2)



        Set tmax_. 
        """
        return _std.StarTrace_TMax(self, *args)


    def setInitialCondition(self, coord):
        """
        setInitialCondition(StarTrace self, double const [8] coord)



        Set or re-set the initial condition prior to integration.

        Parameters:
        -----------

        gg:   Gyoto::SmartPointer to the Gyoto::Metric in this universe;

        coord:  8 element array containing the initial condition, i.e. the
        4-position and the 4-velocity of the Photon at the receiving end;

        dir:  direction: 1 for future, -1 for past. 
        """
        return _std.StarTrace_setInitialCondition(self, coord)


    def __call__(self, coord):
        """__call__(StarTrace self, double const [4] coord) -> double"""
        return _std.StarTrace___call__(self, coord)


    def __init__(self, *args):
        """
        __init__(Gyoto::Astrobj::StarTrace self, Gyoto::SmartPointer< Gyoto::Metric::Generic > gg, double radius, double const [4] pos, double const [3] v) -> StarTrace
        __init__(Gyoto::Astrobj::StarTrace self) -> StarTrace
        __init__(Gyoto::Astrobj::StarTrace self, StarTrace orig) -> StarTrace
        __init__(Gyoto::Astrobj::StarTrace self, Star o, double tmin, double tmax) -> StarTrace
        __init__(Gyoto::Astrobj::StarTrace self, Astrobj base) -> StarTrace
        __init__(Gyoto::Astrobj::StarTrace self, long address) -> StarTrace



        Build StarTrace from Star. 
        """
        this = _std.new_StarTrace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
StarTrace_swigregister = _std.StarTrace_swigregister
StarTrace_swigregister(StarTrace)
StarTrace.properties = _std.cvar.StarTrace_properties
StarTrace.builtinPluginValue = _std.cvar.StarTrace_builtinPluginValue

class FixedStar(UniformSphere):
    """


    Fixed (i.e. non-moving) star (or spherical blob)

    The target of ray-traced Gyoto::Photon

    C++ includes: GyotoFixedStar.h 
    """

    __swig_setmethods__ = {}
    for _s in [UniformSphere]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FixedStar, name, value)
    __swig_getmethods__ = {}
    for _s in [UniformSphere]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FixedStar, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(FixedStar self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.FixedStar_getProperties(self)


    def plugins(self, *args):
        """
        plugins(FixedStar self, vector_string plugname)
        plugins(FixedStar self) -> vector_string
        """
        return _std.FixedStar_plugins(self, *args)


    def clone(self):
        """
        clone(FixedStar self) -> FixedStar



        Cloner.

        This method must be implemented by the various Astrobj::Generic
        subclasses in order to support cloning:

        Cloning is necessary for multi-threading, recommended for interaction
        with the Yorick plug-in etc.

        Implementing it is very straightforward, as long as the copy
        constructor Generic(const Generic& ) has been implemented: 
        """
        return _std.FixedStar_clone(self)

    __swig_destroy__ = _std.delete_FixedStar
    __del__ = lambda self: None

    def getPos(self, *args):
        """
        getPos(FixedStar self) -> double const
        getPos(FixedStar self, double * dst)



        Get a copy of the pos_ array. 
        """
        return _std.FixedStar_getPos(self, *args)


    def position(self, *args):
        """
        position(FixedStar self) -> vector_double
        position(FixedStar self, vector_double arg2)



        Set pos_ from vector. 
        """
        return _std.FixedStar_position(self, *args)


    def rMax(self):
        """
        rMax(FixedStar self) -> double



        Set maximal distance from center of coordinate system.

        Call Generic::rMax(double val) after converting val from unit to
        geometrical units.

        Parameters:
        -----------

        val:   rmax_ expressed in unit "unit";

        unit:  string... 
        """
        return _std.FixedStar_rMax(self)


    def rotating(self, *args):
        """
        rotating(FixedStar self) -> bool
        rotating(FixedStar self, bool arg2)
        """
        return _std.FixedStar_rotating(self, *args)


    def metric(self, *args):
        """
        metric(FixedStar self) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >
        metric(FixedStar self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)
        metric(FixedStar self, Gyoto::SmartPointer< Gyoto::Metric::Generic > metric)



        Get the Metric gg_. 
        """
        return _std.FixedStar_metric(self, *args)


    def radius(self, *args):
        """
        radius(FixedStar self) -> double
        radius(FixedStar self, std::string const & arg2) -> double
        radius(FixedStar self, double arg2, std::string const & arg3)
        radius(FixedStar self, double radius)



        Set radius_ in specified unit. 
        """
        return _std.FixedStar_radius(self, *args)


    def setPos(self, arg2):
        """
        setPos(FixedStar self, double const [3] arg2)



        Set pos_ array. 
        """
        return _std.FixedStar_setPos(self, arg2)


    def __init__(self, *args):
        """
        __init__(Gyoto::Astrobj::FixedStar self) -> FixedStar
        __init__(Gyoto::Astrobj::FixedStar self, FixedStar orig) -> FixedStar
        __init__(Gyoto::Astrobj::FixedStar self, Gyoto::SmartPointer< Gyoto::Metric::Generic > gg, double [3] StPsn, double radius) -> FixedStar
        __init__(Gyoto::Astrobj::FixedStar self, Astrobj base) -> FixedStar
        __init__(Gyoto::Astrobj::FixedStar self, long address) -> FixedStar



        Standard constructor. 
        """
        this = _std.new_FixedStar(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
FixedStar_swigregister = _std.FixedStar_swigregister
FixedStar_swigregister(FixedStar)
FixedStar.properties = _std.cvar.FixedStar_properties
FixedStar.builtinPluginValue = _std.cvar.FixedStar_builtinPluginValue

class FreeStar(UniformSphere):
    """


    UniformShere following a trajectory specified in getVelocity (non-
    geodesic) with a constant velocity.

    C++ includes: GyotoFreeStar.h 
    """

    __swig_setmethods__ = {}
    for _s in [UniformSphere]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FreeStar, name, value)
    __swig_getmethods__ = {}
    for _s in [UniformSphere]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FreeStar, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(FreeStar self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.FreeStar_getProperties(self)


    def plugins(self, *args):
        """
        plugins(FreeStar self, vector_string plugname)
        plugins(FreeStar self) -> vector_string
        """
        return _std.FreeStar_plugins(self, *args)


    def clone(self):
        """
        clone(FreeStar self) -> FreeStar



        Cloner.

        This method must be implemented by the various Astrobj::Generic
        subclasses in order to support cloning:

        Cloning is necessary for multi-threading, recommended for interaction
        with the Yorick plug-in etc.

        Implementing it is very straightforward, as long as the copy
        constructor Generic(const Generic& ) has been implemented: 
        """
        return _std.FreeStar_clone(self)

    __swig_destroy__ = _std.delete_FreeStar
    __del__ = lambda self: None

    def className(self):
        """
        className(FreeStar self) -> std::string



        "FreeStar" 
        """
        return _std.FreeStar_className(self)


    def className_l(self):
        """
        className_l(FreeStar self) -> std::string



        "free_star" 
        """
        return _std.FreeStar_className_l(self)


    def initPosition(self, *args):
        """
        initPosition(FreeStar self, vector_double v)
        initPosition(FreeStar self) -> vector_double
        """
        return _std.FreeStar_initPosition(self, *args)


    def initVelocity(self, *args):
        """
        initVelocity(FreeStar self, vector_double v)
        initVelocity(FreeStar self) -> vector_double
        """
        return _std.FreeStar_initVelocity(self, *args)


    def initCoord(self, *args):
        """
        initCoord(FreeStar self, vector_double v)
        initCoord(FreeStar self) -> vector_double
        """
        return _std.FreeStar_initCoord(self, *args)


    def getCartesian(self, dates, n_dates, x, y, z, xprime=None, yprime=None, zprime=None):
        """
        getCartesian(FreeStar self, double const *const dates, size_t const n_dates, double *const x, double *const y, double *const z, double *const xprime=None, double *const yprime=None, double *const zprime=None)
        getCartesian(FreeStar self, double const *const dates, size_t const n_dates, double *const x, double *const y, double *const z, double *const xprime=None, double *const yprime=None)
        getCartesian(FreeStar self, double const *const dates, size_t const n_dates, double *const x, double *const y, double *const z, double *const xprime=None)
        getCartesian(FreeStar self, double const *const dates, size_t const n_dates, double *const x, double *const y, double *const z)



        Yield the Cartesian coordinates of the center of the sphere.

        If the coordinate system of the Metric object is spherical, use a
        trivial conversion. 
        """
        return _std.FreeStar_getCartesian(self, dates, n_dates, x, y, z, xprime, yprime, zprime)


    def getVelocity(self, pos, vel):
        """
        getVelocity(FreeStar self, double const [4] pos, double [4] vel)



        Yield velocity of the center of the sphere. 
        """
        return _std.FreeStar_getVelocity(self, pos, vel)


    def __init__(self, *args):
        """
        __init__(Gyoto::Astrobj::FreeStar self) -> FreeStar
        __init__(Gyoto::Astrobj::FreeStar self, FreeStar orig) -> FreeStar
        __init__(Gyoto::Astrobj::FreeStar self, Astrobj base) -> FreeStar
        __init__(Gyoto::Astrobj::FreeStar self, long address) -> FreeStar



        Copy constructor. 
        """
        this = _std.new_FreeStar(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
FreeStar_swigregister = _std.FreeStar_swigregister
FreeStar_swigregister(FreeStar)
FreeStar.properties = _std.cvar.FreeStar_properties
FreeStar.builtinPluginValue = _std.cvar.FreeStar_builtinPluginValue

class InflateStar(Star):
    """


    An Astrobj::Star with growing size.

    C++ includes: GyotoInflateStar.h 
    """

    __swig_setmethods__ = {}
    for _s in [Star]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InflateStar, name, value)
    __swig_getmethods__ = {}
    for _s in [Star]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InflateStar, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(InflateStar self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.InflateStar_getProperties(self)


    def plugins(self, *args):
        """
        plugins(InflateStar self, vector_string plugname)
        plugins(InflateStar self) -> vector_string
        """
        return _std.InflateStar_plugins(self, *args)


    def clone(self):
        """
        clone(InflateStar self) -> InflateStar



        Cloner.

        This method must be implemented by the various Astrobj::Generic
        subclasses in order to support cloning:

        Cloning is necessary for multi-threading, recommended for interaction
        with the Yorick plug-in etc.

        Implementing it is very straightforward, as long as the copy
        constructor Generic(const Generic& ) has been implemented: 
        """
        return _std.InflateStar_clone(self)

    __swig_destroy__ = _std.delete_InflateStar
    __del__ = lambda self: None

    def timeInflateInit(self, *args):
        """
        timeInflateInit(InflateStar self, double arg2)
        timeInflateInit(InflateStar self) -> double
        timeInflateInit(InflateStar self, double arg2, std::string const & arg3)
        timeInflateInit(InflateStar self, std::string const & arg2) -> double
        """
        return _std.InflateStar_timeInflateInit(self, *args)


    def timeInflateStop(self, *args):
        """
        timeInflateStop(InflateStar self, double arg2)
        timeInflateStop(InflateStar self) -> double
        timeInflateStop(InflateStar self, double arg2, std::string const & arg3)
        timeInflateStop(InflateStar self, std::string const & arg2) -> double
        """
        return _std.InflateStar_timeInflateStop(self, *args)


    def radiusStop(self, *args):
        """
        radiusStop(InflateStar self, double arg2)
        radiusStop(InflateStar self) -> double
        radiusStop(InflateStar self, double arg2, std::string const & arg3)
        radiusStop(InflateStar self, std::string const & arg2) -> double
        """
        return _std.InflateStar_radiusStop(self, *args)


    def radius(self, *args):
        """
        radius(InflateStar self) -> double
        radius(InflateStar self, double arg2)
        radius(InflateStar self, std::string const & arg2) -> double
        radius(InflateStar self, double arg2, std::string const & arg3)



        Set radius_ in specified unit. 
        """
        return _std.InflateStar_radius(self, *args)


    def radiusAt(self, *args):
        """
        radiusAt(InflateStar self, double t) -> double
        radiusAt(InflateStar self, double t, std::string const & t_unit) -> double
        radiusAt(InflateStar self, double t, std::string const & t_unit, std::string const & r_unit) -> double



        Radius at a given time. 
        """
        return _std.InflateStar_radiusAt(self, *args)


    def className(self):
        """
        className(InflateStar self) -> std::string



        "InflateStar" 
        """
        return _std.InflateStar_className(self)


    def className_l(self):
        """
        className_l(InflateStar self) -> std::string



        "inflate_star" 
        """
        return _std.InflateStar_className_l(self)


    def Impact(self, ph, index, data=None):
        """
        Impact(InflateStar self, Photon ph, size_t index, AstrobjProperties data=None) -> int
        Impact(InflateStar self, Photon ph, size_t index) -> int



        Does a photon at these coordinates impact the object?

        Impact() checks whether a Photon impacts the object between two
        integration steps of the photon's trajectory (those two steps are
        photon->getCoord(index, coord1) and photon->getCoord(index+1,
        coord2)). Impact returns 1 if the photon impacts the object between
        these two steps, else 0. In many cases of geometrically thick obects,
        the implementation Astrobj::Standard::Impact() will be fine.

        Impact will call Generic::processHitQuantities() (which is virtual and
        may be re-implemented) to compute observable properties on demand: if
        the data pointer is non-NULL, the object will look in it for pointers
        to properties which apply to its kind. If a pointer to a property
        known to this object is present, then the property is computed and
        store at the pointed-to address. For instance, all objects know the
        "intensity" property. If data->intensity != NULL, the instensity is
        computed and stored in *data->intensity.

        If data is non-NULL and only in this case, processHitQuantities() will
        also call ph->transmit() to update the transmissions of the Photon
        (see Photon::transmit(size_t, double)). This must not be done if data
        is NULL (see Astrobj::Complex::Impact() for an explanation).

        Impact() may not extend the ph Worldline. The only two dates that are
        guaranteed to be defined are at indices index and index+1.

        Parameters:
        -----------

        ph:   Gyoto::Photon aimed at the object;

        index:  Index of the last photon step;

        data:  Pointer to a structure to hold the observables at impact.

        1 if impact, 0 if not. 
        """
        return _std.InflateStar_Impact(self, ph, index, data)


    def emission(self, nu_em, dsem, cp, co=0):
        """
        emission(InflateStar self, double nu_em, double dsem, vector_double cp, double const [8] co=0) -> double
        emission(InflateStar self, double nu_em, double dsem, vector_double cp) -> double



        Obsolete, update your code. 
        """
        return _std.InflateStar_emission(self, nu_em, dsem, cp, co)


    def __init__(self, *args):
        """
        __init__(Gyoto::Astrobj::InflateStar self) -> InflateStar
        __init__(Gyoto::Astrobj::InflateStar self, InflateStar orig) -> InflateStar
        __init__(Gyoto::Astrobj::InflateStar self, Astrobj base) -> InflateStar
        __init__(Gyoto::Astrobj::InflateStar self, long address) -> InflateStar



        Copy constructor. 
        """
        this = _std.new_InflateStar(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
InflateStar_swigregister = _std.InflateStar_swigregister
InflateStar_swigregister(InflateStar)
InflateStar.properties = _std.cvar.InflateStar_properties
InflateStar.builtinPluginValue = _std.cvar.InflateStar_builtinPluginValue

class Torus(gyoto.core.StandardAstrobj):
    """


    Optically thin or thick torus in circular rotation.

    Any Metric::Generic is acceptable as long as it implements
    Metric::Generic::circularVelocity().

    C++ includes: GyotoTorus.h 
    """

    __swig_setmethods__ = {}
    for _s in [gyoto.core.StandardAstrobj]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Torus, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.StandardAstrobj]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Torus, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(Torus self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.Torus_getProperties(self)


    def plugins(self, *args):
        """
        plugins(Torus self, vector_string plugname)
        plugins(Torus self) -> vector_string
        """
        return _std.Torus_plugins(self, *args)


    def clone(self):
        """
        clone(Torus self) -> Torus



        "Virtual" copy constructor 
        """
        return _std.Torus_clone(self)

    __swig_destroy__ = _std.delete_Torus
    __del__ = lambda self: None

    def largeRadius(self, *args):
        """
        largeRadius(Torus self) -> double
        largeRadius(Torus self, std::string unit) -> double
        largeRadius(Torus self, double c)
        largeRadius(Torus self, double c, std::string unit)



        Set large radius Torus::c_ in specified unit. 
        """
        return _std.Torus_largeRadius(self, *args)


    def smallRadius(self, *args):
        """
        smallRadius(Torus self) -> double
        smallRadius(Torus self, std::string unit) -> double
        smallRadius(Torus self, double a)
        smallRadius(Torus self, double a, std::string unit)



        Set small radius in specified unit. 
        """
        return _std.Torus_smallRadius(self, *args)


    def spectrum(self, *args):
        """
        spectrum(Torus self, Gyoto::SmartPointer< Gyoto::Spectrum::Generic > arg2)
        spectrum(Torus self) -> Gyoto::SmartPointer< Gyoto::Spectrum::Generic >



        Get Torus::spectrum_. 
        """
        return _std.Torus_spectrum(self, *args)


    def opacity(self, *args):
        """
        opacity(Torus self, Gyoto::SmartPointer< Gyoto::Spectrum::Generic > arg2)
        opacity(Torus self) -> Gyoto::SmartPointer< Gyoto::Spectrum::Generic >



        Get Torus::opacity_. 
        """
        return _std.Torus_opacity(self, *args)


    def rMax(self, *args):
        """
        rMax(Torus self) -> double
        rMax(Torus self, std::string const & unit) -> double
        rMax(Torus self, std::string const & unit) -> double
        rMax(Torus self, double val)
        rMax(Torus self, double val, std::string const & unit)
        rMax(Torus self) -> double



        Set maximal distance from center of coordinate system.

        Call Generic::rMax(double val) after converting val from unit to
        geometrical units.

        Parameters:
        -----------

        val:   rmax_ expressed in unit "unit";

        unit:  string... 
        """
        return _std.Torus_rMax(self, *args)


    def __call__(self, coord):
        """__call__(Torus self, double const [4] coord) -> double"""
        return _std.Torus___call__(self, coord)


    def deltaMax(self, arg2):
        """
        deltaMax(Torus self, double * arg2) -> double



        Get max step constraint for adaptive integration.

        Parameters:
        -----------

        coord:  position

        max step to find this object reliably 
        """
        return _std.Torus_deltaMax(self, arg2)


    def __init__(self, *args):
        """
        __init__(Gyoto::Astrobj::Torus self) -> Torus
        __init__(Gyoto::Astrobj::Torus self, Torus arg2) -> Torus
        __init__(Gyoto::Astrobj::Torus self, Astrobj base) -> Torus
        __init__(Gyoto::Astrobj::Torus self, long address) -> Torus



        Copy constructor. 
        """
        this = _std.new_Torus(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
Torus_swigregister = _std.Torus_swigregister
Torus_swigregister(Torus)
Torus.properties = _std.cvar.Torus_properties
Torus.builtinPluginValue = _std.cvar.Torus_builtinPluginValue

class OscilTorus(gyoto.core.StandardAstrobj, gyoto.core.Listener):
    """Proxy of C++ Gyoto::Astrobj::OscilTorus class."""

    __swig_setmethods__ = {}
    for _s in [gyoto.core.StandardAstrobj, gyoto.core.Listener]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OscilTorus, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.StandardAstrobj, gyoto.core.Listener]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, OscilTorus, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(OscilTorus self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.OscilTorus_getProperties(self)


    def plugins(self, *args):
        """
        plugins(OscilTorus self, vector_string plugname)
        plugins(OscilTorus self) -> vector_string
        """
        return _std.OscilTorus_plugins(self, *args)

    __swig_destroy__ = _std.delete_OscilTorus
    __del__ = lambda self: None

    def clone(self):
        """
        clone(OscilTorus self) -> OscilTorus



        Cloner.

        This method must be implemented by the various Astrobj::Generic
        subclasses in order to support cloning:

        Cloning is necessary for multi-threading, recommended for interaction
        with the Yorick plug-in etc.

        Implementing it is very straightforward, as long as the copy
        constructor Generic(const Generic& ) has been implemented: 
        """
        return _std.OscilTorus_clone(self)


    def largeRadius(self, *args):
        """
        largeRadius(OscilTorus self, double arg2)
        largeRadius(OscilTorus self) -> double
        largeRadius(OscilTorus self, double arg2, std::string const & arg3)
        largeRadius(OscilTorus self, std::string const & arg2) -> double
        """
        return _std.OscilTorus_largeRadius(self, *args)


    def mode(self, *args):
        """
        mode(OscilTorus self, unsigned long arg2)
        mode(OscilTorus self) -> unsigned long
        """
        return _std.OscilTorus_mode(self, *args)


    def polyCst(self, *args):
        """
        polyCst(OscilTorus self, double arg2)
        polyCst(OscilTorus self) -> double
        """
        return _std.OscilTorus_polyCst(self, *args)


    def polyIndex(self, *args):
        """
        polyIndex(OscilTorus self, double arg2)
        polyIndex(OscilTorus self) -> double
        """
        return _std.OscilTorus_polyIndex(self, *args)


    def centralDensity(self, *args):
        """
        centralDensity(OscilTorus self, double arg2)
        centralDensity(OscilTorus self) -> double
        """
        return _std.OscilTorus_centralDensity(self, *args)


    def perturbKind(self, *args):
        """
        perturbKind(OscilTorus self, std::string const & arg2)
        perturbKind(OscilTorus self) -> std::string
        """
        return _std.OscilTorus_perturbKind(self, *args)


    def perturbIntens(self, *args):
        """
        perturbIntens(OscilTorus self, double arg2)
        perturbIntens(OscilTorus self) -> double
        """
        return _std.OscilTorus_perturbIntens(self, *args)


    def emittingArea(self, *args):
        """
        emittingArea(OscilTorus self, std::string const & arg2)
        emittingArea(OscilTorus self) -> std::string
        """
        return _std.OscilTorus_emittingArea(self, *args)


    def metric(self, *args):
        """
        metric(OscilTorus self) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >
        metric(OscilTorus self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)



        Get the Metric gg_. 
        """
        return _std.OscilTorus_metric(self, *args)


    def __call__(self, coord):
        """__call__(OscilTorus self, double const [4] coord) -> double"""
        return _std.OscilTorus___call__(self, coord)


    def getVelocity(self, pos, vel):
        """
        getVelocity(OscilTorus self, double const [4] pos, double [4] vel)



        Fluid velocity field.

        Fill vel with the 4-vector velocity of the fluid at 4-position pos.

        Parameters:
        -----------

        pos:  4-position at which to compute velocity;

        vel:  4-velocity at pos. 
        """
        return _std.OscilTorus_getVelocity(self, pos, vel)


    def emission(self, nuem, arg3, arg4, arg5):
        """
        emission(OscilTorus self, double nuem, double arg3, vector_double arg4, double const * arg5) -> double



        Obsolete, update your code. 
        """
        return _std.OscilTorus_emission(self, nuem, arg3, arg4, arg5)


    def setParameters(self, fmp):
        """
        setParameters(OscilTorus self, FactoryMessenger fmp)



        Main loop in Subcontractor_t function.

        The Subcontractor_t function for each Astrobj kind should look
        somewhat like this (templated as
        Gyoto::Astrobj::Subcontractor<MyKind>):

        Each object kind should implement setParameter(string name, string
        content, string unit) to interpret the individual XML elements.
        setParameters() can be overloaded in case the specific Astrobj class
        needs low level access to the FactoryMessenger. See
        UniformSphere::setParameters(). 
        """
        return _std.OscilTorus_setParameters(self, fmp)


    def updateCachedValues(self):
        """updateCachedValues(OscilTorus self)"""
        return _std.OscilTorus_updateCachedValues(self)


    def computeXbYb(self, pos, xb, yb):
        """computeXbYb(OscilTorus self, double const * pos, double & xb, double & yb)"""
        return _std.OscilTorus_computeXbYb(self, pos, xb, yb)


    def tell(self, msg):
        """
        tell(OscilTorus self, Teller msg)



        Update cached values.

        Calls updateCachedValues().

        See Hook::Listener::tell() 
        """
        return _std.OscilTorus_tell(self, msg)


    def __init__(self, *args):
        """
        __init__(Gyoto::Astrobj::OscilTorus self) -> OscilTorus
        __init__(Gyoto::Astrobj::OscilTorus self, OscilTorus o) -> OscilTorus
        __init__(Gyoto::Astrobj::OscilTorus self, Astrobj base) -> OscilTorus
        __init__(Gyoto::Astrobj::OscilTorus self, long address) -> OscilTorus
        """
        this = _std.new_OscilTorus(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
OscilTorus_swigregister = _std.OscilTorus_swigregister
OscilTorus_swigregister(OscilTorus)
OscilTorus.properties = _std.cvar.OscilTorus_properties
OscilTorus.builtinPluginValue = _std.cvar.OscilTorus_builtinPluginValue

class PageThorneDisk(gyoto.core.ThinDisk, gyoto.core.Listener):
    """


    Geometrically thin disk in Kerr metric.

    This class describes a disk contained in the z=0 (equatorial) plane,
    extending from r=r_ISCO to r=infinity. The flux emitted at radius r is
    given by Page & Thorne (1974, ApJ 191:499, Eqs. 11b, 14, 15).

    The metric must be either KerrBL or KerrKS. Emission, Spectrum and
    BinSpectrum are not provide, the only intensity provided is provided,
    as quantity User4 and it is the default quantity returned if nothing
    is requested. The other quantities implemented in ThinDisk are also
    provided.

    C++ includes: GyotoPageThorneDisk.h 
    """

    __swig_setmethods__ = {}
    for _s in [gyoto.core.ThinDisk, gyoto.core.Listener]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PageThorneDisk, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.ThinDisk, gyoto.core.Listener]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PageThorneDisk, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(PageThorneDisk self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.PageThorneDisk_getProperties(self)


    def plugins(self, *args):
        """
        plugins(PageThorneDisk self, vector_string plugname)
        plugins(PageThorneDisk self) -> vector_string
        """
        return _std.PageThorneDisk_plugins(self, *args)


    def isThreadSafe(self):
        """
        isThreadSafe(PageThorneDisk self) -> bool



        Whether this class is thread-safe.

        Return True if this object is thread-safe, i.e. if an instance and its
        clone can be used in parallel threads (in the context of
        Scenery::raytrace()). Known objects which are not thread-safe include
        Lorene metrics and everything from the Python plug-in.

        The default implementation considers that the class itself is thread
        safe and recurses into the declared properties to check whether they
        are safe too. Classes that abide to the Object/Property paradigm and
        are themselves thread-safe have nothing special to do.

        Objects that clone children in their copy constructor that are not
        declared as properties must take these children into account.

        Classes that are never thread-safe must declare it. It acn be easily
        done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
        GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. 
        """
        return _std.PageThorneDisk_isThreadSafe(self)


    def clone(self):
        """
        clone(PageThorneDisk self) -> PageThorneDisk



        Cloner. 
        """
        return _std.PageThorneDisk_clone(self)

    __swig_destroy__ = _std.delete_PageThorneDisk
    __del__ = lambda self: None

    def metric(self, *args):
        """
        metric(PageThorneDisk self) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >
        metric(PageThorneDisk self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)
        metric(PageThorneDisk self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)



        Get the Metric gg_. 
        """
        return _std.PageThorneDisk_metric(self, *args)


    def mdot(self, *args):
        """
        mdot(PageThorneDisk self, double v)
        mdot(PageThorneDisk self) -> double
        """
        return _std.PageThorneDisk_mdot(self, *args)


    def uniFlux(self, *args):
        """
        uniFlux(PageThorneDisk self, bool t)
        uniFlux(PageThorneDisk self) -> bool
        """
        return _std.PageThorneDisk_uniFlux(self, *args)


    def emission(self, *args):
        """
        emission(PageThorneDisk self, double nu_em, double dsem, vector_double coord_ph, double const [8] coord_obj=0) -> double
        emission(PageThorneDisk self, double nu_em, double dsem, vector_double coord_ph) -> double
        emission(PageThorneDisk self, double [] Inu, double const [] nu_em, size_t nbnu, double dsem, vector_double coord_ph, double const [8] coord_obj=0)
        emission(PageThorneDisk self, double [] Inu, double const [] nu_em, size_t nbnu, double dsem, vector_double coord_ph)
        emission(PageThorneDisk self, double nu_em, double dsem, vector_double c_ph, double const [8] c_obj=0) -> double
        emission(PageThorneDisk self, double nu_em, double dsem, vector_double c_ph) -> double



        Obsolete, update your code. 
        """
        return _std.PageThorneDisk_emission(self, *args)


    def bolometricEmission(self, nuem, dsem, c_obj):
        """
        bolometricEmission(PageThorneDisk self, double nuem, double dsem, double const [8] c_obj) -> double



        Bolometric emission.

        Similar to Generic::emission(), but bolometric. 
        """
        return _std.PageThorneDisk_bolometricEmission(self, nuem, dsem, c_obj)


    def processHitQuantities(self, ph, coord_ph_hit, coord_obj_hit, dt, data):
        """processHitQuantities(PageThorneDisk self, Photon ph, vector_double coord_ph_hit, double const * coord_obj_hit, double dt, AstrobjProperties data)"""
        return _std.PageThorneDisk_processHitQuantities(self, ph, coord_ph_hit, coord_obj_hit, dt, data)


    def getDefaultQuantities(self):
        """
        getDefaultQuantities(PageThorneDisk self) -> Gyoto::Quantity_t



        Which quantities to compute if know was requested.

        Return a Gyoto::Quantity_t suitable as input to
        Gyoto::Scenery::setRequestedQuantities() to set de default quantities
        to compute for this object. The default of these defaults
        GYOTO_QUANTITY_INTENSITY. 
        """
        return _std.PageThorneDisk_getDefaultQuantities(self)


    def tell(self, msg):
        """
        tell(PageThorneDisk self, Teller msg)



        Update PageThorneDisk::aa_.

        Calls updateSpin().

        See Hook::Listener::tell() 
        """
        return _std.PageThorneDisk_tell(self, msg)


    def radiativeQ(self, Inu, Qnu, Unu, Vnu, Onu, nuem, nbnu, dsem, cph, co):
        """radiativeQ(PageThorneDisk self, double * Inu, double * Qnu, double * Unu, double * Vnu, Eigen::Matrix4d * Onu, double const * nuem, size_t nbnu, double dsem, vector_double cph, double const * co)"""
        return _std.PageThorneDisk_radiativeQ(self, Inu, Qnu, Unu, Vnu, Onu, nuem, nbnu, dsem, cph, co)


    def __init__(self, *args):
        """
        __init__(Gyoto::Astrobj::PageThorneDisk self) -> PageThorneDisk
        __init__(Gyoto::Astrobj::PageThorneDisk self, PageThorneDisk arg2) -> PageThorneDisk
        __init__(Gyoto::Astrobj::PageThorneDisk self, Astrobj base) -> PageThorneDisk
        __init__(Gyoto::Astrobj::PageThorneDisk self, long address) -> PageThorneDisk



        Copy constructor. 
        """
        this = _std.new_PageThorneDisk(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
PageThorneDisk_swigregister = _std.PageThorneDisk_swigregister
PageThorneDisk_swigregister(PageThorneDisk)
PageThorneDisk.properties = _std.cvar.PageThorneDisk_properties
PageThorneDisk.builtinPluginValue = _std.cvar.PageThorneDisk_builtinPluginValue

class ThinDiskPL(gyoto.core.ThinDisk):
    """


    Geometrically thin disk with black-body emission.

    Temperature varies with a power-law from the inner radius outwards:

    =0 (rcur/rinner)

    C++ includes: GyotoThinDiskPL.h 
    """

    __swig_setmethods__ = {}
    for _s in [gyoto.core.ThinDisk]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ThinDiskPL, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.ThinDisk]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ThinDiskPL, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(ThinDiskPL self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.ThinDiskPL_getProperties(self)


    def plugins(self, *args):
        """
        plugins(ThinDiskPL self, vector_string plugname)
        plugins(ThinDiskPL self) -> vector_string
        """
        return _std.ThinDiskPL_plugins(self, *args)


    def isThreadSafe(self):
        """
        isThreadSafe(ThinDiskPL self) -> bool



        Whether this class is thread-safe.

        Return True if this object is thread-safe, i.e. if an instance and its
        clone can be used in parallel threads (in the context of
        Scenery::raytrace()). Known objects which are not thread-safe include
        Lorene metrics and everything from the Python plug-in.

        The default implementation considers that the class itself is thread
        safe and recurses into the declared properties to check whether they
        are safe too. Classes that abide to the Object/Property paradigm and
        are themselves thread-safe have nothing special to do.

        Objects that clone children in their copy constructor that are not
        declared as properties must take these children into account.

        Classes that are never thread-safe must declare it. It acn be easily
        done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
        GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. 
        """
        return _std.ThinDiskPL_isThreadSafe(self)


    def clone(self):
        """
        clone(ThinDiskPL self) -> ThinDiskPL



        Cloner. 
        """
        return _std.ThinDiskPL_clone(self)

    __swig_destroy__ = _std.delete_ThinDiskPL
    __del__ = lambda self: None

    def Slope(self, *args):
        """
        Slope(ThinDiskPL self, double arg2)
        Slope(ThinDiskPL self) -> double
        """
        return _std.ThinDiskPL_Slope(self, *args)


    def Tinner(self, *args):
        """
        Tinner(ThinDiskPL self, double arg2)
        Tinner(ThinDiskPL self) -> double
        """
        return _std.ThinDiskPL_Tinner(self, *args)


    def emission(self, *args):
        """
        emission(ThinDiskPL self, double nu_em, double dsem, vector_double coord_ph, double const [8] coord_obj=0) -> double
        emission(ThinDiskPL self, double nu_em, double dsem, vector_double coord_ph) -> double
        emission(ThinDiskPL self, double [] Inu, double const [] nu_em, size_t nbnu, double dsem, vector_double coord_ph, double const [8] coord_obj=0)
        emission(ThinDiskPL self, double [] Inu, double const [] nu_em, size_t nbnu, double dsem, vector_double coord_ph)
        emission(ThinDiskPL self, double nu_em, double dsem, vector_double c_ph, double const [8] c_obj=0) -> double
        emission(ThinDiskPL self, double nu_em, double dsem, vector_double c_ph) -> double



        Obsolete, update your code. 
        """
        return _std.ThinDiskPL_emission(self, *args)


    def __init__(self, *args):
        """
        __init__(Gyoto::Astrobj::ThinDiskPL self) -> ThinDiskPL
        __init__(Gyoto::Astrobj::ThinDiskPL self, ThinDiskPL arg2) -> ThinDiskPL
        __init__(Gyoto::Astrobj::ThinDiskPL self, Astrobj base) -> ThinDiskPL
        __init__(Gyoto::Astrobj::ThinDiskPL self, long address) -> ThinDiskPL



        Copy constructor. 
        """
        this = _std.new_ThinDiskPL(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
ThinDiskPL_swigregister = _std.ThinDiskPL_swigregister
ThinDiskPL_swigregister(ThinDiskPL)
ThinDiskPL.properties = _std.cvar.ThinDiskPL_properties
ThinDiskPL.builtinPluginValue = _std.cvar.ThinDiskPL_builtinPluginValue

class PolishDoughnut(gyoto.core.StandardAstrobj):
    """


    A toroidal accretion structure.

    Latest reference: Vincent, F. H.; Yan, W.; Straub, O.; Zdziarski, A.
    A.; Abramowicz, M. A. 2015, A magnetized torus for modeling
    Sagittarius A* millimeter images and spectra, A&A 574:A48.

    Reference: Straub, O.; Vincent, F. H.; Abramowicz, M. A.; Gourgoulhon,
    E.; & Paumard, T. 2012, Modelling the black hole silhouette in
    Sagittarius A* with ion tori, A&A 543:83.

    C++ includes: GyotoPolishDoughnut.h 
    """

    __swig_setmethods__ = {}
    for _s in [gyoto.core.StandardAstrobj]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PolishDoughnut, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.StandardAstrobj]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PolishDoughnut, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(PolishDoughnut self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.PolishDoughnut_getProperties(self)


    def plugins(self, *args):
        """
        plugins(PolishDoughnut self, vector_string plugname)
        plugins(PolishDoughnut self) -> vector_string
        """
        return _std.PolishDoughnut_plugins(self, *args)


    def isThreadSafe(self):
        """
        isThreadSafe(PolishDoughnut self) -> bool



        Whether this class is thread-safe.

        Return True if this object is thread-safe, i.e. if an instance and its
        clone can be used in parallel threads (in the context of
        Scenery::raytrace()). Known objects which are not thread-safe include
        Lorene metrics and everything from the Python plug-in.

        The default implementation considers that the class itself is thread
        safe and recurses into the declared properties to check whether they
        are safe too. Classes that abide to the Object/Property paradigm and
        are themselves thread-safe have nothing special to do.

        Objects that clone children in their copy constructor that are not
        declared as properties must take these children into account.

        Classes that are never thread-safe must declare it. It acn be easily
        done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
        GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. 
        """
        return _std.PolishDoughnut_isThreadSafe(self)


    def fillProperty(self, fmp, p):
        """
        fillProperty(PolishDoughnut self, FactoryMessenger fmp, Property p)



        Output a single Property to XML.

        The base implementation decides what to do based on the p.type. The
        format matches how setParameters() an setParameter() would interpret
        the XML descition.

        Overriding this method should be avoided, but makes sense in some
        cases (for instance Screen::fillProperty() selects a different unit
        for Distance based on its magnitude, so that stellar sizes are
        expressed in solar radii while smaller sizes can be expressed in
        meters and larger sizes in parsecs).

        Overriding implementation should fall-back on calling the
        implementation in the direct parent class: 
        """
        return _std.PolishDoughnut_fillProperty(self, fmp, p)


    def clone(self):
        """
        clone(PolishDoughnut self) -> PolishDoughnut



        Cloner.

        This method must be implemented by the various Astrobj::Generic
        subclasses in order to support cloning:

        Cloning is necessary for multi-threading, recommended for interaction
        with the Yorick plug-in etc.

        Implementing it is very straightforward, as long as the copy
        constructor Generic(const Generic& ) has been implemented: 
        """
        return _std.PolishDoughnut_clone(self)

    __swig_destroy__ = _std.delete_PolishDoughnut
    __del__ = lambda self: None

    def getL0(self):
        """
        getL0(PolishDoughnut self) -> double



        Get PolishDoughnut::l0_. 
        """
        return _std.PolishDoughnut_getL0(self)


    def _lambda(self, *args):
        """
        _lambda(PolishDoughnut self) -> double
        _lambda(PolishDoughnut self, double arg2)



        Set PolishDoughnut::lambda_. 
        """
        return _std.PolishDoughnut__lambda(self, *args)


    def centralEnthalpyPerUnitVolume(self, *args):
        """
        centralEnthalpyPerUnitVolume(PolishDoughnut self) -> double
        centralEnthalpyPerUnitVolume(PolishDoughnut self, std::string const & unit) -> double
        centralEnthalpyPerUnitVolume(PolishDoughnut self, double density)
        centralEnthalpyPerUnitVolume(PolishDoughnut self, double density, std::string const & unit)



        Set PolishDoughnut::central_enthalpy_cgs_ in specified unit. 
        """
        return _std.PolishDoughnut_centralEnthalpyPerUnitVolume(self, *args)


    def centralTemp(self, *args):
        """
        centralTemp(PolishDoughnut self) -> double
        centralTemp(PolishDoughnut self, double val)



        Set PolishDoughnut::central_temperature_. 
        """
        return _std.PolishDoughnut_centralTemp(self, *args)


    def beta(self, *args):
        """
        beta(PolishDoughnut self) -> double
        beta(PolishDoughnut self, double beta)



        Set PolishDoughnut::beta_. 
        """
        return _std.PolishDoughnut_beta(self, *args)


    def magnetizationParameter(self, *args):
        """
        magnetizationParameter(PolishDoughnut self, double rr)
        magnetizationParameter(PolishDoughnut self) -> double
        """
        return _std.PolishDoughnut_magnetizationParameter(self, *args)


    def spectralOversampling(self, *args):
        """
        spectralOversampling(PolishDoughnut self, size_t arg2)
        spectralOversampling(PolishDoughnut self) -> size_t



        Get PolishDoughnut::spectral_oversampling_. 
        """
        return _std.PolishDoughnut_spectralOversampling(self, *args)


    def changeCusp(self, *args):
        """
        changeCusp(PolishDoughnut self) -> bool
        changeCusp(PolishDoughnut self, bool t)



        Set PolishDoughnut::komissarov_. 
        """
        return _std.PolishDoughnut_changeCusp(self, *args)


    def bremsstrahlung(self, *args):
        """
        bremsstrahlung(PolishDoughnut self) -> bool
        bremsstrahlung(PolishDoughnut self, bool brems)



        Set PolishDoughnut::bremsstrahlung_. 
        """
        return _std.PolishDoughnut_bremsstrahlung(self, *args)


    def angleAveraged(self, *args):
        """
        angleAveraged(PolishDoughnut self) -> bool
        angleAveraged(PolishDoughnut self, bool komis)



        Set PolishDoughnut::angle_averaged_. 
        """
        return _std.PolishDoughnut_angleAveraged(self, *args)


    def nonThermalDeltaExpo(self, *args):
        """
        nonThermalDeltaExpo(PolishDoughnut self, vector_double v)
        nonThermalDeltaExpo(PolishDoughnut self) -> vector_double
        """
        return _std.PolishDoughnut_nonThermalDeltaExpo(self, *args)


    def angmomrinner(self, *args):
        """
        angmomrinner(PolishDoughnut self, vector_double v)
        angmomrinner(PolishDoughnut self) -> vector_double
        """
        return _std.PolishDoughnut_angmomrinner(self, *args)


    def adafparams(self, *args):
        """
        adafparams(PolishDoughnut self, vector_double v)
        adafparams(PolishDoughnut self) -> vector_double
        """
        return _std.PolishDoughnut_adafparams(self, *args)


    def adaf(self, *args):
        """
        adaf(PolishDoughnut self, bool t)
        adaf(PolishDoughnut self) -> bool
        """
        return _std.PolishDoughnut_adaf(self, *args)


    def setParameter(self, p, name, content, unit):
        """
        setParameter(PolishDoughnut self, Property p, std::string const & name, std::string const & content, std::string const & unit)



        Set parameter by name.

        This function is used when parsing an XML description, if no Property
        of this name is found. Overriding implementation should fall-back on
        calling the direct's parent implementation:

        Parameters:
        -----------

        name:  XML name of the parameter (XML entity). This may have a path
        component, e.g. "Astrobj::Radius", in which case a property named
        "Astrobj" will be sought in the current object, and setParameter
        will be called recusrively on this Astrobj with Radius as name.

        content:  string representation of the value

        unit:  string representation of the unit

        0 if this parameter is known, 1 if it is not. 
        """
        return _std.PolishDoughnut_setParameter(self, p, name, content, unit)


    def getWsurface(self):
        """
        getWsurface(PolishDoughnut self) -> double



        Get PolishDoughnut::W_surface_. 
        """
        return _std.PolishDoughnut_getWsurface(self)


    def getWcentre(self):
        """
        getWcentre(PolishDoughnut self) -> double



        Get PolishDoughnut::W_centre_. 
        """
        return _std.PolishDoughnut_getWcentre(self)


    def getRcusp(self):
        """
        getRcusp(PolishDoughnut self) -> double



        Get PolishDoughnut::r_cusp_. 
        """
        return _std.PolishDoughnut_getRcusp(self)


    def getRcentre(self):
        """
        getRcentre(PolishDoughnut self) -> double



        Get PolishDoughnut::r_centre_. 
        """
        return _std.PolishDoughnut_getRcentre(self)


    def metric(self, *args):
        """
        metric(PolishDoughnut self) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >
        metric(PolishDoughnut self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)



        Get the Metric gg_. 
        """
        return _std.PolishDoughnut_metric(self, *args)


    def Impact(self, ph, index, data):
        """
        Impact(PolishDoughnut self, Photon ph, size_t index, AstrobjProperties data) -> int



        Does a photon at these coordinates impact the object?

        Impact() checks whether a Photon impacts the object between two
        integration steps of the photon's trajectory (those two steps are
        photon->getCoord(index, coord1) and photon->getCoord(index+1,
        coord2)). Impact returns 1 if the photon impacts the object between
        these two steps, else 0. In many cases of geometrically thick obects,
        the implementation Astrobj::Standard::Impact() will be fine.

        Impact will call Generic::processHitQuantities() (which is virtual and
        may be re-implemented) to compute observable properties on demand: if
        the data pointer is non-NULL, the object will look in it for pointers
        to properties which apply to its kind. If a pointer to a property
        known to this object is present, then the property is computed and
        store at the pointed-to address. For instance, all objects know the
        "intensity" property. If data->intensity != NULL, the instensity is
        computed and stored in *data->intensity.

        If data is non-NULL and only in this case, processHitQuantities() will
        also call ph->transmit() to update the transmissions of the Photon
        (see Photon::transmit(size_t, double)). This must not be done if data
        is NULL (see Astrobj::Complex::Impact() for an explanation).

        Impact() may not extend the ph Worldline. The only two dates that are
        guaranteed to be defined are at indices index and index+1.

        Parameters:
        -----------

        ph:   Gyoto::Photon aimed at the object;

        index:  Index of the last photon step;

        data:  Pointer to a structure to hold the observables at impact.

        1 if impact, 0 if not. 
        """
        return _std.PolishDoughnut_Impact(self, ph, index, data)


    def __call__(self, coord):
        """__call__(PolishDoughnut self, double const [4] coord) -> double"""
        return _std.PolishDoughnut___call__(self, coord)


    def __init__(self, *args):
        """
        __init__(Gyoto::Astrobj::PolishDoughnut self) -> PolishDoughnut
        __init__(Gyoto::Astrobj::PolishDoughnut self, PolishDoughnut arg2) -> PolishDoughnut
        __init__(Gyoto::Astrobj::PolishDoughnut self, Astrobj base) -> PolishDoughnut
        __init__(Gyoto::Astrobj::PolishDoughnut self, long address) -> PolishDoughnut



        Copy constructor. 
        """
        this = _std.new_PolishDoughnut(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
PolishDoughnut_swigregister = _std.PolishDoughnut_swigregister
PolishDoughnut_swigregister(PolishDoughnut)
PolishDoughnut.properties = _std.cvar.PolishDoughnut_properties
PolishDoughnut.builtinPluginValue = _std.cvar.PolishDoughnut_builtinPluginValue

class ThinDiskIronLine(gyoto.core.ThinDisk):
    """Proxy of C++ Gyoto::Astrobj::ThinDiskIronLine class."""

    __swig_setmethods__ = {}
    for _s in [gyoto.core.ThinDisk]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ThinDiskIronLine, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.ThinDisk]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ThinDiskIronLine, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(ThinDiskIronLine self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.ThinDiskIronLine_getProperties(self)


    def plugins(self, *args):
        """
        plugins(ThinDiskIronLine self, vector_string plugname)
        plugins(ThinDiskIronLine self) -> vector_string
        """
        return _std.ThinDiskIronLine_plugins(self, *args)

    __swig_destroy__ = _std.delete_ThinDiskIronLine
    __del__ = lambda self: None

    def clone(self):
        """
        clone(ThinDiskIronLine self) -> ThinDiskIronLine



        Cloner.

        This method must be implemented by the various Astrobj::Generic
        subclasses in order to support cloning:

        Cloning is necessary for multi-threading, recommended for interaction
        with the Yorick plug-in etc.

        Implementing it is very straightforward, as long as the copy
        constructor Generic(const Generic& ) has been implemented: 
        """
        return _std.ThinDiskIronLine_clone(self)


    def emission(self, *args):
        """
        emission(ThinDiskIronLine self, double nu_em, double dsem, vector_double coord_ph, double const [8] coord_obj=0) -> double
        emission(ThinDiskIronLine self, double nu_em, double dsem, vector_double coord_ph) -> double
        emission(ThinDiskIronLine self, double [] Inu, double const [] nu_em, size_t nbnu, double dsem, vector_double coord_ph, double const [8] coord_obj=0)
        emission(ThinDiskIronLine self, double [] Inu, double const [] nu_em, size_t nbnu, double dsem, vector_double coord_ph)
        emission(ThinDiskIronLine self, double nu_em, double dsem, vector_double c_ph, double const [8] c_obj=0) -> double
        emission(ThinDiskIronLine self, double nu_em, double dsem, vector_double c_ph) -> double



        Obsolete, update your code. 
        """
        return _std.ThinDiskIronLine_emission(self, *args)


    def getVelocity(self, pos, vel):
        """
        getVelocity(ThinDiskIronLine self, double const [4] pos, double [4] vel)



        Get fluid 4-velocity at point.

        Fill vel with the 4-vector velocity of the fluid at 4-position pos.
        getVelocity() should work at some distance from the equatorial plane.
        The default implementation calls Metric::Generic::circularVelocity().

        Parameters:
        -----------

        pos:  4-position at which to compute velocity;

        vel:  4-velocity at pos. 
        """
        return _std.ThinDiskIronLine_getVelocity(self, pos, vel)


    def PowerLawIndex(self, *args):
        """
        PowerLawIndex(ThinDiskIronLine self, double arg2)
        PowerLawIndex(ThinDiskIronLine self) -> double
        """
        return _std.ThinDiskIronLine_PowerLawIndex(self, *args)


    def LineFreq(self, *args):
        """
        LineFreq(ThinDiskIronLine self, double arg2)
        LineFreq(ThinDiskIronLine self) -> double
        LineFreq(ThinDiskIronLine self, double v, std::string const & u)
        LineFreq(ThinDiskIronLine self, std::string const & u) -> double
        """
        return _std.ThinDiskIronLine_LineFreq(self, *args)


    def CutRadius(self, *args):
        """
        CutRadius(ThinDiskIronLine self, double arg2)
        CutRadius(ThinDiskIronLine self) -> double
        CutRadius(ThinDiskIronLine self, double v, std::string const & u)
        CutRadius(ThinDiskIronLine self, std::string const & u) -> double
        """
        return _std.ThinDiskIronLine_CutRadius(self, *args)


    def __init__(self, *args):
        """
        __init__(Gyoto::Astrobj::ThinDiskIronLine self) -> ThinDiskIronLine
        __init__(Gyoto::Astrobj::ThinDiskIronLine self, ThinDiskIronLine o) -> ThinDiskIronLine
        __init__(Gyoto::Astrobj::ThinDiskIronLine self, Astrobj base) -> ThinDiskIronLine
        __init__(Gyoto::Astrobj::ThinDiskIronLine self, long address) -> ThinDiskIronLine
        """
        this = _std.new_ThinDiskIronLine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
ThinDiskIronLine_swigregister = _std.ThinDiskIronLine_swigregister
ThinDiskIronLine_swigregister(ThinDiskIronLine)
ThinDiskIronLine.properties = _std.cvar.ThinDiskIronLine_properties
ThinDiskIronLine.builtinPluginValue = _std.cvar.ThinDiskIronLine_builtinPluginValue

class PatternDisk(gyoto.core.ThinDisk):
    """


    Geometrically thin disk read from FITS file.

    This class describes a disk contained in the z=0 (equatorial) plane,
    extending from r=r_ISCO to r=infinity. The flux emitted at radius r
    and longitude phi at frequency nu is given in a FITS file.

    C++ includes: GyotoPatternDisk.h 
    """

    __swig_setmethods__ = {}
    for _s in [gyoto.core.ThinDisk]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PatternDisk, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.ThinDisk]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PatternDisk, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(PatternDisk self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.PatternDisk_getProperties(self)


    def plugins(self, *args):
        """
        plugins(PatternDisk self, vector_string plugname)
        plugins(PatternDisk self) -> vector_string
        """
        return _std.PatternDisk_plugins(self, *args)


    def fillProperty(self, fmp, p):
        """
        fillProperty(PatternDisk self, FactoryMessenger fmp, Property p)



        Output a single Property to XML.

        The base implementation decides what to do based on the p.type. The
        format matches how setParameters() an setParameter() would interpret
        the XML descition.

        Overriding this method should be avoided, but makes sense in some
        cases (for instance Screen::fillProperty() selects a different unit
        for Distance based on its magnitude, so that stellar sizes are
        expressed in solar radii while smaller sizes can be expressed in
        meters and larger sizes in parsecs).

        Overriding implementation should fall-back on calling the
        implementation in the direct parent class: 
        """
        return _std.PatternDisk_fillProperty(self, fmp, p)


    def clone(self):
        """
        clone(PatternDisk self) -> PatternDisk



        Cloner. 
        """
        return _std.PatternDisk_clone(self)

    __swig_destroy__ = _std.delete_PatternDisk
    __del__ = lambda self: None

    def innerRadius(self, *args):
        """
        innerRadius(PatternDisk self) -> double
        innerRadius(PatternDisk self, std::string const & arg2) -> double
        innerRadius(PatternDisk self, double arg2, std::string const & arg3)
        innerRadius(PatternDisk self, double arg2)



        Set rin_. 
        """
        return _std.PatternDisk_innerRadius(self, *args)


    def outerRadius(self, *args):
        """
        outerRadius(PatternDisk self) -> double
        outerRadius(PatternDisk self, std::string const & arg2) -> double
        outerRadius(PatternDisk self, double arg2, std::string const & arg3)
        outerRadius(PatternDisk self, double arg2)



        Set rout_. 
        """
        return _std.PatternDisk_outerRadius(self, *args)


    def patternVelocity(self, *args):
        """
        patternVelocity(PatternDisk self, double arg2)
        patternVelocity(PatternDisk self) -> double



        Get PatternDisk::Omega_. 
        """
        return _std.PatternDisk_patternVelocity(self, *args)


    def file(self, *args):
        """
        file(PatternDisk self, std::string const & f)
        file(PatternDisk self) -> std::string
        """
        return _std.PatternDisk_file(self, *args)


    def fitsRead(self, filename_):
        """fitsRead(PatternDisk self, std::string filename_)"""
        return _std.PatternDisk_fitsRead(self, filename_)


    def fitsWrite(self, filename_):
        """fitsWrite(PatternDisk self, std::string filename_)"""
        return _std.PatternDisk_fitsWrite(self, filename_)


    def setEmission(self, pattern):
        """
        setEmission(PatternDisk self, double * pattern)



        Set PatternDisk::emission_.

        The pointer is copied directly, not the array content.

        This is a low-level function. Beware that: previously allocated array
        will not be freed automatically;

        array attached when the destructor is called will be freed. 
        """
        return _std.PatternDisk_setEmission(self, pattern)


    def setVelocity(self, pattern):
        """
        setVelocity(PatternDisk self, double * pattern)



        Set PatternDisk::velocity__.

        The pointer is copied directly, not the array content.

        This is a low-level function. Beware that: previously allocated array
        will not be freed automatically;

        array attached when the destructor is called will be freed. 
        """
        return _std.PatternDisk_setVelocity(self, pattern)


    def radius(self, pattern):
        """
        radius(PatternDisk self, double * pattern)



        Set PatternDisk::radius_.

        The pointer is copied directly, not the array content.

        This is a low-level function. Beware that: previously allocated array
        will not be freed automatically;

        array attached when the destructor is called will be freed. 
        """
        return _std.PatternDisk_radius(self, pattern)


    def copyIntensity(self, pattern=None, naxes=0):
        """
        copyIntensity(PatternDisk self, double const *const pattern=None, size_t const [3] naxes=0)
        copyIntensity(PatternDisk self, double const *const pattern=None)
        copyIntensity(PatternDisk self)



        Set PatternDisk::emission_.

        PatternDisk::emission_ is freed if not NULL, reallocated, and pattern
        is copied into emission_.

        If PatternDisk::opacity_, PatternDisk::velocity_ or
        PatternDisk::radius_ have been set previously with mismatching sizes,
        they are deallocated too.

        Finally, PatternDisk::nnu_, PatternDisk::nphi_, and PatternDisk::nr_
        are set according to naxes.

        Parameters:
        -----------

        pattern:  Array to copy as emission_. May be NULL in which case
        emission_ is simply deallocated and set to NULL.

        naxes:  { nnu_, nphi_, nr_ }. 
        """
        return _std.PatternDisk_copyIntensity(self, pattern, naxes)


    def getIntensity(self):
        """
        getIntensity(PatternDisk self) -> double const *



        Get PatternDisk::emission_. 
        """
        return _std.PatternDisk_getIntensity(self)


    def getIntensityNaxes(self, naxes):
        """
        getIntensityNaxes(PatternDisk self, size_t [3] naxes)



        Get PatternDisk::nnu_, PatternDisk::nphi_, and PatternDisk::nr_. 
        """
        return _std.PatternDisk_getIntensityNaxes(self, naxes)


    def copyOpacity(self, pattern=None, naxes=0):
        """
        copyOpacity(PatternDisk self, double const *const pattern=None, size_t const [3] naxes=0)
        copyOpacity(PatternDisk self, double const *const pattern=None)
        copyOpacity(PatternDisk self)



        Set PatternDisk::opacity_.

        PatternDisk::opacity_ is first freed if not NULL and set to NULL.

        If pattern is not NULL, PatternDisk::emission_ must have been set
        previously with matching dimensions. PatternDisk::opacity_ is then
        reallocated, and pattern is copied into opacity_.

        Parameters:
        -----------

        pattern:  Array to copy as opacity_. May be NULL in which case
        opacity_ is simply deallocated and set to NULL.

        naxes:  { nnu_, nphi_, nr_ }. 
        """
        return _std.PatternDisk_copyOpacity(self, pattern, naxes)


    def opacity(self):
        """
        opacity(PatternDisk self) -> double const *



        Get PatternDisk::opacity_. 
        """
        return _std.PatternDisk_opacity(self)


    def copyVelocity(self, pattern=None, naxes=0):
        """
        copyVelocity(PatternDisk self, double const *const pattern=None, size_t const [2] naxes=0)
        copyVelocity(PatternDisk self, double const *const pattern=None)
        copyVelocity(PatternDisk self)



        Set PatternDisk::velocity_.

        PatternDisk::velocity_ is first freed if not NULL and set to NULL.

        If pattern is not NULL, PatternDisk::emission_ must have been set
        previously with matching dimensions. PatternDisk::velocity_ is then
        reallocated, and pattern is copied into velocity_.

        Parameters:
        -----------

        pattern:  Array to copy as velocity_. May be NULL in which case
        velocity_ is simply deallocated and set to NULL.

        naxes:  { nphi_, nr_ }. 
        """
        return _std.PatternDisk_copyVelocity(self, pattern, naxes)


    def copyGridRadius(self, pattern=None, nr=0):
        """
        copyGridRadius(PatternDisk self, double const *const pattern=None, size_t nr=0)
        copyGridRadius(PatternDisk self, double const *const pattern=None)
        copyGridRadius(PatternDisk self)



        Set PatternDisk::radius_.

        PatternDisk::radius_ is first freed if not NULL and set to NULL.

        If pattern is not NULL, PatternDisk::emission_ must have been set
        previously with matching dimensions. PatternDisk::radius_ is then
        reallocated, and pattern is copied into radius_.

        Parameters:
        -----------

        pattern:  Array to copy as radius_. May be NULL in which case radius_
        is simply deallocated and set to NULL.

        nr:  size of radius array. 
        """
        return _std.PatternDisk_copyGridRadius(self, pattern, nr)


    def getGridRadius(self):
        """
        getGridRadius(PatternDisk self) -> double const *



        Get PatternDisk::radius_. 
        """
        return _std.PatternDisk_getGridRadius(self)


    def repeatPhi(self, *args):
        """
        repeatPhi(PatternDisk self, size_t n)
        repeatPhi(PatternDisk self) -> size_t



        Get PatternDisk::repeat_phi_. 
        """
        return _std.PatternDisk_repeatPhi(self, *args)


    def nu0(self, *args):
        """
        nu0(PatternDisk self, double freq)
        nu0(PatternDisk self) -> double



        Get PatternDisk::nu0_. 
        """
        return _std.PatternDisk_nu0(self, *args)


    def dnu(self, *args):
        """
        dnu(PatternDisk self, double dfreq)
        dnu(PatternDisk self) -> double



        Get PatternDisk::dnu_. 
        """
        return _std.PatternDisk_dnu(self, *args)


    def phimin(self, *args):
        """
        phimin(PatternDisk self, double phimin)
        phimin(PatternDisk self) -> double



        Get PatternDisk::phimin_. 
        """
        return _std.PatternDisk_phimin(self, *args)


    def phimax(self, *args):
        """
        phimax(PatternDisk self, double phimax)
        phimax(PatternDisk self) -> double



        Get PatternDisk::phimax_. 
        """
        return _std.PatternDisk_phimax(self, *args)


    def emission(self, *args):
        """
        emission(PatternDisk self, double nu_em, double dsem, vector_double coord_ph, double const [8] coord_obj=0) -> double
        emission(PatternDisk self, double nu_em, double dsem, vector_double coord_ph) -> double
        emission(PatternDisk self, double [] Inu, double const [] nu_em, size_t nbnu, double dsem, vector_double coord_ph, double const [8] coord_obj=0)
        emission(PatternDisk self, double [] Inu, double const [] nu_em, size_t nbnu, double dsem, vector_double coord_ph)
        emission(PatternDisk self, double nu_em, double dsem, vector_double c_ph, double const [8] c_obj=0) -> double
        emission(PatternDisk self, double nu_em, double dsem, vector_double c_ph) -> double



        Obsolete, update your code. 
        """
        return _std.PatternDisk_emission(self, *args)


    def transmission(self, nu_em, dsem, arg4, coord):
        """
        transmission(PatternDisk self, double nu_em, double dsem, vector_double arg4, double const [8] coord) -> double



        Obsolete, update your code. 
        """
        return _std.PatternDisk_transmission(self, nu_em, dsem, arg4, coord)


    def getVelocity(self, *args):
        """
        getVelocity(PatternDisk self) -> double const
        getVelocity(PatternDisk self, double const [4] pos, double [4] vel)



        Get fluid 4-velocity at point.

        Fill vel with the 4-vector velocity of the fluid at 4-position pos.
        getVelocity() should work at some distance from the equatorial plane.
        The default implementation calls Metric::Generic::circularVelocity().

        Parameters:
        -----------

        pos:  4-position at which to compute velocity;

        vel:  4-velocity at pos. 
        """
        return _std.PatternDisk_getVelocity(self, *args)


    def __init__(self, *args):
        """
        __init__(Gyoto::Astrobj::PatternDisk self) -> PatternDisk
        __init__(Gyoto::Astrobj::PatternDisk self, PatternDisk arg2) -> PatternDisk
        __init__(Gyoto::Astrobj::PatternDisk self, Astrobj base) -> PatternDisk
        __init__(Gyoto::Astrobj::PatternDisk self, long address) -> PatternDisk



        Copy constructor. 
        """
        this = _std.new_PatternDisk(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
PatternDisk_swigregister = _std.PatternDisk_swigregister
PatternDisk_swigregister(PatternDisk)
PatternDisk.properties = _std.cvar.PatternDisk_properties
PatternDisk.builtinPluginValue = _std.cvar.PatternDisk_builtinPluginValue

class PatternDiskBB(PatternDisk):
    """


    Geometrically thin disk read from FITS file with black body spectrum.

    This class describes a disk contained in the z=0 (equatorial) plane,
    extending from r=r_ISCO to r=rmax_. The flux emitted at radius r and
    longitude phi at frequency nu is given in a FITS file.

    C++ includes: GyotoPatternDiskBB.h 
    """

    __swig_setmethods__ = {}
    for _s in [PatternDisk]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PatternDiskBB, name, value)
    __swig_getmethods__ = {}
    for _s in [PatternDisk]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PatternDiskBB, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(PatternDiskBB self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.PatternDiskBB_getProperties(self)


    def plugins(self, *args):
        """
        plugins(PatternDiskBB self, vector_string plugname)
        plugins(PatternDiskBB self) -> vector_string
        """
        return _std.PatternDiskBB_plugins(self, *args)


    def isThreadSafe(self):
        """
        isThreadSafe(PatternDiskBB self) -> bool



        Whether this class is thread-safe.

        Return True if this object is thread-safe, i.e. if an instance and its
        clone can be used in parallel threads (in the context of
        Scenery::raytrace()). Known objects which are not thread-safe include
        Lorene metrics and everything from the Python plug-in.

        The default implementation considers that the class itself is thread
        safe and recurses into the declared properties to check whether they
        are safe too. Classes that abide to the Object/Property paradigm and
        are themselves thread-safe have nothing special to do.

        Objects that clone children in their copy constructor that are not
        declared as properties must take these children into account.

        Classes that are never thread-safe must declare it. It acn be easily
        done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
        GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. 
        """
        return _std.PatternDiskBB_isThreadSafe(self)


    def clone(self):
        """
        clone(PatternDiskBB self) -> PatternDiskBB



        Cloner. 
        """
        return _std.PatternDiskBB_clone(self)

    __swig_destroy__ = _std.delete_PatternDiskBB
    __del__ = lambda self: None

    def spectralEmission(self, *args):
        """
        spectralEmission(PatternDiskBB self) -> bool
        spectralEmission(PatternDiskBB self, bool t)
        """
        return _std.PatternDiskBB_spectralEmission(self, *args)


    def emission(self, *args):
        """
        emission(PatternDiskBB self, double nu_em, double dsem, vector_double coord_ph, double const [8] coord_obj=0) -> double
        emission(PatternDiskBB self, double nu_em, double dsem, vector_double coord_ph) -> double
        emission(PatternDiskBB self, double [] Inu, double const [] nu_em, size_t nbnu, double dsem, vector_double coord_ph, double const [8] coord_obj=0)
        emission(PatternDiskBB self, double [] Inu, double const [] nu_em, size_t nbnu, double dsem, vector_double coord_ph)
        emission(PatternDiskBB self, double nu_em, double dsem, vector_double c_ph, double const [8] c_obj=0) -> double
        emission(PatternDiskBB self, double nu_em, double dsem, vector_double c_ph) -> double



        Obsolete, update your code. 
        """
        return _std.PatternDiskBB_emission(self, *args)


    def __init__(self, *args):
        """
        __init__(Gyoto::Astrobj::PatternDiskBB self) -> PatternDiskBB
        __init__(Gyoto::Astrobj::PatternDiskBB self, PatternDiskBB arg2) -> PatternDiskBB
        __init__(Gyoto::Astrobj::PatternDiskBB self, Astrobj base) -> PatternDiskBB
        __init__(Gyoto::Astrobj::PatternDiskBB self, long address) -> PatternDiskBB



        Copy constructor. 
        """
        this = _std.new_PatternDiskBB(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
PatternDiskBB_swigregister = _std.PatternDiskBB_swigregister
PatternDiskBB_swigregister(PatternDiskBB)
PatternDiskBB.properties = _std.cvar.PatternDiskBB_properties
PatternDiskBB.builtinPluginValue = _std.cvar.PatternDiskBB_builtinPluginValue

class DynamicalDisk(PatternDiskBB):
    """


    Geometrically thin disk read from a set of FITS files.

    This class describes a PatternDiskBB that evolves dynamically. It is
    described by a set of FITS files.

    C++ includes: GyotoDynamicalDisk.h 
    """

    __swig_setmethods__ = {}
    for _s in [PatternDiskBB]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DynamicalDisk, name, value)
    __swig_getmethods__ = {}
    for _s in [PatternDiskBB]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DynamicalDisk, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(DynamicalDisk self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.DynamicalDisk_getProperties(self)


    def plugins(self, *args):
        """
        plugins(DynamicalDisk self, vector_string plugname)
        plugins(DynamicalDisk self) -> vector_string
        """
        return _std.DynamicalDisk_plugins(self, *args)


    def clone(self):
        """
        clone(DynamicalDisk self) -> DynamicalDisk



        Cloner. 
        """
        return _std.DynamicalDisk_clone(self)

    __swig_destroy__ = _std.delete_DynamicalDisk
    __del__ = lambda self: None

    def file(self, *args):
        """
        file(DynamicalDisk self) -> std::string
        file(DynamicalDisk self, std::string const & fname)
        """
        return _std.DynamicalDisk_file(self, *args)


    def tinit(self, *args):
        """
        tinit(DynamicalDisk self, double t)
        tinit(DynamicalDisk self) -> double
        """
        return _std.DynamicalDisk_tinit(self, *args)


    def dt(self, *args):
        """
        dt(DynamicalDisk self, double t)
        dt(DynamicalDisk self) -> double
        """
        return _std.DynamicalDisk_dt(self, *args)


    def fillProperty(self, fmp, p):
        """
        fillProperty(DynamicalDisk self, FactoryMessenger fmp, Property p)



        Output a single Property to XML.

        The base implementation decides what to do based on the p.type. The
        format matches how setParameters() an setParameter() would interpret
        the XML descition.

        Overriding this method should be avoided, but makes sense in some
        cases (for instance Screen::fillProperty() selects a different unit
        for Distance based on its magnitude, so that stellar sizes are
        expressed in solar radii while smaller sizes can be expressed in
        meters and larger sizes in parsecs).

        Overriding implementation should fall-back on calling the
        implementation in the direct parent class: 
        """
        return _std.DynamicalDisk_fillProperty(self, fmp, p)


    def emission(self, *args):
        """
        emission(DynamicalDisk self, double nu_em, double dsem, vector_double coord_ph, double const [8] coord_obj=0) -> double
        emission(DynamicalDisk self, double nu_em, double dsem, vector_double coord_ph) -> double
        emission(DynamicalDisk self, double [] Inu, double const [] nu_em, size_t nbnu, double dsem, vector_double coord_ph, double const [8] coord_obj=0)
        emission(DynamicalDisk self, double [] Inu, double const [] nu_em, size_t nbnu, double dsem, vector_double coord_ph)
        emission(DynamicalDisk self, double nu_em, double dsem, vector_double c_ph, double const [8] c_obj=0) -> double
        emission(DynamicalDisk self, double nu_em, double dsem, vector_double c_ph) -> double



        Obsolete, update your code. 
        """
        return _std.DynamicalDisk_emission(self, *args)


    def getVelocity(self, *args):
        """
        getVelocity(DynamicalDisk self, double const [4] pos, double [4] vel)
        getVelocity(DynamicalDisk self) -> double const *



        Get PatternDisk::velocity_. 
        """
        return _std.DynamicalDisk_getVelocity(self, *args)


    def __init__(self, *args):
        """
        __init__(Gyoto::Astrobj::DynamicalDisk self) -> DynamicalDisk
        __init__(Gyoto::Astrobj::DynamicalDisk self, DynamicalDisk arg2) -> DynamicalDisk
        __init__(Gyoto::Astrobj::DynamicalDisk self, Astrobj base) -> DynamicalDisk
        __init__(Gyoto::Astrobj::DynamicalDisk self, long address) -> DynamicalDisk



        Copy constructor. 
        """
        this = _std.new_DynamicalDisk(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
DynamicalDisk_swigregister = _std.DynamicalDisk_swigregister
DynamicalDisk_swigregister(DynamicalDisk)
DynamicalDisk.properties = _std.cvar.DynamicalDisk_properties
DynamicalDisk.builtinPluginValue = _std.cvar.DynamicalDisk_builtinPluginValue

class DynamicalDiskBolometric(DynamicalDisk):
    """


    Geometrically thin disk read from a set of FITS files.

    This class describes a PatternDiskBB that evolves dynamically. It is
    described by a set of FITS files.

    C++ includes: GyotoDynamicalDiskBolometric.h 
    """

    __swig_setmethods__ = {}
    for _s in [DynamicalDisk]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DynamicalDiskBolometric, name, value)
    __swig_getmethods__ = {}
    for _s in [DynamicalDisk]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DynamicalDiskBolometric, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(DynamicalDiskBolometric self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.DynamicalDiskBolometric_getProperties(self)


    def plugins(self, *args):
        """
        plugins(DynamicalDiskBolometric self, vector_string plugname)
        plugins(DynamicalDiskBolometric self) -> vector_string
        """
        return _std.DynamicalDiskBolometric_plugins(self, *args)


    def clone(self):
        """
        clone(DynamicalDiskBolometric self) -> DynamicalDiskBolometric



        Cloner. 
        """
        return _std.DynamicalDiskBolometric_clone(self)

    __swig_destroy__ = _std.delete_DynamicalDiskBolometric
    __del__ = lambda self: None

    def emission(self, nu_em, dsem, arg4, coord_obj):
        """
        emission(DynamicalDiskBolometric self, double nu_em, double dsem, vector_double arg4, double const [8] coord_obj) -> double



        Obsolete, update your code. 
        """
        return _std.DynamicalDiskBolometric_emission(self, nu_em, dsem, arg4, coord_obj)


    def bolometricEmission(self, dsem, cph, coord_obj):
        """bolometricEmission(DynamicalDiskBolometric self, double dsem, vector_double cph, double const [8] coord_obj) -> double"""
        return _std.DynamicalDiskBolometric_bolometricEmission(self, dsem, cph, coord_obj)


    def processHitQuantities(self, ph, coord_ph_hit, coord_obj_hit, dt, data):
        """processHitQuantities(DynamicalDiskBolometric self, Photon ph, vector_double coord_ph_hit, double const * coord_obj_hit, double dt, AstrobjProperties data)"""
        return _std.DynamicalDiskBolometric_processHitQuantities(self, ph, coord_ph_hit, coord_obj_hit, dt, data)


    def __init__(self, *args):
        """
        __init__(Gyoto::Astrobj::DynamicalDiskBolometric self) -> DynamicalDiskBolometric
        __init__(Gyoto::Astrobj::DynamicalDiskBolometric self, DynamicalDiskBolometric arg2) -> DynamicalDiskBolometric
        __init__(Gyoto::Astrobj::DynamicalDiskBolometric self, Astrobj base) -> DynamicalDiskBolometric
        __init__(Gyoto::Astrobj::DynamicalDiskBolometric self, long address) -> DynamicalDiskBolometric



        Copy constructor. 
        """
        this = _std.new_DynamicalDiskBolometric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
DynamicalDiskBolometric_swigregister = _std.DynamicalDiskBolometric_swigregister
DynamicalDiskBolometric_swigregister(DynamicalDiskBolometric)
DynamicalDiskBolometric.properties = _std.cvar.DynamicalDiskBolometric_properties
DynamicalDiskBolometric.builtinPluginValue = _std.cvar.DynamicalDiskBolometric_builtinPluginValue

class Disk3D(gyoto.core.Astrobj):
    """


    Geometrically thick disk read from FITS file.

    This class is the base class for thick disks. The emitter's velocity
    is given in a FITS file, together with emission related quantity
    (typically temperature). This class mainly implements the Impact()
    function. Emission() function is here left to its default, and should
    be implemented according to specific needs in heir classes. Here the
    disk is supposed not to evolve in time. The dynamical treatment is
    provided in heir classes.

    The 3D disk is assumed to be described by a regular (non adaptive)
    grid of cylindrical geometry. The disk is a slab from rin_ to rout_
    and zmin_ (typically = -zmax_) to zmax_.

    C++ includes: GyotoDisk3D.h 
    """

    __swig_setmethods__ = {}
    for _s in [gyoto.core.Astrobj]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Disk3D, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.Astrobj]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Disk3D, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(Disk3D self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.Disk3D_getProperties(self)


    def plugins(self, *args):
        """
        plugins(Disk3D self, vector_string plugname)
        plugins(Disk3D self) -> vector_string
        """
        return _std.Disk3D_plugins(self, *args)


    def fillProperty(self, fmp, p):
        """
        fillProperty(Disk3D self, FactoryMessenger fmp, Property p)



        Output a single Property to XML.

        The base implementation decides what to do based on the p.type. The
        format matches how setParameters() an setParameter() would interpret
        the XML descition.

        Overriding this method should be avoided, but makes sense in some
        cases (for instance Screen::fillProperty() selects a different unit
        for Distance based on its magnitude, so that stellar sizes are
        expressed in solar radii while smaller sizes can be expressed in
        meters and larger sizes in parsecs).

        Overriding implementation should fall-back on calling the
        implementation in the direct parent class: 
        """
        return _std.Disk3D_fillProperty(self, fmp, p)


    def clone(self):
        """
        clone(Disk3D self) -> Disk3D



        Cloner. 
        """
        return _std.Disk3D_clone(self)

    __swig_destroy__ = _std.delete_Disk3D
    __del__ = lambda self: None

    def fitsRead(self, filename_):
        """fitsRead(Disk3D self, std::string filename_)"""
        return _std.Disk3D_fitsRead(self, filename_)


    def fitsWrite(self, filename_):
        """fitsWrite(Disk3D self, std::string filename_)"""
        return _std.Disk3D_fitsWrite(self, filename_)


    def file(self, *args):
        """
        file(Disk3D self, std::string const & f)
        file(Disk3D self) -> std::string
        """
        return _std.Disk3D_file(self, *args)


    def zsym(self, *args):
        """
        zsym(Disk3D self, bool t)
        zsym(Disk3D self) -> bool
        """
        return _std.Disk3D_zsym(self, *args)


    def tPattern(self, *args):
        """
        tPattern(Disk3D self, double t)
        tPattern(Disk3D self) -> double
        """
        return _std.Disk3D_tPattern(self, *args)


    def omegaPattern(self, *args):
        """
        omegaPattern(Disk3D self, double t)
        omegaPattern(Disk3D self) -> double
        """
        return _std.Disk3D_omegaPattern(self, *args)


    def setEmissquant(self, pattern):
        """
        setEmissquant(Disk3D self, double * pattern)



        Set Disk3D::emissquant_.

        The pointer is copied directly, not the array content.

        This is a low-level function. Beware that: previously allocated array
        will not be freed automatically;

        array attached when the destructor is called will be freed. 
        """
        return _std.Disk3D_setEmissquant(self, pattern)


    def setVelocity(self, pattern):
        """
        setVelocity(Disk3D self, double * pattern)



        Set Disk3D::velocity__.

        The pointer is copied directly, not the array content.

        This is a low-level function. Beware that: previously allocated array
        will not be freed automatically;

        array attached when the destructor is called will be freed. 
        """
        return _std.Disk3D_setVelocity(self, pattern)


    def copyEmissquant(self, pattern=None, naxes=0):
        """
        copyEmissquant(Disk3D self, double const *const pattern=None, size_t const [4] naxes=0)
        copyEmissquant(Disk3D self, double const *const pattern=None)
        copyEmissquant(Disk3D self)



        Set Disk3D::emissquant_.

        Disk3D::emissquant_ is freed if not NULL, reallocated, and pattern is
        copied into emission_.

        If Disk3D::velocity_ or has been set previously with mismatching
        sizes, it is deallocated too.

        Finally, Disk3D::nnu_, Disk3D::nphi_, Disk3D::nz_ and Disk3D::nr_ are
        set according to naxes.

        Parameters:
        -----------

        pattern:  Array to copy as emission_. May be NULL in which case
        emission_ is simply deallocated and set to NULL.

        naxes:  { nnu_, nphi_, nz_, nr_ }. 
        """
        return _std.Disk3D_copyEmissquant(self, pattern, naxes)


    def getEmissquant(self):
        """
        getEmissquant(Disk3D self) -> double const *



        Get Disk3D::emissquant_. 
        """
        return _std.Disk3D_getEmissquant(self)


    def getEmissquantNaxes(self, naxes):
        """
        getEmissquantNaxes(Disk3D self, size_t [4] naxes)



        Get { Disk3D::nnu_, Disk3D::nphi_, Disk3D::nz_, Disk3D::nr_ }. 
        """
        return _std.Disk3D_getEmissquantNaxes(self, naxes)


    def copyOpacity(self, pattern=None, naxes=0):
        """
        copyOpacity(Disk3D self, double const *const pattern=None, size_t const [4] naxes=0)
        copyOpacity(Disk3D self, double const *const pattern=None)
        copyOpacity(Disk3D self)
        """
        return _std.Disk3D_copyOpacity(self, pattern, naxes)


    def opacity(self, *args):
        """
        opacity(Disk3D self, double * pattern)
        opacity(Disk3D self) -> double const *



        Get Disk3D::opacity_. 
        """
        return _std.Disk3D_opacity(self, *args)


    def copyVelocity(self, pattern=None, naxes=0):
        """
        copyVelocity(Disk3D self, double const *const pattern=None, size_t const [3] naxes=0)
        copyVelocity(Disk3D self, double const *const pattern=None)
        copyVelocity(Disk3D self)



        Set Disk3D::velocity_.

        Disk3D::velocity_ is first freed if not NULL and set to NULL.

        If pattern is not NULL, Disk3D::emissquant_ must have been set
        previously with matching dimensions. Disk3D::velocity_ is then
        reallocated, and pattern is copied into velocity_.

        Parameters:
        -----------

        pattern:  Array to copy as velocity_. May be NULL in which case
        velocity_ is simply deallocated and set to NULL.

        naxes:  { nphi_, nz_, nr_ }. 
        """
        return _std.Disk3D_copyVelocity(self, pattern, naxes)


    def repeatPhi(self, *args):
        """
        repeatPhi(Disk3D self, size_t n)
        repeatPhi(Disk3D self) -> size_t



        Get Disk3D::repeat_phi_. 
        """
        return _std.Disk3D_repeatPhi(self, *args)


    def nu0(self, *args):
        """
        nu0(Disk3D self, double freq)
        nu0(Disk3D self) -> double



        Get Disk3D::nu0_. 
        """
        return _std.Disk3D_nu0(self, *args)


    def dnu(self, *args):
        """
        dnu(Disk3D self, double dfreq)
        dnu(Disk3D self) -> double



        Get Disk3D::dnu_. 
        """
        return _std.Disk3D_dnu(self, *args)


    def rin(self, *args):
        """
        rin(Disk3D self, double rrin)
        rin(Disk3D self) -> double



        Get Disk3D::rin_. 
        """
        return _std.Disk3D_rin(self, *args)


    def rout(self, *args):
        """
        rout(Disk3D self, double rout)
        rout(Disk3D self) -> double



        Get Disk3D::rout_. 
        """
        return _std.Disk3D_rout(self, *args)


    def zmin(self, *args):
        """
        zmin(Disk3D self, double zmin)
        zmin(Disk3D self) -> double



        Get Disk3D::zmin_. 
        """
        return _std.Disk3D_zmin(self, *args)


    def zmax(self, *args):
        """
        zmax(Disk3D self, double zmax)
        zmax(Disk3D self) -> double



        Get Disk3D::zmax_. 
        """
        return _std.Disk3D_zmax(self, *args)


    def phimin(self, *args):
        """
        phimin(Disk3D self, double phimin)
        phimin(Disk3D self) -> double



        Get Disk3D::phimin_. 
        """
        return _std.Disk3D_phimin(self, *args)


    def phimax(self, *args):
        """
        phimax(Disk3D self, double phimax)
        phimax(Disk3D self) -> double



        Get Disk3D::phimax_. 
        """
        return _std.Disk3D_phimax(self, *args)


    def Impact(self, ph, index, data):
        """
        Impact(Disk3D self, Photon ph, size_t index, AstrobjProperties data) -> int



        Does a photon at these coordinates impact the object?

        Impact() checks whether a Photon impacts the object between two
        integration steps of the photon's trajectory (those two steps are
        photon->getCoord(index, coord1) and photon->getCoord(index+1,
        coord2)). Impact returns 1 if the photon impacts the object between
        these two steps, else 0. In many cases of geometrically thick obects,
        the implementation Astrobj::Standard::Impact() will be fine.

        Impact will call Generic::processHitQuantities() (which is virtual and
        may be re-implemented) to compute observable properties on demand: if
        the data pointer is non-NULL, the object will look in it for pointers
        to properties which apply to its kind. If a pointer to a property
        known to this object is present, then the property is computed and
        store at the pointed-to address. For instance, all objects know the
        "intensity" property. If data->intensity != NULL, the instensity is
        computed and stored in *data->intensity.

        If data is non-NULL and only in this case, processHitQuantities() will
        also call ph->transmit() to update the transmissions of the Photon
        (see Photon::transmit(size_t, double)). This must not be done if data
        is NULL (see Astrobj::Complex::Impact() for an explanation).

        Impact() may not extend the ph Worldline. The only two dates that are
        guaranteed to be defined are at indices index and index+1.

        Parameters:
        -----------

        ph:   Gyoto::Photon aimed at the object;

        index:  Index of the last photon step;

        data:  Pointer to a structure to hold the observables at impact.

        1 if impact, 0 if not. 
        """
        return _std.Disk3D_Impact(self, ph, index, data)


    def getVelocity(self, *args):
        """
        getVelocity(Disk3D self) -> double const
        getVelocity(Disk3D self, double const [4] pos, double [4] vel)



        Get fluid 4-velocity at point.

        Fill vel with the 4-vector velocity of the fluid at 4-position pos.

        Parameters:
        -----------

        pos:  4-position at which to compute velocity;

        vel:  4-velocity at pos. 
        """
        return _std.Disk3D_getVelocity(self, *args)


    def __init__(self, *args):
        """
        __init__(Gyoto::Astrobj::Disk3D self) -> Disk3D
        __init__(Gyoto::Astrobj::Disk3D self, Disk3D arg2) -> Disk3D
        __init__(Gyoto::Astrobj::Disk3D self, Astrobj base) -> Disk3D
        __init__(Gyoto::Astrobj::Disk3D self, long address) -> Disk3D



        Copy constructor. 
        """
        this = _std.new_Disk3D(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
Disk3D_swigregister = _std.Disk3D_swigregister
Disk3D_swigregister(Disk3D)
Disk3D.properties = _std.cvar.Disk3D_properties
Disk3D.builtinPluginValue = _std.cvar.Disk3D_builtinPluginValue

class DynamicalDisk3D(Disk3D):
    """


    Geometrically thick optically thin disk read from a set of FITS files.

    This class describes a PatternDiskBB that evolves dynamically. It is
    described by a set of FITS files for different times. Its emission is
    blackbody.

    The disk is assumed to be described by a regular, constant in time,
    grid.

    The metric must be Kerr in BL coordinates.

    C++ includes: GyotoDynamicalDisk3D.h 
    """

    __swig_setmethods__ = {}
    for _s in [Disk3D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DynamicalDisk3D, name, value)
    __swig_getmethods__ = {}
    for _s in [Disk3D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DynamicalDisk3D, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(DynamicalDisk3D self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.DynamicalDisk3D_getProperties(self)


    def plugins(self, *args):
        """
        plugins(DynamicalDisk3D self, vector_string plugname)
        plugins(DynamicalDisk3D self) -> vector_string
        """
        return _std.DynamicalDisk3D_plugins(self, *args)


    def isThreadSafe(self):
        """
        isThreadSafe(DynamicalDisk3D self) -> bool



        Whether this class is thread-safe.

        Return True if this object is thread-safe, i.e. if an instance and its
        clone can be used in parallel threads (in the context of
        Scenery::raytrace()). Known objects which are not thread-safe include
        Lorene metrics and everything from the Python plug-in.

        The default implementation considers that the class itself is thread
        safe and recurses into the declared properties to check whether they
        are safe too. Classes that abide to the Object/Property paradigm and
        are themselves thread-safe have nothing special to do.

        Objects that clone children in their copy constructor that are not
        declared as properties must take these children into account.

        Classes that are never thread-safe must declare it. It acn be easily
        done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
        GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. 
        """
        return _std.DynamicalDisk3D_isThreadSafe(self)


    def clone(self):
        """
        clone(DynamicalDisk3D self) -> DynamicalDisk3D



        Cloner. 
        """
        return _std.DynamicalDisk3D_clone(self)

    __swig_destroy__ = _std.delete_DynamicalDisk3D
    __del__ = lambda self: None

    def metric(self, *args):
        """
        metric(DynamicalDisk3D self) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >
        metric(DynamicalDisk3D self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)
        metric(DynamicalDisk3D self, Gyoto::SmartPointer< Gyoto::Metric::Generic > gg)



        Get the Metric gg_. 
        """
        return _std.DynamicalDisk3D_metric(self, *args)


    def file(self, *args):
        """
        file(DynamicalDisk3D self, std::string const & f)
        file(DynamicalDisk3D self) -> std::string
        """
        return _std.DynamicalDisk3D_file(self, *args)


    def tinit(self, *args):
        """
        tinit(DynamicalDisk3D self, double t)
        tinit(DynamicalDisk3D self) -> double
        """
        return _std.DynamicalDisk3D_tinit(self, *args)


    def dt(self, *args):
        """
        dt(DynamicalDisk3D self, double t)
        dt(DynamicalDisk3D self) -> double
        """
        return _std.DynamicalDisk3D_dt(self, *args)


    def PLindex(self, *args):
        """
        PLindex(DynamicalDisk3D self, double t)
        PLindex(DynamicalDisk3D self) -> double
        """
        return _std.DynamicalDisk3D_PLindex(self, *args)


    def floorTemperature(self, *args):
        """
        floorTemperature(DynamicalDisk3D self, double t)
        floorTemperature(DynamicalDisk3D self) -> double
        """
        return _std.DynamicalDisk3D_floorTemperature(self, *args)


    def temperature(self, *args):
        """
        temperature(DynamicalDisk3D self, bool t)
        temperature(DynamicalDisk3D self) -> bool
        """
        return _std.DynamicalDisk3D_temperature(self, *args)


    def withVelocity(self, *args):
        """
        withVelocity(DynamicalDisk3D self, bool t)
        withVelocity(DynamicalDisk3D self) -> bool
        """
        return _std.DynamicalDisk3D_withVelocity(self, *args)


    def emission1date(self, nu_em, dsem, c_ph, c_obj):
        """
        emission1date(DynamicalDisk3D self, double nu_em, double dsem, vector_double c_ph, double const [8] c_obj) -> double



        Compute emission at one grid date. 
        """
        return _std.DynamicalDisk3D_emission1date(self, nu_em, dsem, c_ph, c_obj)


    def emission(self, *args):
        """
        emission(DynamicalDisk3D self, double nu_em, double dsem, vector_double coord_ph, double const [8] coord_obj=0) -> double
        emission(DynamicalDisk3D self, double nu_em, double dsem, vector_double coord_ph) -> double
        emission(DynamicalDisk3D self, double [] Inu, double const [] nu_em, size_t nbnu, double dsem, vector_double coord_ph, double const [8] coord_obj=0)
        emission(DynamicalDisk3D self, double [] Inu, double const [] nu_em, size_t nbnu, double dsem, vector_double coord_ph)
        emission(DynamicalDisk3D self, double nu_em, double dsem, vector_double c_ph, double const [8] c_obj=0) -> double
        emission(DynamicalDisk3D self, double nu_em, double dsem, vector_double c_ph) -> double



        Obsolete, update your code. 
        """
        return _std.DynamicalDisk3D_emission(self, *args)


    def transmission1date(self, nu_em, dsem, c_ph, c_obj):
        """
        transmission1date(DynamicalDisk3D self, double nu_em, double dsem, vector_double c_ph, double const [8] c_obj) -> double



        Compute transmission at one grid date. 
        """
        return _std.DynamicalDisk3D_transmission1date(self, nu_em, dsem, c_ph, c_obj)


    def transmission(self, nu_em, dsem, cph, co):
        """
        transmission(DynamicalDisk3D self, double nu_em, double dsem, vector_double cph, double const [8] co) -> double



        Obsolete, update your code. 
        """
        return _std.DynamicalDisk3D_transmission(self, nu_em, dsem, cph, co)


    def getVelocity(self, *args):
        """
        getVelocity(DynamicalDisk3D self, double const [4] pos, double [4] vel)
        getVelocity(DynamicalDisk3D self) -> double const *



        Get Disk3D::velocity_. 
        """
        return _std.DynamicalDisk3D_getVelocity(self, *args)


    def __init__(self, *args):
        """
        __init__(Gyoto::Astrobj::DynamicalDisk3D self) -> DynamicalDisk3D
        __init__(Gyoto::Astrobj::DynamicalDisk3D self, DynamicalDisk3D arg2) -> DynamicalDisk3D
        __init__(Gyoto::Astrobj::DynamicalDisk3D self, Astrobj base) -> DynamicalDisk3D
        __init__(Gyoto::Astrobj::DynamicalDisk3D self, long address) -> DynamicalDisk3D



        Copy constructor. 
        """
        this = _std.new_DynamicalDisk3D(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
DynamicalDisk3D_swigregister = _std.DynamicalDisk3D_swigregister
DynamicalDisk3D_swigregister(DynamicalDisk3D)
DynamicalDisk3D.properties = _std.cvar.DynamicalDisk3D_properties
DynamicalDisk3D.builtinPluginValue = _std.cvar.DynamicalDisk3D_builtinPluginValue

class DirectionalDisk(gyoto.core.ThinDisk):
    """


    Geometrically thin disk read from FITS file.

    This class describes a disk contained in the z=0 (equatorial) plane.
    The flux emitted at radius r, making an angle i with respect to the
    local normal, at frequency nu is given in a FITS file.

    C++ includes: GyotoDirectionalDisk.h 
    """

    __swig_setmethods__ = {}
    for _s in [gyoto.core.ThinDisk]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DirectionalDisk, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.ThinDisk]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DirectionalDisk, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(DirectionalDisk self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.DirectionalDisk_getProperties(self)


    def plugins(self, *args):
        """
        plugins(DirectionalDisk self, vector_string plugname)
        plugins(DirectionalDisk self) -> vector_string
        """
        return _std.DirectionalDisk_plugins(self, *args)


    def fillProperty(self, fmp, p):
        """
        fillProperty(DirectionalDisk self, FactoryMessenger fmp, Property p)



        Output a single Property to XML.

        The base implementation decides what to do based on the p.type. The
        format matches how setParameters() an setParameter() would interpret
        the XML descition.

        Overriding this method should be avoided, but makes sense in some
        cases (for instance Screen::fillProperty() selects a different unit
        for Distance based on its magnitude, so that stellar sizes are
        expressed in solar radii while smaller sizes can be expressed in
        meters and larger sizes in parsecs).

        Overriding implementation should fall-back on calling the
        implementation in the direct parent class: 
        """
        return _std.DirectionalDisk_fillProperty(self, fmp, p)


    def metric(self, *args):
        """
        metric(DirectionalDisk self) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >
        metric(DirectionalDisk self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)
        metric(DirectionalDisk self, Gyoto::SmartPointer< Gyoto::Metric::Generic > gg)



        Get the Metric gg_. 
        """
        return _std.DirectionalDisk_metric(self, *args)


    def clone(self):
        """
        clone(DirectionalDisk self) -> DirectionalDisk



        Cloner. 
        """
        return _std.DirectionalDisk_clone(self)

    __swig_destroy__ = _std.delete_DirectionalDisk
    __del__ = lambda self: None

    def file(self, *args):
        """
        file(DirectionalDisk self, std::string const & f)
        file(DirectionalDisk self) -> std::string
        """
        return _std.DirectionalDisk_file(self, *args)


    def averageOverAngle(self, *args):
        """
        averageOverAngle(DirectionalDisk self, bool t)
        averageOverAngle(DirectionalDisk self) -> bool
        """
        return _std.DirectionalDisk_averageOverAngle(self, *args)


    def lampaltitude(self, *args):
        """
        lampaltitude(DirectionalDisk self, double zz)
        lampaltitude(DirectionalDisk self) -> double
        """
        return _std.DirectionalDisk_lampaltitude(self, *args)


    def lampcutoffsinev(self, *args):
        """
        lampcutoffsinev(DirectionalDisk self, vector_double v)
        lampcutoffsinev(DirectionalDisk self) -> vector_double
        """
        return _std.DirectionalDisk_lampcutoffsinev(self, *args)


    def fitsRead(self, filename_):
        """fitsRead(DirectionalDisk self, std::string filename_)"""
        return _std.DirectionalDisk_fitsRead(self, filename_)


    def fitsWrite(self, filename_):
        """fitsWrite(DirectionalDisk self, std::string filename_)"""
        return _std.DirectionalDisk_fitsWrite(self, filename_)


    def setEmission(self, pattern):
        """
        setEmission(DirectionalDisk self, double * pattern)



        Set DirectionalDisk::emission_.

        The pointer is copied directly, not the array content.

        This is a low-level function. Beware that: previously allocated array
        will not be freed automatically;

        array attached when the destructor is called will be freed. 
        """
        return _std.DirectionalDisk_setEmission(self, pattern)


    def radius(self, pattern):
        """radius(DirectionalDisk self, double * pattern)"""
        return _std.DirectionalDisk_radius(self, pattern)


    def copyIntensity(self, pattern=None, naxes=0):
        """
        copyIntensity(DirectionalDisk self, double const *const pattern=None, size_t const [3] naxes=0)
        copyIntensity(DirectionalDisk self, double const *const pattern=None)
        copyIntensity(DirectionalDisk self)



        DirectionalDisk::emission_ is freed if not NULL, reallocated, and
        pattern is copied into emission_.

        Finally, DirectionalDisk::nnu_, DirectionalDisk::ni_, and
        DirectionalDisk::nr_ are set according to naxes.

        Parameters:
        -----------

        pattern:  Array to copy as emission_. May be NULL in which case
        emission_ is simply deallocated and set to NULL.

        naxes:  { nnu_, ni_, nr_ }. 
        """
        return _std.DirectionalDisk_copyIntensity(self, pattern, naxes)


    def getIntensity(self):
        """
        getIntensity(DirectionalDisk self) -> double const *



        Get DirectionalDisk::emission_. 
        """
        return _std.DirectionalDisk_getIntensity(self)


    def getIntensityNaxes(self, naxes):
        """
        getIntensityNaxes(DirectionalDisk self, size_t [3] naxes)



        Get DirectionalDisk::nnu_, DirectionalDisk::ni_, and
        DirectionalDisk::nr_. 
        """
        return _std.DirectionalDisk_getIntensityNaxes(self, naxes)


    def copyGridRadius(self, pattern=None, nr=0):
        """
        copyGridRadius(DirectionalDisk self, double const *const pattern=None, size_t nr=0)
        copyGridRadius(DirectionalDisk self, double const *const pattern=None)
        copyGridRadius(DirectionalDisk self)
        """
        return _std.DirectionalDisk_copyGridRadius(self, pattern, nr)


    def getGridRadius(self):
        """
        getGridRadius(DirectionalDisk self) -> double const *



        Get DirectionalDisk::radius_. 
        """
        return _std.DirectionalDisk_getGridRadius(self)


    def copyGridCosi(self, pattern=None, ni=0):
        """
        copyGridCosi(DirectionalDisk self, double const *const pattern=None, size_t ni=0)
        copyGridCosi(DirectionalDisk self, double const *const pattern=None)
        copyGridCosi(DirectionalDisk self)
        """
        return _std.DirectionalDisk_copyGridCosi(self, pattern, ni)


    def getGridCosi(self):
        """
        getGridCosi(DirectionalDisk self) -> double const *



        Get DirectionalDisk::cosi_. 
        """
        return _std.DirectionalDisk_getGridCosi(self)


    def copyGridFreq(self, pattern=None, ni=0):
        """
        copyGridFreq(DirectionalDisk self, double const *const pattern=None, size_t ni=0)
        copyGridFreq(DirectionalDisk self, double const *const pattern=None)
        copyGridFreq(DirectionalDisk self)
        """
        return _std.DirectionalDisk_copyGridFreq(self, pattern, ni)


    def getGridFreq(self):
        """
        getGridFreq(DirectionalDisk self) -> double const *



        Get DirectionalDisk::freq_. 
        """
        return _std.DirectionalDisk_getGridFreq(self)


    def emission(self, *args):
        """
        emission(DirectionalDisk self, double nu_em, double dsem, vector_double coord_ph, double const [8] coord_obj=0) -> double
        emission(DirectionalDisk self, double nu_em, double dsem, vector_double coord_ph) -> double
        emission(DirectionalDisk self, double [] Inu, double const [] nu_em, size_t nbnu, double dsem, vector_double coord_ph, double const [8] coord_obj=0)
        emission(DirectionalDisk self, double [] Inu, double const [] nu_em, size_t nbnu, double dsem, vector_double coord_ph)
        emission(DirectionalDisk self, double nu_em, double dsem, vector_double c_ph, double const [8] c_obj=0) -> double
        emission(DirectionalDisk self, double nu_em, double dsem, vector_double c_ph) -> double



        Obsolete, update your code. 
        """
        return _std.DirectionalDisk_emission(self, *args)


    def __init__(self, *args):
        """
        __init__(Gyoto::Astrobj::DirectionalDisk self) -> DirectionalDisk
        __init__(Gyoto::Astrobj::DirectionalDisk self, DirectionalDisk arg2) -> DirectionalDisk
        __init__(Gyoto::Astrobj::DirectionalDisk self, Astrobj base) -> DirectionalDisk
        __init__(Gyoto::Astrobj::DirectionalDisk self, long address) -> DirectionalDisk



        Copy constructor. 
        """
        this = _std.new_DirectionalDisk(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
DirectionalDisk_swigregister = _std.DirectionalDisk_swigregister
DirectionalDisk_swigregister(DirectionalDisk)
DirectionalDisk.properties = _std.cvar.DirectionalDisk_properties
DirectionalDisk.builtinPluginValue = _std.cvar.DirectionalDisk_builtinPluginValue

class DeformedTorus(gyoto.core.StandardAstrobj):
    """Proxy of C++ Gyoto::Astrobj::DeformedTorus class."""

    __swig_setmethods__ = {}
    for _s in [gyoto.core.StandardAstrobj]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DeformedTorus, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.StandardAstrobj]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DeformedTorus, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(DeformedTorus self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.DeformedTorus_getProperties(self)


    def plugins(self, *args):
        """
        plugins(DeformedTorus self, vector_string plugname)
        plugins(DeformedTorus self) -> vector_string
        """
        return _std.DeformedTorus_plugins(self, *args)

    __swig_destroy__ = _std.delete_DeformedTorus
    __del__ = lambda self: None

    def clone(self):
        """
        clone(DeformedTorus self) -> DeformedTorus



        Cloner.

        This method must be implemented by the various Astrobj::Generic
        subclasses in order to support cloning:

        Cloning is necessary for multi-threading, recommended for interaction
        with the Yorick plug-in etc.

        Implementing it is very straightforward, as long as the copy
        constructor Generic(const Generic& ) has been implemented: 
        """
        return _std.DeformedTorus_clone(self)


    def spectrum(self, *args):
        """
        spectrum(DeformedTorus self, Gyoto::SmartPointer< Gyoto::Spectrum::Generic > arg2)
        spectrum(DeformedTorus self) -> Gyoto::SmartPointer< Gyoto::Spectrum::Generic >
        """
        return _std.DeformedTorus_spectrum(self, *args)


    def largeRadius(self, *args):
        """
        largeRadius(DeformedTorus self, double arg2)
        largeRadius(DeformedTorus self) -> double
        """
        return _std.DeformedTorus_largeRadius(self, *args)


    def beta(self, *args):
        """
        beta(DeformedTorus self, double arg2)
        beta(DeformedTorus self) -> double
        """
        return _std.DeformedTorus_beta(self, *args)


    def betaSt(self, *args):
        """
        betaSt(DeformedTorus self, double arg2)
        betaSt(DeformedTorus self) -> double
        """
        return _std.DeformedTorus_betaSt(self, *args)


    def eta(self, *args):
        """
        eta(DeformedTorus self, double arg2)
        eta(DeformedTorus self) -> double
        """
        return _std.DeformedTorus_eta(self, *args)


    def mode(self, *args):
        """
        mode(DeformedTorus self, unsigned long arg2)
        mode(DeformedTorus self) -> unsigned long
        """
        return _std.DeformedTorus_mode(self, *args)


    def perturbKind(self, *args):
        """
        perturbKind(DeformedTorus self, std::string const & arg2)
        perturbKind(DeformedTorus self) -> std::string
        """
        return _std.DeformedTorus_perturbKind(self, *args)


    def metric(self, *args):
        """
        metric(DeformedTorus self) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >
        metric(DeformedTorus self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)



        Get the Metric gg_. 
        """
        return _std.DeformedTorus_metric(self, *args)


    def __call__(self, coord):
        """__call__(DeformedTorus self, double const [4] coord) -> double"""
        return _std.DeformedTorus___call__(self, coord)


    def getVelocity(self, pos, vel):
        """
        getVelocity(DeformedTorus self, double const [4] pos, double [4] vel)



        Fluid velocity field.

        Fill vel with the 4-vector velocity of the fluid at 4-position pos.

        Parameters:
        -----------

        pos:  4-position at which to compute velocity;

        vel:  4-velocity at pos. 
        """
        return _std.DeformedTorus_getVelocity(self, pos, vel)


    def emission(self, nuem, arg3, arg4, arg5):
        """
        emission(DeformedTorus self, double nuem, double arg3, vector_double arg4, double const * arg5) -> double



        Obsolete, update your code. 
        """
        return _std.DeformedTorus_emission(self, nuem, arg3, arg4, arg5)


    def __init__(self, *args):
        """
        __init__(Gyoto::Astrobj::DeformedTorus self) -> DeformedTorus
        __init__(Gyoto::Astrobj::DeformedTorus self, DeformedTorus o) -> DeformedTorus
        __init__(Gyoto::Astrobj::DeformedTorus self, Astrobj base) -> DeformedTorus
        __init__(Gyoto::Astrobj::DeformedTorus self, long address) -> DeformedTorus
        """
        this = _std.new_DeformedTorus(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
DeformedTorus_swigregister = _std.DeformedTorus_swigregister
DeformedTorus_swigregister(DeformedTorus)
DeformedTorus.properties = _std.cvar.DeformedTorus_properties
DeformedTorus.builtinPluginValue = _std.cvar.DeformedTorus_builtinPluginValue

class EquatorialHotSpot(gyoto.core.ThinDisk, gyoto.core.Worldline):
    """Proxy of C++ Gyoto::Astrobj::EquatorialHotSpot class."""

    __swig_setmethods__ = {}
    for _s in [gyoto.core.ThinDisk, gyoto.core.Worldline]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EquatorialHotSpot, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.ThinDisk, gyoto.core.Worldline]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EquatorialHotSpot, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(EquatorialHotSpot self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.EquatorialHotSpot_getProperties(self)


    def plugins(self, *args):
        """
        plugins(EquatorialHotSpot self, vector_string plugname)
        plugins(EquatorialHotSpot self) -> vector_string
        """
        return _std.EquatorialHotSpot_plugins(self, *args)


    def _delta(self, *args):
        """
        _delta(EquatorialHotSpot self, double const delta)
        _delta(EquatorialHotSpot self, double arg2, std::string const & unit)
        _delta(EquatorialHotSpot self) -> double
        _delta(EquatorialHotSpot self, std::string const & unit) -> double
        """
        return _std.EquatorialHotSpot__delta(self, *args)


    def _tMin(self, *args):
        """
        _tMin(EquatorialHotSpot self, double const tmin)
        _tMin(EquatorialHotSpot self, double arg2, std::string const & unit)
        _tMin(EquatorialHotSpot self) -> double
        _tMin(EquatorialHotSpot self, std::string const & unit) -> double
        """
        return _std.EquatorialHotSpot__tMin(self, *args)


    def _adaptive(self, *args):
        """
        _adaptive(EquatorialHotSpot self, bool mode)
        _adaptive(EquatorialHotSpot self) -> bool
        """
        return _std.EquatorialHotSpot__adaptive(self, *args)


    def _secondary(self, *args):
        """
        _secondary(EquatorialHotSpot self, bool sec)
        _secondary(EquatorialHotSpot self) -> bool
        """
        return _std.EquatorialHotSpot__secondary(self, *args)


    def _integ31(self, *args):
        """
        _integ31(EquatorialHotSpot self, bool sec)
        _integ31(EquatorialHotSpot self) -> bool
        """
        return _std.EquatorialHotSpot__integ31(self, *args)


    def _parallelTransport(self, *args):
        """
        _parallelTransport(EquatorialHotSpot self, bool sec)
        _parallelTransport(EquatorialHotSpot self) -> bool
        """
        return _std.EquatorialHotSpot__parallelTransport(self, *args)


    def _maxiter(self, *args):
        """
        _maxiter(EquatorialHotSpot self, size_t miter)
        _maxiter(EquatorialHotSpot self) -> size_t
        """
        return _std.EquatorialHotSpot__maxiter(self, *args)


    def _integrator(self, *args):
        """
        _integrator(EquatorialHotSpot self, std::string const & type)
        _integrator(EquatorialHotSpot self) -> std::string
        """
        return _std.EquatorialHotSpot__integrator(self, *args)


    def _deltaMin(self, *args):
        """
        _deltaMin(EquatorialHotSpot self) -> double
        _deltaMin(EquatorialHotSpot self, double h1)
        """
        return _std.EquatorialHotSpot__deltaMin(self, *args)


    def _absTol(self, *args):
        """
        _absTol(EquatorialHotSpot self, double arg2)
        _absTol(EquatorialHotSpot self) -> double
        """
        return _std.EquatorialHotSpot__absTol(self, *args)


    def _maxCrossEqplane(self, *args):
        """
        _maxCrossEqplane(EquatorialHotSpot self, double arg2)
        _maxCrossEqplane(EquatorialHotSpot self) -> double
        """
        return _std.EquatorialHotSpot__maxCrossEqplane(self, *args)


    def _relTol(self, *args):
        """
        _relTol(EquatorialHotSpot self, double arg2)
        _relTol(EquatorialHotSpot self) -> double
        """
        return _std.EquatorialHotSpot__relTol(self, *args)


    def _deltaMax(self, *args):
        """
        _deltaMax(EquatorialHotSpot self, double h1)
        _deltaMax(EquatorialHotSpot self) -> double
        """
        return _std.EquatorialHotSpot__deltaMax(self, *args)


    def _deltaMaxOverR(self, *args):
        """
        _deltaMaxOverR(EquatorialHotSpot self) -> double
        _deltaMaxOverR(EquatorialHotSpot self, double t)
        """
        return _std.EquatorialHotSpot__deltaMaxOverR(self, *args)


    def _initCoord(self, *args):
        """
        _initCoord(EquatorialHotSpot self) -> vector_double
        _initCoord(EquatorialHotSpot self, vector_double f)
        """
        return _std.EquatorialHotSpot__initCoord(self, *args)


    def _metric(self, *args):
        """
        _metric(EquatorialHotSpot self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)
        _metric(EquatorialHotSpot self) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >
        """
        return _std.EquatorialHotSpot__metric(self, *args)


    def deltaMax(self, *args):
        """
        deltaMax(EquatorialHotSpot self) -> double
        deltaMax(EquatorialHotSpot self, double const [8] pos, double delta_max_external) -> double
        deltaMax(EquatorialHotSpot self, double h1)
        deltaMax(EquatorialHotSpot self, double [8] coord) -> double



        Get max step constraint for adaptive integration.

        Parameters:
        -----------

        coord:  position

        max step to find this object reliably 
        """
        return _std.EquatorialHotSpot_deltaMax(self, *args)

    __swig_destroy__ = _std.delete_EquatorialHotSpot
    __del__ = lambda self: None

    def clone(self):
        """
        clone(EquatorialHotSpot self) -> EquatorialHotSpot



        Cloner.

        This method must be implemented by the various Astrobj::Generic
        subclasses in order to support cloning:

        Cloning is necessary for multi-threading, recommended for interaction
        with the Yorick plug-in etc.

        Implementing it is very straightforward, as long as the copy
        constructor Generic(const Generic& ) has been implemented: 
        """
        return _std.EquatorialHotSpot_clone(self)


    def spotRadSize(self, *args):
        """
        spotRadSize(EquatorialHotSpot self, double t)
        spotRadSize(EquatorialHotSpot self) -> double
        """
        return _std.EquatorialHotSpot_spotRadSize(self, *args)


    def beaming(self, *args):
        """
        beaming(EquatorialHotSpot self, std::string const & b)
        beaming(EquatorialHotSpot self) -> std::string
        """
        return _std.EquatorialHotSpot_beaming(self, *args)


    def beamAngle(self, *args):
        """
        beamAngle(EquatorialHotSpot self, double t)
        beamAngle(EquatorialHotSpot self) -> double
        """
        return _std.EquatorialHotSpot_beamAngle(self, *args)


    def magneticConfiguration(self, *args):
        """
        magneticConfiguration(EquatorialHotSpot self, std::string config)
        magneticConfiguration(EquatorialHotSpot self) -> std::string
        """
        return _std.EquatorialHotSpot_magneticConfiguration(self, *args)


    def getMass(self):
        """
        getMass(EquatorialHotSpot self) -> double



        Get mass of particule. 
        """
        return _std.EquatorialHotSpot_getMass(self)


    def metric(self, *args):
        """
        metric(EquatorialHotSpot self) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >
        metric(EquatorialHotSpot self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)
        metric(EquatorialHotSpot self, Gyoto::SmartPointer< Gyoto::Metric::Generic > gg)



        Get metric. 
        """
        return _std.EquatorialHotSpot_metric(self, *args)


    def setInitialCondition(self, coord):
        """
        setInitialCondition(EquatorialHotSpot self, double [8] coord)



        Set or re-set the initial condition prior to integration.

        Parameters:
        -----------

        gg:   Gyoto::SmartPointer to the Gyoto::Metric in this universe;

        coord:  8 element array containing the initial condition, i.e. the
        4-position and the 4-velocity of the Photon at the receiving end;

        dir:  direction: 1 for future, -1 for past. 
        """
        return _std.EquatorialHotSpot_setInitialCondition(self, coord)


    def getVelocity(self, pos, vel):
        """
        getVelocity(EquatorialHotSpot self, double const [4] pos, double [4] vel)



        Get fluid 4-velocity at point.

        Fill vel with the 4-vector velocity of the fluid at 4-position pos.
        getVelocity() should work at some distance from the equatorial plane.
        The default implementation calls Metric::Generic::circularVelocity().

        Parameters:
        -----------

        pos:  4-position at which to compute velocity;

        vel:  4-velocity at pos. 
        """
        return _std.EquatorialHotSpot_getVelocity(self, pos, vel)


    def emission(self, nu_em, dsem, arg4, coord_obj):
        """
        emission(EquatorialHotSpot self, double nu_em, double dsem, vector_double arg4, double const [8] coord_obj) -> double



        Obsolete, update your code. 
        """
        return _std.EquatorialHotSpot_emission(self, nu_em, dsem, arg4, coord_obj)


    def radiativeQ(self, *args):
        """
        radiativeQ(EquatorialHotSpot self, double * Inu, double * Qnu, double * Unu, double * Vnu, Eigen::Matrix4d * Onu, double const * nuem, size_t nbnu, double dsem, vector_double cph, double const * co)
        radiativeQ(EquatorialHotSpot self, double [] Inu, double [] Taunu, double const [] nu_ems, size_t nbnu, double dsem, vector_double coord_ph, double const [8] coord_obj)
        """
        return _std.EquatorialHotSpot_radiativeQ(self, *args)


    def setParameter(self, name, content, unit):
        """
        setParameter(EquatorialHotSpot self, std::string name, std::string content, std::string unit) -> int



        Set parameter by Property (and name)

        This function is used when parsing an XML description, if Property (
        p) of this name is found (i.e. either p.name or p.name_false is equal
        to name). Implementation should fall-back on calling the direct's
        parent implementation:

        Parameters:
        -----------

        p:   Property that matches name ( p.name == name or p.name_false ==
        name)

        name:  XML name of the parameter (XML entity)

        content:  string representation of the value

        unit:  string representation of the unit 
        """
        return _std.EquatorialHotSpot_setParameter(self, name, content, unit)


    def setParameters(self, fmp):
        """
        setParameters(EquatorialHotSpot self, FactoryMessenger fmp)



        Main loop in Subcontractor_t function.

        The Subcontractor_t function for each Astrobj kind should look
        somewhat like this (templated as
        Gyoto::Astrobj::Subcontractor<MyKind>):

        Each object kind should implement setParameter(string name, string
        content, string unit) to interpret the individual XML elements.
        setParameters() can be overloaded in case the specific Astrobj class
        needs low level access to the FactoryMessenger. See
        UniformSphere::setParameters(). 
        """
        return _std.EquatorialHotSpot_setParameters(self, fmp)


    def fillProperty(self, fmp, p):
        """
        fillProperty(EquatorialHotSpot self, FactoryMessenger fmp, Property p)



        Output a single Property to XML.

        The base implementation decides what to do based on the p.type. The
        format matches how setParameters() an setParameter() would interpret
        the XML descition.

        Overriding this method should be avoided, but makes sense in some
        cases (for instance Screen::fillProperty() selects a different unit
        for Distance based on its magnitude, so that stellar sizes are
        expressed in solar radii while smaller sizes can be expressed in
        meters and larger sizes in parsecs).

        Overriding implementation should fall-back on calling the
        implementation in the direct parent class: 
        """
        return _std.EquatorialHotSpot_fillProperty(self, fmp, p)


    def __init__(self, *args):
        """
        __init__(Gyoto::Astrobj::EquatorialHotSpot self) -> EquatorialHotSpot
        __init__(Gyoto::Astrobj::EquatorialHotSpot self, EquatorialHotSpot o) -> EquatorialHotSpot
        __init__(Gyoto::Astrobj::EquatorialHotSpot self, Astrobj base) -> EquatorialHotSpot
        __init__(Gyoto::Astrobj::EquatorialHotSpot self, long address) -> EquatorialHotSpot
        """
        this = _std.new_EquatorialHotSpot(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
EquatorialHotSpot_swigregister = _std.EquatorialHotSpot_swigregister
EquatorialHotSpot_swigregister(EquatorialHotSpot)
EquatorialHotSpot.properties = _std.cvar.EquatorialHotSpot_properties
EquatorialHotSpot.builtinPluginValue = _std.cvar.EquatorialHotSpot_builtinPluginValue

class XillverReflection(gyoto.core.ThinDisk, gyoto.core.Listener):
    """


    The illumination table specifies how the thin disk is illuminated
    while the reflection table deduces from that the reflected spectrum as
    computed by Javier Garcia's XILLVER code.

    C++ includes: GyotoXillverReflection.h 
    """

    __swig_setmethods__ = {}
    for _s in [gyoto.core.ThinDisk, gyoto.core.Listener]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, XillverReflection, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.ThinDisk, gyoto.core.Listener]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, XillverReflection, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(XillverReflection self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.XillverReflection_getProperties(self)


    def plugins(self, *args):
        """
        plugins(XillverReflection self, vector_string plugname)
        plugins(XillverReflection self) -> vector_string
        """
        return _std.XillverReflection_plugins(self, *args)


    def fillProperty(self, fmp, p):
        """
        fillProperty(XillverReflection self, FactoryMessenger fmp, Property p)



        Output a single Property to XML.

        The base implementation decides what to do based on the p.type. The
        format matches how setParameters() an setParameter() would interpret
        the XML descition.

        Overriding this method should be avoided, but makes sense in some
        cases (for instance Screen::fillProperty() selects a different unit
        for Distance based on its magnitude, so that stellar sizes are
        expressed in solar radii while smaller sizes can be expressed in
        meters and larger sizes in parsecs).

        Overriding implementation should fall-back on calling the
        implementation in the direct parent class: 
        """
        return _std.XillverReflection_fillProperty(self, fmp, p)


    def clone(self):
        """
        clone(XillverReflection self) -> XillverReflection



        Cloner. 
        """
        return _std.XillverReflection_clone(self)

    __swig_destroy__ = _std.delete_XillverReflection
    __del__ = lambda self: None

    def timelampphizero(self, *args):
        """
        timelampphizero(XillverReflection self, double tt)
        timelampphizero(XillverReflection self) -> double
        """
        return _std.XillverReflection_timelampphizero(self, *args)


    def lampradius(self, *args):
        """
        lampradius(XillverReflection self, double rr)
        lampradius(XillverReflection self) -> double
        """
        return _std.XillverReflection_lampradius(self, *args)


    def fileillumination(self, *args):
        """
        fileillumination(XillverReflection self, std::string const & f)
        fileillumination(XillverReflection self) -> std::string
        """
        return _std.XillverReflection_fileillumination(self, *args)


    def filereflection(self, *args):
        """
        filereflection(XillverReflection self, std::string const & f)
        filereflection(XillverReflection self) -> std::string
        """
        return _std.XillverReflection_filereflection(self, *args)


    def averageOverAngle(self, *args):
        """
        averageOverAngle(XillverReflection self, bool t)
        averageOverAngle(XillverReflection self) -> bool
        """
        return _std.XillverReflection_averageOverAngle(self, *args)


    def fitsReadIllum(self, filename):
        """fitsReadIllum(XillverReflection self, std::string filename)"""
        return _std.XillverReflection_fitsReadIllum(self, filename)


    def fitsWriteIllum(self, filename):
        """fitsWriteIllum(XillverReflection self, std::string filename)"""
        return _std.XillverReflection_fitsWriteIllum(self, filename)


    def fitsReadRefl(self, filename):
        """fitsReadRefl(XillverReflection self, std::string filename)"""
        return _std.XillverReflection_fitsReadRefl(self, filename)


    def fitsWriteRefl(self, filename):
        """fitsWriteRefl(XillverReflection self, std::string filename)"""
        return _std.XillverReflection_fitsWriteRefl(self, filename)


    def setIllumination(self, pattern):
        """
        setIllumination(XillverReflection self, double * pattern)



        The pointer is copied directly, not the array content.

        This is a low-level function. Beware that: previously allocated array
        will not be freed automatically;

        array attached when the destructor is called will be freed. 
        """
        return _std.XillverReflection_setIllumination(self, pattern)


    def setReflection(self, pattern):
        """setReflection(XillverReflection self, double * pattern)"""
        return _std.XillverReflection_setReflection(self, pattern)


    def copyIllumination(self, pattern=None, naxes=0):
        """
        copyIllumination(XillverReflection self, double const *const pattern=None, size_t const [2] naxes=0)
        copyIllumination(XillverReflection self, double const *const pattern=None)
        copyIllumination(XillverReflection self)



        XillverReflection::emission_ is freed if not NULL, reallocated, and
        pattern is copied into emission_.

        Finally, XillverReflection::nnu_, XillverReflection::ni_, and
        XillverReflection::nsg_ are set according to naxes.

        Parameters:
        -----------

        pattern:  Array to copy as emission_. May be NULL in which case
        emission_ is simply deallocated and set to NULL.

        naxes:  { nnu_, ni_, nsg_ }. 
        """
        return _std.XillverReflection_copyIllumination(self, pattern, naxes)


    def getIllumination(self):
        """getIllumination(XillverReflection self) -> double const *"""
        return _std.XillverReflection_getIllumination(self)


    def getIlluminationNaxes(self, naxes):
        """
        getIlluminationNaxes(XillverReflection self, size_t [2] naxes)



        Get XillverReflection::nr_, XillverReflection::nphi_. 
        """
        return _std.XillverReflection_getIlluminationNaxes(self, naxes)


    def copyReflection(self, pattern=None, naxes=0):
        """
        copyReflection(XillverReflection self, double const *const pattern=None, size_t const [3] naxes=0)
        copyReflection(XillverReflection self, double const *const pattern=None)
        copyReflection(XillverReflection self)
        """
        return _std.XillverReflection_copyReflection(self, pattern, naxes)


    def getReflection(self):
        """getReflection(XillverReflection self) -> double const *"""
        return _std.XillverReflection_getReflection(self)


    def getReflectionNaxes(self, naxes):
        """
        getReflectionNaxes(XillverReflection self, size_t [3] naxes)



        Get XillverReflection::nnu_, XillverReflection::ni_,
        XillverReflection::nxi_. 
        """
        return _std.XillverReflection_getReflectionNaxes(self, naxes)


    def copyGridReflLogxi(self, pattern=None, nxi=0):
        """
        copyGridReflLogxi(XillverReflection self, double const *const pattern=None, size_t nxi=0)
        copyGridReflLogxi(XillverReflection self, double const *const pattern=None)
        copyGridReflLogxi(XillverReflection self)
        """
        return _std.XillverReflection_copyGridReflLogxi(self, pattern, nxi)


    def getGridReflLogxi(self):
        """
        getGridReflLogxi(XillverReflection self) -> double const *



        Get XillverReflection::logxi_. 
        """
        return _std.XillverReflection_getGridReflLogxi(self)


    def copyGridReflIncl(self, pattern=None, ni=0):
        """
        copyGridReflIncl(XillverReflection self, double const *const pattern=None, size_t ni=0)
        copyGridReflIncl(XillverReflection self, double const *const pattern=None)
        copyGridReflIncl(XillverReflection self)
        """
        return _std.XillverReflection_copyGridReflIncl(self, pattern, ni)


    def getGridReflIncl(self):
        """
        getGridReflIncl(XillverReflection self) -> double const *



        Get XillverReflection::incl_. 
        """
        return _std.XillverReflection_getGridReflIncl(self)


    def copyGridReflFreq(self, pattern=None, nnu=0):
        """
        copyGridReflFreq(XillverReflection self, double const *const pattern=None, size_t nnu=0)
        copyGridReflFreq(XillverReflection self, double const *const pattern=None)
        copyGridReflFreq(XillverReflection self)
        """
        return _std.XillverReflection_copyGridReflFreq(self, pattern, nnu)


    def getGridReflFreq(self):
        """
        getGridReflFreq(XillverReflection self) -> double const *



        Get XillverReflection::freq_. 
        """
        return _std.XillverReflection_getGridReflFreq(self)


    def copyGridIllumRadius(self, pattern=None, nr=0):
        """
        copyGridIllumRadius(XillverReflection self, double const *const pattern=None, size_t nr=0)
        copyGridIllumRadius(XillverReflection self, double const *const pattern=None)
        copyGridIllumRadius(XillverReflection self)
        """
        return _std.XillverReflection_copyGridIllumRadius(self, pattern, nr)


    def getGridIllumRadius(self):
        """
        getGridIllumRadius(XillverReflection self) -> double const *



        Get XillverReflection::radius_. 
        """
        return _std.XillverReflection_getGridIllumRadius(self)


    def copyGridIllumPhi(self, pattern=None, nphi=0):
        """
        copyGridIllumPhi(XillverReflection self, double const *const pattern=None, size_t nphi=0)
        copyGridIllumPhi(XillverReflection self, double const *const pattern=None)
        copyGridIllumPhi(XillverReflection self)
        """
        return _std.XillverReflection_copyGridIllumPhi(self, pattern, nphi)


    def getGridIllumPhi(self):
        """
        getGridIllumPhi(XillverReflection self) -> double const *



        Get XillverReflection::phi_. 
        """
        return _std.XillverReflection_getGridIllumPhi(self)


    def emission(self, nu_em, dsem, _ph, _obj=0):
        """
        emission(XillverReflection self, double nu_em, double dsem, vector_double _ph, double const [8] _obj=0) -> double
        emission(XillverReflection self, double nu_em, double dsem, vector_double _ph) -> double



        Obsolete, update your code. 
        """
        return _std.XillverReflection_emission(self, nu_em, dsem, _ph, _obj)


    def updateSpin(self):
        """updateSpin(XillverReflection self)"""
        return _std.XillverReflection_updateSpin(self)


    def tell(self, msg):
        """
        tell(XillverReflection self, Teller msg)



        This is how a Teller tells.

        A teller will basically call listener->tell(this).

        Parameters:
        -----------

        msg:  Teller* the Teller who is telling... Useful if the Listener
        listens to several Tellers. 
        """
        return _std.XillverReflection_tell(self, msg)


    def metric(self, *args):
        """
        metric(XillverReflection self) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >
        metric(XillverReflection self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)
        metric(XillverReflection self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)



        Get the Metric gg_. 
        """
        return _std.XillverReflection_metric(self, *args)


    def __init__(self, *args):
        """
        __init__(Gyoto::Astrobj::XillverReflection self) -> XillverReflection
        __init__(Gyoto::Astrobj::XillverReflection self, XillverReflection o) -> XillverReflection
        __init__(Gyoto::Astrobj::XillverReflection self, Astrobj base) -> XillverReflection
        __init__(Gyoto::Astrobj::XillverReflection self, long address) -> XillverReflection



        Copy constructor. 
        """
        this = _std.new_XillverReflection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
XillverReflection_swigregister = _std.XillverReflection_swigregister
XillverReflection_swigregister(XillverReflection)
XillverReflection.properties = _std.cvar.XillverReflection_properties
XillverReflection.builtinPluginValue = _std.cvar.XillverReflection_builtinPluginValue

class Jet(gyoto.core.StandardAstrobj, gyoto.core.Listener):
    """


    Simple jet model with thermal or kappa-distribution synchrotron
    emission from Pandya et al. (2016)

    This class implements a jet defined as the volume contained between
    the two conical surfaces defined by angles jetInnerOpeningAngle_ and
    jetOuterOpeningAngle_, with apex located on the black hole rotation
    axis at altitude jetBaseHeight_ in units of M.

    The Lorentz factor is assumed constant at gammaJet_. The electron
    number density at the base of the jet is baseNumberDensity_cgs_, its
    z-evolution is dedictated by mass conservation. The electron
    temperature is baseTemperature_, its z-evolution is assumed to follow
    a power law z^temperatureSlope_. The magnetic field amplitude is
    defined by the magnetization parameter, magnetizationParameter_.

    The jet emits synchrotron radiation, assuming that the electrons
    follow a thermal or kappa distribution, ie the smooth gluing of a
    thermal distribution at low electron Lorentz factor, to a power-law
    distribution at high electron Lorentz factor. This distribution, as
    well as the resulting emission and absorption coefficients are taken
    from: Pandya et al., ApJ, 822, 34 (2016), section 5.3.3

    C++ includes: GyotoJet.h 
    """

    __swig_setmethods__ = {}
    for _s in [gyoto.core.StandardAstrobj, gyoto.core.Listener]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Jet, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.StandardAstrobj, gyoto.core.Listener]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Jet, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(Jet self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.Jet_getProperties(self)


    def plugins(self, *args):
        """
        plugins(Jet self, vector_string plugname)
        plugins(Jet self) -> vector_string
        """
        return _std.Jet_plugins(self, *args)


    def isThreadSafe(self):
        """
        isThreadSafe(Jet self) -> bool



        Whether this class is thread-safe.

        Return True if this object is thread-safe, i.e. if an instance and its
        clone can be used in parallel threads (in the context of
        Scenery::raytrace()). Known objects which are not thread-safe include
        Lorene metrics and everything from the Python plug-in.

        The default implementation considers that the class itself is thread
        safe and recurses into the declared properties to check whether they
        are safe too. Classes that abide to the Object/Property paradigm and
        are themselves thread-safe have nothing special to do.

        Objects that clone children in their copy constructor that are not
        declared as properties must take these children into account.

        Classes that are never thread-safe must declare it. It acn be easily
        done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
        GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. 
        """
        return _std.Jet_isThreadSafe(self)


    def clone(self):
        """
        clone(Jet self) -> Jet



        Cloner. 
        """
        return _std.Jet_clone(self)

    __swig_destroy__ = _std.delete_Jet
    __del__ = lambda self: None

    def jetOuterOpeningAngle(self, *args):
        """
        jetOuterOpeningAngle(Jet self, double ang)
        jetOuterOpeningAngle(Jet self) -> double
        """
        return _std.Jet_jetOuterOpeningAngle(self, *args)


    def jetInnerOpeningAngle(self, *args):
        """
        jetInnerOpeningAngle(Jet self, double ang)
        jetInnerOpeningAngle(Jet self) -> double
        """
        return _std.Jet_jetInnerOpeningAngle(self, *args)


    def jetBaseHeight(self, *args):
        """
        jetBaseHeight(Jet self, double hh)
        jetBaseHeight(Jet self) -> double
        """
        return _std.Jet_jetBaseHeight(self, *args)


    def gammaJet(self, *args):
        """
        gammaJet(Jet self, double gam)
        gammaJet(Jet self) -> double
        """
        return _std.Jet_gammaJet(self, *args)


    def jetVphiOverVr(self, *args):
        """
        jetVphiOverVr(Jet self, double alpha)
        jetVphiOverVr(Jet self) -> double
        """
        return _std.Jet_jetVphiOverVr(self, *args)


    def baseNumberDensity(self, *args):
        """
        baseNumberDensity(Jet self) -> double
        baseNumberDensity(Jet self, std::string const & unit) -> double
        baseNumberDensity(Jet self, double ne)
        baseNumberDensity(Jet self, double dens, std::string const & unit)
        """
        return _std.Jet_baseNumberDensity(self, *args)


    def baseTemperature(self, *args):
        """
        baseTemperature(Jet self, double tt)
        baseTemperature(Jet self) -> double
        """
        return _std.Jet_baseTemperature(self, *args)


    def temperatureSlope(self, *args):
        """
        temperatureSlope(Jet self, double ss)
        temperatureSlope(Jet self) -> double
        """
        return _std.Jet_temperatureSlope(self, *args)


    def magnetizationParameter(self, *args):
        """
        magnetizationParameter(Jet self, double rr)
        magnetizationParameter(Jet self) -> double
        """
        return _std.Jet_magnetizationParameter(self, *args)


    def kappaIndex(self, *args):
        """
        kappaIndex(Jet self, double index)
        kappaIndex(Jet self) -> double
        """
        return _std.Jet_kappaIndex(self, *args)


    def metric(self, *args):
        """
        metric(Jet self) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >
        metric(Jet self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)
        metric(Jet self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)



        Get the Metric gg_. 
        """
        return _std.Jet_metric(self, *args)


    def __call__(self, coord):
        """__call__(Jet self, double const [4] coord) -> double"""
        return _std.Jet___call__(self, coord)


    def radiativeQ(self, Inu, Taunu, nu_em, nbnu, dsem, coord_ph, coord_obj=0):
        """
        radiativeQ(Jet self, double [] Inu, double [] Taunu, double const [] nu_em, size_t nbnu, double dsem, vector_double coord_ph, double const [8] coord_obj=0)
        radiativeQ(Jet self, double [] Inu, double [] Taunu, double const [] nu_em, size_t nbnu, double dsem, vector_double coord_ph)



        Compute the increment of Stokes parameters and transmission matrix.
        Polarised version of RadiaveQ.

        First function to be called for radiative quantities. If exist, i.e.
        implemented in an Astrobj, return the Stokes parameters emitted by the
        small volume of length dsem.

        Warning : The basis used to determine the Stokes coefficients is
        different from the observer parallel transported polarisation basis.
        One should use getChi function to compute the angle between these two
        basis.

        The non polarized case must also be implemented in this function to
        avoid error.

        See exemple in SimplePolarStar.C.

        Parameters:
        -----------

        Inu[nbnu]:  Output increment of intensity (must be set to a previously
        allocated array of doubles)

        Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
        previously allocated array of doubles)

        Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
        previously allocated array of doubles)

        Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
        previously allocated array of doubles)

        Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
        previously allocated array of Matrix4d)

        nu_em[nbnu]:  Frequencies at emission

        nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

        dsem:  Length over which to integrate inside the object

        cph:   Photon coordinate

        co:  Emitter coordinate at current photon position

        Increment of the Stokes parameters (I,Q,U,V) and local Transmission
        matrix (O). 
        """
        return _std.Jet_radiativeQ(self, Inu, Taunu, nu_em, nbnu, dsem, coord_ph, coord_obj)


    def getVelocity(self, pos, vel):
        """
        getVelocity(Jet self, double const [4] pos, double [4] vel)



        Fluid velocity field.

        Fill vel with the 4-vector velocity of the fluid at 4-position pos.

        Parameters:
        -----------

        pos:  4-position at which to compute velocity;

        vel:  4-velocity at pos. 
        """
        return _std.Jet_getVelocity(self, pos, vel)


    def __init__(self, *args):
        """
        __init__(Gyoto::Astrobj::Jet self) -> Jet
        __init__(Gyoto::Astrobj::Jet self, Jet arg2) -> Jet
        __init__(Gyoto::Astrobj::Jet self, Astrobj base) -> Jet
        __init__(Gyoto::Astrobj::Jet self, long address) -> Jet



        Copy constructor. 
        """
        this = _std.new_Jet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
Jet_swigregister = _std.Jet_swigregister
Jet_swigregister(Jet)
Jet.properties = _std.cvar.Jet_properties
Jet.builtinPluginValue = _std.cvar.Jet_builtinPluginValue

class Blob(Star):
    """


    Blob of plasma following a Star orbit, emitting synchrotron, with
    Gaussian time-evolving density and temperature.

    C++ includes: GyotoBlob.h 
    """

    __swig_setmethods__ = {}
    for _s in [Star]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Blob, name, value)
    __swig_getmethods__ = {}
    for _s in [Star]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Blob, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(Blob self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.Blob_getProperties(self)


    def plugins(self, *args):
        """
        plugins(Blob self, vector_string plugname)
        plugins(Blob self) -> vector_string
        """
        return _std.Blob_plugins(self, *args)


    def clone(self):
        """
        clone(Blob self) -> Blob



        Cloner.

        This method must be implemented by the various Astrobj::Generic
        subclasses in order to support cloning:

        Cloning is necessary for multi-threading, recommended for interaction
        with the Yorick plug-in etc.

        Implementing it is very straightforward, as long as the copy
        constructor Generic(const Generic& ) has been implemented: 
        """
        return _std.Blob_clone(self)

    __swig_destroy__ = _std.delete_Blob
    __del__ = lambda self: None

    def electronDistribution(self, *args):
        """
        electronDistribution(Blob self, std::string const & kind)
        electronDistribution(Blob self) -> std::string
        """
        return _std.Blob_electronDistribution(self, *args)


    def className(self):
        """
        className(Blob self) -> std::string



        "Blob" 
        """
        return _std.Blob_className(self)


    def className_l(self):
        """
        className_l(Blob self) -> std::string



        "inflate_star" 
        """
        return _std.Blob_className_l(self)


    def numberDensity(self, *args):
        """
        numberDensity(Blob self) -> double
        numberDensity(Blob self, std::string const & unit) -> double
        numberDensity(Blob self, double ne)
        numberDensity(Blob self, double dens, std::string const & unit)
        """
        return _std.Blob_numberDensity(self, *args)


    def temperature(self, *args):
        """
        temperature(Blob self) -> double
        temperature(Blob self, double tt)
        """
        return _std.Blob_temperature(self, *args)


    def timeRef(self, *args):
        """
        timeRef(Blob self) -> double
        timeRef(Blob self, std::string const & unit) -> double
        timeRef(Blob self, double tt)
        timeRef(Blob self, double tt, std::string const & unit)
        """
        return _std.Blob_timeRef(self, *args)


    def timeSigma(self, *args):
        """
        timeSigma(Blob self) -> double
        timeSigma(Blob self, std::string const & unit) -> double
        timeSigma(Blob self, double tt)
        timeSigma(Blob self, double tt, std::string const & unit)
        """
        return _std.Blob_timeSigma(self, *args)


    def magnetizationParameter(self, *args):
        """
        magnetizationParameter(Blob self, double rr)
        magnetizationParameter(Blob self) -> double
        """
        return _std.Blob_magnetizationParameter(self, *args)


    def kappaIndex(self, *args):
        """
        kappaIndex(Blob self) -> double
        kappaIndex(Blob self, double arg2)
        """
        return _std.Blob_kappaIndex(self, *args)


    def magneticConfiguration(self, *args):
        """
        magneticConfiguration(Blob self, std::string config)
        magneticConfiguration(Blob self) -> std::string
        """
        return _std.Blob_magneticConfiguration(self, *args)


    def radiativeQ(self, *args):
        """
        radiativeQ(Blob self, double [] Inu, double [] Taunu, double const [] nu_em, size_t nbnu, double dsem, vector_double coord_ph, double const [8] coord_obj=0)
        radiativeQ(Blob self, double [] Inu, double [] Taunu, double const [] nu_em, size_t nbnu, double dsem, vector_double coord_ph)
        radiativeQ(Blob self, double [] Inu, double [] Qnu, double [] Unu, double [] Vnu, Eigen::Matrix4d [] Onu, double const [] nu_ems, size_t nbnu, double dsem, vector_double coord_ph, double const [8] coord_obj)
        """
        return _std.Blob_radiativeQ(self, *args)


    def __init__(self, *args):
        """
        __init__(Gyoto::Astrobj::Blob self) -> Blob
        __init__(Gyoto::Astrobj::Blob self, Blob orig) -> Blob
        __init__(Gyoto::Astrobj::Blob self, Astrobj base) -> Blob
        __init__(Gyoto::Astrobj::Blob self, long address) -> Blob



        Copy constructor. 
        """
        this = _std.new_Blob(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
Blob_swigregister = _std.Blob_swigregister
Blob_swigregister(Blob)
Blob.properties = _std.cvar.Blob_properties
Blob.builtinPluginValue = _std.cvar.Blob_builtinPluginValue

class Plasmoid(gyoto.core.FitsRW, UniformSphere):
    """


    Plasmoid Shere of plasma emitting synchrotron, following a trajectory
    specified in getVelocity (non-geodesic a priori)

    C++ includes: GyotoPlasmoid.h 
    """

    __swig_setmethods__ = {}
    for _s in [gyoto.core.FitsRW, UniformSphere]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Plasmoid, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.FitsRW, UniformSphere]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Plasmoid, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(Plasmoid self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.Plasmoid_getProperties(self)


    def plugins(self, *args):
        """
        plugins(Plasmoid self, vector_string plugname)
        plugins(Plasmoid self) -> vector_string
        """
        return _std.Plasmoid_plugins(self, *args)


    def clone(self):
        """clone(Plasmoid self) -> Plasmoid"""
        return _std.Plasmoid_clone(self)

    __swig_destroy__ = _std.delete_Plasmoid
    __del__ = lambda self: None

    def className(self):
        """
        className(Plasmoid self) -> std::string



        "Plasmoid" 
        """
        return _std.Plasmoid_className(self)


    def className_l(self):
        """
        className_l(Plasmoid self) -> std::string



        "inflate_star" 
        """
        return _std.Plasmoid_className_l(self)


    def motionType(self, type):
        """motionType(Plasmoid self, std::string const type)"""
        return _std.Plasmoid_motionType(self, type)


    def metric(self, *args):
        """
        metric(Plasmoid self) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >
        metric(Plasmoid self, Gyoto::SmartPointer< Gyoto::Metric::Generic > gg)



        Set the Metric gg_. 
        """
        return _std.Plasmoid_metric(self, *args)


    def initPosition(self, *args):
        """
        initPosition(Plasmoid self, vector_double v)
        initPosition(Plasmoid self) -> vector_double
        """
        return _std.Plasmoid_initPosition(self, *args)


    def initVelocity(self, *args):
        """
        initVelocity(Plasmoid self, vector_double v)
        initVelocity(Plasmoid self) -> vector_double
        """
        return _std.Plasmoid_initVelocity(self, *args)


    def initCoord(self, *args):
        """
        initCoord(Plasmoid self, vector_double v)
        initCoord(Plasmoid self) -> vector_double
        """
        return _std.Plasmoid_initCoord(self, *args)


    def radiusMax(self, *args):
        """
        radiusMax(Plasmoid self, double rr)
        radiusMax(Plasmoid self) -> double
        """
        return _std.Plasmoid_radiusMax(self, *args)


    def Radius(self, vary):
        """Radius(Plasmoid self, std::string vary)"""
        return _std.Plasmoid_Radius(self, vary)


    def radiativeQ(self, Inu, Taunu, nu_em, nbnu, dsem, coord_ph, coord_obj=0):
        """
        radiativeQ(Plasmoid self, double [] Inu, double [] Taunu, double const [] nu_em, size_t nbnu, double dsem, vector_double coord_ph, double const [8] coord_obj=0)
        radiativeQ(Plasmoid self, double [] Inu, double [] Taunu, double const [] nu_em, size_t nbnu, double dsem, vector_double coord_ph)



        Compute the increment of Stokes parameters and transmission matrix.
        Polarised version of RadiaveQ.

        First function to be called for radiative quantities. If exist, i.e.
        implemented in an Astrobj, return the Stokes parameters emitted by the
        small volume of length dsem.

        Warning : The basis used to determine the Stokes coefficients is
        different from the observer parallel transported polarisation basis.
        One should use getChi function to compute the angle between these two
        basis.

        The non polarized case must also be implemented in this function to
        avoid error.

        See exemple in SimplePolarStar.C.

        Parameters:
        -----------

        Inu[nbnu]:  Output increment of intensity (must be set to a previously
        allocated array of doubles)

        Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
        previously allocated array of doubles)

        Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
        previously allocated array of doubles)

        Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
        previously allocated array of doubles)

        Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
        previously allocated array of Matrix4d)

        nu_em[nbnu]:  Frequencies at emission

        nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

        dsem:  Length over which to integrate inside the object

        cph:   Photon coordinate

        co:  Emitter coordinate at current photon position

        Increment of the Stokes parameters (I,Q,U,V) and local Transmission
        matrix (O). 
        """
        return _std.Plasmoid_radiativeQ(self, Inu, Taunu, nu_em, nbnu, dsem, coord_ph, coord_obj)


    def getCartesian(self, dates, n_dates, x, y, z, xprime=None, yprime=None, zprime=None):
        """
        getCartesian(Plasmoid self, double const *const dates, size_t const n_dates, double *const x, double *const y, double *const z, double *const xprime=None, double *const yprime=None, double *const zprime=None)
        getCartesian(Plasmoid self, double const *const dates, size_t const n_dates, double *const x, double *const y, double *const z, double *const xprime=None, double *const yprime=None)
        getCartesian(Plasmoid self, double const *const dates, size_t const n_dates, double *const x, double *const y, double *const z, double *const xprime=None)
        getCartesian(Plasmoid self, double const *const dates, size_t const n_dates, double *const x, double *const y, double *const z)



        Yield the Cartesian coordinates of the center of the sphere.

        If the coordinate system of the Metric object is spherical, use a
        trivial conversion. 
        """
        return _std.Plasmoid_getCartesian(self, dates, n_dates, x, y, z, xprime, yprime, zprime)


    def getVelocity(self, pos, vel):
        """
        getVelocity(Plasmoid self, double const [4] pos, double [4] vel)



        Yield velocity of the center of the sphere. 
        """
        return _std.Plasmoid_getVelocity(self, pos, vel)


    def Impact(self, ph, index, data=None):
        """
        Impact(Plasmoid self, Photon ph, size_t index, AstrobjProperties data=None) -> int
        Impact(Plasmoid self, Photon ph, size_t index) -> int



        Does a photon at these coordinates impact the object?

        Impact() checks whether a Photon impacts the object between two
        integration steps of the photon's trajectory (those two steps are
        photon->getCoord(index, coord1) and photon->getCoord(index+1,
        coord2)). Impact returns 1 if the photon impacts the object between
        these two steps, else 0. In many cases of geometrically thick obects,
        the implementation Astrobj::Standard::Impact() will be fine.

        Impact will call Generic::processHitQuantities() (which is virtual and
        may be re-implemented) to compute observable properties on demand: if
        the data pointer is non-NULL, the object will look in it for pointers
        to properties which apply to its kind. If a pointer to a property
        known to this object is present, then the property is computed and
        store at the pointed-to address. For instance, all objects know the
        "intensity" property. If data->intensity != NULL, the instensity is
        computed and stored in *data->intensity.

        If data is non-NULL and only in this case, processHitQuantities() will
        also call ph->transmit() to update the transmissions of the Photon
        (see Photon::transmit(size_t, double)). This must not be done if data
        is NULL (see Astrobj::Complex::Impact() for an explanation).

        Impact() may not extend the ph Worldline. The only two dates that are
        guaranteed to be defined are at indices index and index+1.

        Parameters:
        -----------

        ph:   Gyoto::Photon aimed at the object;

        index:  Index of the last photon step;

        data:  Pointer to a structure to hold the observables at impact.

        1 if impact, 0 if not. 
        """
        return _std.Plasmoid_Impact(self, ph, index, data)


    def file(self, f):
        """file(Plasmoid self, std::string const & f)"""
        return _std.Plasmoid_file(self, f)


    def fitsRead(self, filename):
        """fitsRead(Plasmoid self, std::string filename) -> std::vector< size_t,std::allocator< size_t > >"""
        return _std.Plasmoid_fitsRead(self, filename)


    def __init__(self, *args):
        """
        __init__(Gyoto::Astrobj::Plasmoid self) -> Plasmoid
        __init__(Gyoto::Astrobj::Plasmoid self, Plasmoid orig) -> Plasmoid
        __init__(Gyoto::Astrobj::Plasmoid self, Astrobj base) -> Plasmoid
        __init__(Gyoto::Astrobj::Plasmoid self, long address) -> Plasmoid



        Copy constructor. 
        """
        this = _std.new_Plasmoid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
Plasmoid_swigregister = _std.Plasmoid_swigregister
Plasmoid_swigregister(Plasmoid)
Plasmoid.properties = _std.cvar.Plasmoid_properties
Plasmoid.builtinPluginValue = _std.cvar.Plasmoid_builtinPluginValue

class FlaredDiskSynchrotron(gyoto.core.StandardAstrobj, gyoto.core.GridData2D, gyoto.core.Listener):
    """Proxy of C++ Gyoto::Astrobj::FlaredDiskSynchrotron class."""

    __swig_setmethods__ = {}
    for _s in [gyoto.core.StandardAstrobj, gyoto.core.GridData2D, gyoto.core.Listener]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FlaredDiskSynchrotron, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.StandardAstrobj, gyoto.core.GridData2D, gyoto.core.Listener]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FlaredDiskSynchrotron, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(FlaredDiskSynchrotron self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.FlaredDiskSynchrotron_getProperties(self)


    def plugins(self, *args):
        """
        plugins(FlaredDiskSynchrotron self, vector_string plugname)
        plugins(FlaredDiskSynchrotron self) -> vector_string
        """
        return _std.FlaredDiskSynchrotron_plugins(self, *args)


    def isThreadSafe(self):
        """
        isThreadSafe(FlaredDiskSynchrotron self) -> bool



        Whether this class is thread-safe.

        Return True if this object is thread-safe, i.e. if an instance and its
        clone can be used in parallel threads (in the context of
        Scenery::raytrace()). Known objects which are not thread-safe include
        Lorene metrics and everything from the Python plug-in.

        The default implementation considers that the class itself is thread
        safe and recurses into the declared properties to check whether they
        are safe too. Classes that abide to the Object/Property paradigm and
        are themselves thread-safe have nothing special to do.

        Objects that clone children in their copy constructor that are not
        declared as properties must take these children into account.

        Classes that are never thread-safe must declare it. It acn be easily
        done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
        GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. 
        """
        return _std.FlaredDiskSynchrotron_isThreadSafe(self)


    def clone(self):
        """
        clone(FlaredDiskSynchrotron self) -> FlaredDiskSynchrotron



        Cloner. 
        """
        return _std.FlaredDiskSynchrotron_clone(self)

    __swig_destroy__ = _std.delete_FlaredDiskSynchrotron
    __del__ = lambda self: None

    def file(self, *args):
        """
        file(FlaredDiskSynchrotron self, std::string const & f)
        file(FlaredDiskSynchrotron self) -> std::string
        """
        return _std.FlaredDiskSynchrotron_file(self, *args)


    def hoverR(self, *args):
        """
        hoverR(FlaredDiskSynchrotron self, double const hor)
        hoverR(FlaredDiskSynchrotron self) -> double
        """
        return _std.FlaredDiskSynchrotron_hoverR(self, *args)


    def timeTranslation_inMunit(self, *args):
        """
        timeTranslation_inMunit(FlaredDiskSynchrotron self, double const dt)
        timeTranslation_inMunit(FlaredDiskSynchrotron self) -> double
        """
        return _std.FlaredDiskSynchrotron_timeTranslation_inMunit(self, *args)


    def magnetizationParameter(self, *args):
        """
        magnetizationParameter(FlaredDiskSynchrotron self, double rr)
        magnetizationParameter(FlaredDiskSynchrotron self) -> double
        """
        return _std.FlaredDiskSynchrotron_magnetizationParameter(self, *args)


    def kappaIndex(self, *args):
        """
        kappaIndex(FlaredDiskSynchrotron self, double index)
        kappaIndex(FlaredDiskSynchrotron self) -> double
        """
        return _std.FlaredDiskSynchrotron_kappaIndex(self, *args)


    def numberDensityMax(self, *args):
        """
        numberDensityMax(FlaredDiskSynchrotron self) -> double
        numberDensityMax(FlaredDiskSynchrotron self, std::string const & unit) -> double
        numberDensityMax(FlaredDiskSynchrotron self, double dens)
        numberDensityMax(FlaredDiskSynchrotron self, double dens, std::string const & unit)
        """
        return _std.FlaredDiskSynchrotron_numberDensityMax(self, *args)


    def temperatureMax(self, *args):
        """
        temperatureMax(FlaredDiskSynchrotron self, double tt)
        temperatureMax(FlaredDiskSynchrotron self) -> double
        """
        return _std.FlaredDiskSynchrotron_temperatureMax(self, *args)


    def polytropicIndex(self, *args):
        """
        polytropicIndex(FlaredDiskSynchrotron self, double gamma)
        polytropicIndex(FlaredDiskSynchrotron self) -> double
        """
        return _std.FlaredDiskSynchrotron_polytropicIndex(self, *args)


    def betaAtMax(self, *args):
        """
        betaAtMax(FlaredDiskSynchrotron self, double beta)
        betaAtMax(FlaredDiskSynchrotron self) -> double
        """
        return _std.FlaredDiskSynchrotron_betaAtMax(self, *args)


    def copyDensity(self, density, naxes):
        """copyDensity(FlaredDiskSynchrotron self, double const *const density, size_t const [3] naxes)"""
        return _std.FlaredDiskSynchrotron_copyDensity(self, density, naxes)


    def getDensity(self):
        """getDensity(FlaredDiskSynchrotron self) -> double const *"""
        return _std.FlaredDiskSynchrotron_getDensity(self)


    def copyVelocity(self, velocity, naxes):
        """copyVelocity(FlaredDiskSynchrotron self, double const *const velocity, size_t const [3] naxes)"""
        return _std.FlaredDiskSynchrotron_copyVelocity(self, velocity, naxes)


    def copyBvector(self, Bvector, naxes):
        """copyBvector(FlaredDiskSynchrotron self, double const *const Bvector, size_t const [3] naxes)"""
        return _std.FlaredDiskSynchrotron_copyBvector(self, Bvector, naxes)


    def getBvector(self):
        """getBvector(FlaredDiskSynchrotron self) -> double const *"""
        return _std.FlaredDiskSynchrotron_getBvector(self)


    def copyTimeArray(self, time_array, ntimes):
        """copyTimeArray(FlaredDiskSynchrotron self, double const *const time_array, size_t const ntimes)"""
        return _std.FlaredDiskSynchrotron_copyTimeArray(self, time_array, ntimes)


    def getTimeArray(self):
        """getTimeArray(FlaredDiskSynchrotron self) -> double const *"""
        return _std.FlaredDiskSynchrotron_getTimeArray(self)


    def metric(self, *args):
        """
        metric(FlaredDiskSynchrotron self) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >
        metric(FlaredDiskSynchrotron self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)



        Set the Metric gg_. 
        """
        return _std.FlaredDiskSynchrotron_metric(self, *args)


    def fitsRead(self, filename):
        """fitsRead(FlaredDiskSynchrotron self, std::string filename) -> std::vector< size_t,std::allocator< size_t > >"""
        return _std.FlaredDiskSynchrotron_fitsRead(self, filename)


    def __call__(self, coord):
        """__call__(FlaredDiskSynchrotron self, double const [4] coord) -> double"""
        return _std.FlaredDiskSynchrotron___call__(self, coord)


    def radiativeQ(self, Inu, Taunu, nu_ems, nbnu, dsem, coord_ph, coord_obj):
        """
        radiativeQ(FlaredDiskSynchrotron self, double [] Inu, double [] Taunu, double const [] nu_ems, size_t nbnu, double dsem, vector_double coord_ph, double const [8] coord_obj)



        Compute the increment of Stokes parameters and transmission matrix.
        Polarised version of RadiaveQ.

        First function to be called for radiative quantities. If exist, i.e.
        implemented in an Astrobj, return the Stokes parameters emitted by the
        small volume of length dsem.

        Warning : The basis used to determine the Stokes coefficients is
        different from the observer parallel transported polarisation basis.
        One should use getChi function to compute the angle between these two
        basis.

        The non polarized case must also be implemented in this function to
        avoid error.

        See exemple in SimplePolarStar.C.

        Parameters:
        -----------

        Inu[nbnu]:  Output increment of intensity (must be set to a previously
        allocated array of doubles)

        Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
        previously allocated array of doubles)

        Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
        previously allocated array of doubles)

        Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
        previously allocated array of doubles)

        Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
        previously allocated array of Matrix4d)

        nu_em[nbnu]:  Frequencies at emission

        nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

        dsem:  Length over which to integrate inside the object

        cph:   Photon coordinate

        co:  Emitter coordinate at current photon position

        Increment of the Stokes parameters (I,Q,U,V) and local Transmission
        matrix (O). 
        """
        return _std.FlaredDiskSynchrotron_radiativeQ(self, Inu, Taunu, nu_ems, nbnu, dsem, coord_ph, coord_obj)


    def getVelocity(self, *args):
        """
        getVelocity(FlaredDiskSynchrotron self) -> double const
        getVelocity(FlaredDiskSynchrotron self, double const [4] pos, double [4] vel)



        Fluid velocity field.

        Fill vel with the 4-vector velocity of the fluid at 4-position pos.

        Parameters:
        -----------

        pos:  4-position at which to compute velocity;

        vel:  4-velocity at pos. 
        """
        return _std.FlaredDiskSynchrotron_getVelocity(self, *args)


    def __init__(self, *args):
        """
        __init__(Gyoto::Astrobj::FlaredDiskSynchrotron self) -> FlaredDiskSynchrotron
        __init__(Gyoto::Astrobj::FlaredDiskSynchrotron self, FlaredDiskSynchrotron arg2) -> FlaredDiskSynchrotron
        __init__(Gyoto::Astrobj::FlaredDiskSynchrotron self, Astrobj base) -> FlaredDiskSynchrotron
        __init__(Gyoto::Astrobj::FlaredDiskSynchrotron self, long address) -> FlaredDiskSynchrotron



        Copy constructor. 
        """
        this = _std.new_FlaredDiskSynchrotron(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
FlaredDiskSynchrotron_swigregister = _std.FlaredDiskSynchrotron_swigregister
FlaredDiskSynchrotron_swigregister(FlaredDiskSynchrotron)
FlaredDiskSynchrotron.properties = _std.cvar.FlaredDiskSynchrotron_properties
FlaredDiskSynchrotron.builtinPluginValue = _std.cvar.FlaredDiskSynchrotron_builtinPluginValue

class ThinDiskGridIntensity(gyoto.core.ThinDisk, gyoto.core.GridData2D, gyoto.core.Listener):
    """Proxy of C++ Gyoto::Astrobj::ThinDiskGridIntensity class."""

    __swig_setmethods__ = {}
    for _s in [gyoto.core.ThinDisk, gyoto.core.GridData2D, gyoto.core.Listener]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ThinDiskGridIntensity, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.ThinDisk, gyoto.core.GridData2D, gyoto.core.Listener]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ThinDiskGridIntensity, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(ThinDiskGridIntensity self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.ThinDiskGridIntensity_getProperties(self)


    def plugins(self, *args):
        """
        plugins(ThinDiskGridIntensity self, vector_string plugname)
        plugins(ThinDiskGridIntensity self) -> vector_string
        """
        return _std.ThinDiskGridIntensity_plugins(self, *args)


    def isThreadSafe(self):
        """
        isThreadSafe(ThinDiskGridIntensity self) -> bool



        Whether this class is thread-safe.

        Return True if this object is thread-safe, i.e. if an instance and its
        clone can be used in parallel threads (in the context of
        Scenery::raytrace()). Known objects which are not thread-safe include
        Lorene metrics and everything from the Python plug-in.

        The default implementation considers that the class itself is thread
        safe and recurses into the declared properties to check whether they
        are safe too. Classes that abide to the Object/Property paradigm and
        are themselves thread-safe have nothing special to do.

        Objects that clone children in their copy constructor that are not
        declared as properties must take these children into account.

        Classes that are never thread-safe must declare it. It acn be easily
        done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
        GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. 
        """
        return _std.ThinDiskGridIntensity_isThreadSafe(self)


    def clone(self):
        """
        clone(ThinDiskGridIntensity self) -> ThinDiskGridIntensity



        Cloner. 
        """
        return _std.ThinDiskGridIntensity_clone(self)

    __swig_destroy__ = _std.delete_ThinDiskGridIntensity
    __del__ = lambda self: None

    def file(self, *args):
        """
        file(ThinDiskGridIntensity self, std::string const & f)
        file(ThinDiskGridIntensity self) -> std::string
        """
        return _std.ThinDiskGridIntensity_file(self, *args)


    def timeTranslation_inMunit(self, *args):
        """
        timeTranslation_inMunit(ThinDiskGridIntensity self, double const dt)
        timeTranslation_inMunit(ThinDiskGridIntensity self) -> double
        """
        return _std.ThinDiskGridIntensity_timeTranslation_inMunit(self, *args)


    def copyIntensity(self, intensity, naxes):
        """copyIntensity(ThinDiskGridIntensity self, double const *const intensity, size_t const [3] naxes)"""
        return _std.ThinDiskGridIntensity_copyIntensity(self, intensity, naxes)


    def getIntensity(self):
        """getIntensity(ThinDiskGridIntensity self) -> double const *"""
        return _std.ThinDiskGridIntensity_getIntensity(self)


    def copyTimeArray(self, time_array, ntimes):
        """copyTimeArray(ThinDiskGridIntensity self, double const *const time_array, size_t const ntimes)"""
        return _std.ThinDiskGridIntensity_copyTimeArray(self, time_array, ntimes)


    def getTimeArray(self):
        """getTimeArray(ThinDiskGridIntensity self) -> double const *"""
        return _std.ThinDiskGridIntensity_getTimeArray(self)


    def metric(self, *args):
        """
        metric(ThinDiskGridIntensity self) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >
        metric(ThinDiskGridIntensity self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)



        Set the Metric gg_. 
        """
        return _std.ThinDiskGridIntensity_metric(self, *args)


    def fitsRead(self, filename):
        """fitsRead(ThinDiskGridIntensity self, std::string filename) -> std::vector< size_t,std::allocator< size_t > >"""
        return _std.ThinDiskGridIntensity_fitsRead(self, filename)


    def emission(self, nu_em, dsem, c_ph, c_obj=0):
        """
        emission(ThinDiskGridIntensity self, double nu_em, double dsem, vector_double c_ph, double const [8] c_obj=0) -> double
        emission(ThinDiskGridIntensity self, double nu_em, double dsem, vector_double c_ph) -> double



        Obsolete, update your code. 
        """
        return _std.ThinDiskGridIntensity_emission(self, nu_em, dsem, c_ph, c_obj)


    def getVelocity(self, pos, vel):
        """
        getVelocity(ThinDiskGridIntensity self, double const [4] pos, double [4] vel)



        Get fluid 4-velocity at point.

        Fill vel with the 4-vector velocity of the fluid at 4-position pos.
        getVelocity() should work at some distance from the equatorial plane.
        The default implementation calls Metric::Generic::circularVelocity().

        Parameters:
        -----------

        pos:  4-position at which to compute velocity;

        vel:  4-velocity at pos. 
        """
        return _std.ThinDiskGridIntensity_getVelocity(self, pos, vel)


    def __init__(self, *args):
        """
        __init__(Gyoto::Astrobj::ThinDiskGridIntensity self) -> ThinDiskGridIntensity
        __init__(Gyoto::Astrobj::ThinDiskGridIntensity self, ThinDiskGridIntensity arg2) -> ThinDiskGridIntensity
        __init__(Gyoto::Astrobj::ThinDiskGridIntensity self, Astrobj base) -> ThinDiskGridIntensity
        __init__(Gyoto::Astrobj::ThinDiskGridIntensity self, long address) -> ThinDiskGridIntensity



        Copy constructor. 
        """
        this = _std.new_ThinDiskGridIntensity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
ThinDiskGridIntensity_swigregister = _std.ThinDiskGridIntensity_swigregister
ThinDiskGridIntensity_swigregister(ThinDiskGridIntensity)
ThinDiskGridIntensity.properties = _std.cvar.ThinDiskGridIntensity_properties
ThinDiskGridIntensity.builtinPluginValue = _std.cvar.ThinDiskGridIntensity_builtinPluginValue

class ThickDisk(gyoto.core.StandardAstrobj, gyoto.core.Listener):
    """


    A thick accretion disk described by its inner radius and the fwhm of
    the Gaussian factor affecting the density out of the equatorial plane.

    Density is assumed to follow a r^{-2} law while temperature is a power
    law with a specified slope.

    This astrobj emits thermal synchrotron.

    C++ includes: GyotoThickDisk.h 
    """

    __swig_setmethods__ = {}
    for _s in [gyoto.core.StandardAstrobj, gyoto.core.Listener]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ThickDisk, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.StandardAstrobj, gyoto.core.Listener]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ThickDisk, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(ThickDisk self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.ThickDisk_getProperties(self)


    def plugins(self, *args):
        """
        plugins(ThickDisk self, vector_string plugname)
        plugins(ThickDisk self) -> vector_string
        """
        return _std.ThickDisk_plugins(self, *args)


    def isThreadSafe(self):
        """
        isThreadSafe(ThickDisk self) -> bool



        Whether this class is thread-safe.

        Return True if this object is thread-safe, i.e. if an instance and its
        clone can be used in parallel threads (in the context of
        Scenery::raytrace()). Known objects which are not thread-safe include
        Lorene metrics and everything from the Python plug-in.

        The default implementation considers that the class itself is thread
        safe and recurses into the declared properties to check whether they
        are safe too. Classes that abide to the Object/Property paradigm and
        are themselves thread-safe have nothing special to do.

        Objects that clone children in their copy constructor that are not
        declared as properties must take these children into account.

        Classes that are never thread-safe must declare it. It acn be easily
        done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
        GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. 
        """
        return _std.ThickDisk_isThreadSafe(self)


    def clone(self):
        """
        clone(ThickDisk self) -> ThickDisk



        Cloner. 
        """
        return _std.ThickDisk_clone(self)

    __swig_destroy__ = _std.delete_ThickDisk
    __del__ = lambda self: None

    def thickDiskInnerRadius(self, *args):
        """
        thickDiskInnerRadius(ThickDisk self, double hh)
        thickDiskInnerRadius(ThickDisk self) -> double
        """
        return _std.ThickDisk_thickDiskInnerRadius(self, *args)


    def thickDiskZGaussianSigma(self, *args):
        """
        thickDiskZGaussianSigma(ThickDisk self, double sig)
        thickDiskZGaussianSigma(ThickDisk self) -> double
        """
        return _std.ThickDisk_thickDiskZGaussianSigma(self, *args)


    def useSelfAbsorption(self, *args):
        """
        useSelfAbsorption(ThickDisk self, bool abs)
        useSelfAbsorption(ThickDisk self) -> bool
        """
        return _std.ThickDisk_useSelfAbsorption(self, *args)


    def veloParam(self, *args):
        """
        veloParam(ThickDisk self, vector_double v)
        veloParam(ThickDisk self) -> vector_double
        """
        return _std.ThickDisk_veloParam(self, *args)


    def numberDensityAtInnerRadius(self, *args):
        """
        numberDensityAtInnerRadius(ThickDisk self) -> double
        numberDensityAtInnerRadius(ThickDisk self, std::string const & unit) -> double
        numberDensityAtInnerRadius(ThickDisk self, double ne)
        numberDensityAtInnerRadius(ThickDisk self, double dens, std::string const & unit)
        """
        return _std.ThickDisk_numberDensityAtInnerRadius(self, *args)


    def temperatureAtInnerRadius(self, *args):
        """
        temperatureAtInnerRadius(ThickDisk self, double tt)
        temperatureAtInnerRadius(ThickDisk self) -> double
        """
        return _std.ThickDisk_temperatureAtInnerRadius(self, *args)


    def temperatureSlope(self, *args):
        """
        temperatureSlope(ThickDisk self, double ss)
        temperatureSlope(ThickDisk self) -> double
        """
        return _std.ThickDisk_temperatureSlope(self, *args)


    def densitySlope(self, *args):
        """
        densitySlope(ThickDisk self, double ss)
        densitySlope(ThickDisk self) -> double
        """
        return _std.ThickDisk_densitySlope(self, *args)


    def magnetizationParameter(self, *args):
        """
        magnetizationParameter(ThickDisk self, double rr)
        magnetizationParameter(ThickDisk self) -> double
        """
        return _std.ThickDisk_magnetizationParameter(self, *args)


    def magneticConfiguration(self, *args):
        """
        magneticConfiguration(ThickDisk self, std::string config)
        magneticConfiguration(ThickDisk self) -> std::string
        """
        return _std.ThickDisk_magneticConfiguration(self, *args)


    def metric(self, *args):
        """
        metric(ThickDisk self) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >
        metric(ThickDisk self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)
        metric(ThickDisk self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)



        Get the Metric gg_. 
        """
        return _std.ThickDisk_metric(self, *args)


    def __call__(self, coord):
        """__call__(ThickDisk self, double const [4] coord) -> double"""
        return _std.ThickDisk___call__(self, coord)


    def getVelocity(self, pos, vel):
        """
        getVelocity(ThickDisk self, double const [4] pos, double [4] vel)



        Fluid velocity field.

        Fill vel with the 4-vector velocity of the fluid at 4-position pos.

        Parameters:
        -----------

        pos:  4-position at which to compute velocity;

        vel:  4-velocity at pos. 
        """
        return _std.ThickDisk_getVelocity(self, pos, vel)


    def radiativeQ(self, *args):
        """
        radiativeQ(ThickDisk self, double [] Inu, double [] Taunu, double const [] nu_em, size_t nbnu, double dsem, vector_double coord_ph, double const [8] coord_obj=0)
        radiativeQ(ThickDisk self, double [] Inu, double [] Taunu, double const [] nu_em, size_t nbnu, double dsem, vector_double coord_ph)
        radiativeQ(ThickDisk self, double * Inu, double * Qnu, double * Unu, double * Vnu, Eigen::Matrix4d * Onu, double const * nuem, size_t nbnu, double dsem, vector_double cph, double const * co)
        """
        return _std.ThickDisk_radiativeQ(self, *args)


    def __init__(self, *args):
        """
        __init__(Gyoto::Astrobj::ThickDisk self) -> ThickDisk
        __init__(Gyoto::Astrobj::ThickDisk self, ThickDisk arg2) -> ThickDisk
        __init__(Gyoto::Astrobj::ThickDisk self, Astrobj base) -> ThickDisk
        __init__(Gyoto::Astrobj::ThickDisk self, long address) -> ThickDisk



        Copy constructor. 
        """
        this = _std.new_ThickDisk(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
ThickDisk_swigregister = _std.ThickDisk_swigregister
ThickDisk_swigregister(ThickDisk)
ThickDisk.properties = _std.cvar.ThickDisk_properties
ThickDisk.builtinPluginValue = _std.cvar.ThickDisk_builtinPluginValue

class SphericalAccretion(gyoto.core.StandardAstrobj, gyoto.core.Listener):
    """


    A spherically-symmetric accretion flow radially falling onto the
    central object.

    Density is assumed to follow a r^{-2} law while temperature is a power
    law with a specified slope.

    This astrobj emits thermal synchrotron.

    C++ includes: GyotoSphericalAccretion.h 
    """

    __swig_setmethods__ = {}
    for _s in [gyoto.core.StandardAstrobj, gyoto.core.Listener]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SphericalAccretion, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.StandardAstrobj, gyoto.core.Listener]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SphericalAccretion, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(SphericalAccretion self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.SphericalAccretion_getProperties(self)


    def plugins(self, *args):
        """
        plugins(SphericalAccretion self, vector_string plugname)
        plugins(SphericalAccretion self) -> vector_string
        """
        return _std.SphericalAccretion_plugins(self, *args)


    def isThreadSafe(self):
        """
        isThreadSafe(SphericalAccretion self) -> bool



        Whether this class is thread-safe.

        Return True if this object is thread-safe, i.e. if an instance and its
        clone can be used in parallel threads (in the context of
        Scenery::raytrace()). Known objects which are not thread-safe include
        Lorene metrics and everything from the Python plug-in.

        The default implementation considers that the class itself is thread
        safe and recurses into the declared properties to check whether they
        are safe too. Classes that abide to the Object/Property paradigm and
        are themselves thread-safe have nothing special to do.

        Objects that clone children in their copy constructor that are not
        declared as properties must take these children into account.

        Classes that are never thread-safe must declare it. It acn be easily
        done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
        GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. 
        """
        return _std.SphericalAccretion_isThreadSafe(self)


    def clone(self):
        """
        clone(SphericalAccretion self) -> SphericalAccretion



        Cloner. 
        """
        return _std.SphericalAccretion_clone(self)

    __swig_destroy__ = _std.delete_SphericalAccretion
    __del__ = lambda self: None

    def useSelfAbsorption(self, *args):
        """
        useSelfAbsorption(SphericalAccretion self, bool abs)
        useSelfAbsorption(SphericalAccretion self) -> bool
        """
        return _std.SphericalAccretion_useSelfAbsorption(self, *args)


    def sphericalAccretionInnerRadius(self, *args):
        """
        sphericalAccretionInnerRadius(SphericalAccretion self, double hh)
        sphericalAccretionInnerRadius(SphericalAccretion self) -> double
        """
        return _std.SphericalAccretion_sphericalAccretionInnerRadius(self, *args)


    def numberDensityAtInnerRadius(self, *args):
        """
        numberDensityAtInnerRadius(SphericalAccretion self) -> double
        numberDensityAtInnerRadius(SphericalAccretion self, std::string const & unit) -> double
        numberDensityAtInnerRadius(SphericalAccretion self, double ne)
        numberDensityAtInnerRadius(SphericalAccretion self, double dens, std::string const & unit)
        """
        return _std.SphericalAccretion_numberDensityAtInnerRadius(self, *args)


    def densitySlope(self, *args):
        """
        densitySlope(SphericalAccretion self, double ss)
        densitySlope(SphericalAccretion self) -> double
        """
        return _std.SphericalAccretion_densitySlope(self, *args)


    def temperatureAtInnerRadius(self, *args):
        """
        temperatureAtInnerRadius(SphericalAccretion self, double tt)
        temperatureAtInnerRadius(SphericalAccretion self) -> double
        """
        return _std.SphericalAccretion_temperatureAtInnerRadius(self, *args)


    def temperatureSlope(self, *args):
        """
        temperatureSlope(SphericalAccretion self, double ss)
        temperatureSlope(SphericalAccretion self) -> double
        """
        return _std.SphericalAccretion_temperatureSlope(self, *args)


    def magnetizationParameter(self, *args):
        """
        magnetizationParameter(SphericalAccretion self, double rr)
        magnetizationParameter(SphericalAccretion self) -> double
        """
        return _std.SphericalAccretion_magnetizationParameter(self, *args)


    def metric(self, *args):
        """
        metric(SphericalAccretion self) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >
        metric(SphericalAccretion self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)
        metric(SphericalAccretion self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)



        Get the Metric gg_. 
        """
        return _std.SphericalAccretion_metric(self, *args)


    def __call__(self, coord):
        """__call__(SphericalAccretion self, double const [4] coord) -> double"""
        return _std.SphericalAccretion___call__(self, coord)


    def radiativeQ(self, Inu, Taunu, nu_em, nbnu, dsem, coord_ph, coord_obj=0):
        """
        radiativeQ(SphericalAccretion self, double [] Inu, double [] Taunu, double const [] nu_em, size_t nbnu, double dsem, vector_double coord_ph, double const [8] coord_obj=0)
        radiativeQ(SphericalAccretion self, double [] Inu, double [] Taunu, double const [] nu_em, size_t nbnu, double dsem, vector_double coord_ph)



        Compute the increment of Stokes parameters and transmission matrix.
        Polarised version of RadiaveQ.

        First function to be called for radiative quantities. If exist, i.e.
        implemented in an Astrobj, return the Stokes parameters emitted by the
        small volume of length dsem.

        Warning : The basis used to determine the Stokes coefficients is
        different from the observer parallel transported polarisation basis.
        One should use getChi function to compute the angle between these two
        basis.

        The non polarized case must also be implemented in this function to
        avoid error.

        See exemple in SimplePolarStar.C.

        Parameters:
        -----------

        Inu[nbnu]:  Output increment of intensity (must be set to a previously
        allocated array of doubles)

        Qnu[nbnu]:  Output increment of Stokes parameter Q (must be set to a
        previously allocated array of doubles)

        Unu[nbnu]:  Output increment of Stokes parameter U (must be set to a
        previously allocated array of doubles)

        Vnu[nbnu]:  Output increment of Stokes parameter V (must be set to a
        previously allocated array of doubles)

        Onu[nbnu]:  Output transmission (Eigen) matrix (must be set to a
        previously allocated array of Matrix4d)

        nu_em[nbnu]:  Frequencies at emission

        nbnu:  Size of nu_em[], Inu[], Qnu[], Unu[], Vnu[], and Onu[]

        dsem:  Length over which to integrate inside the object

        cph:   Photon coordinate

        co:  Emitter coordinate at current photon position

        Increment of the Stokes parameters (I,Q,U,V) and local Transmission
        matrix (O). 
        """
        return _std.SphericalAccretion_radiativeQ(self, Inu, Taunu, nu_em, nbnu, dsem, coord_ph, coord_obj)


    def getVelocity(self, pos, vel):
        """
        getVelocity(SphericalAccretion self, double const [4] pos, double [4] vel)



        Fluid velocity field.

        Fill vel with the 4-vector velocity of the fluid at 4-position pos.

        Parameters:
        -----------

        pos:  4-position at which to compute velocity;

        vel:  4-velocity at pos. 
        """
        return _std.SphericalAccretion_getVelocity(self, pos, vel)


    def __init__(self, *args):
        """
        __init__(Gyoto::Astrobj::SphericalAccretion self) -> SphericalAccretion
        __init__(Gyoto::Astrobj::SphericalAccretion self, SphericalAccretion arg2) -> SphericalAccretion
        __init__(Gyoto::Astrobj::SphericalAccretion self, Astrobj base) -> SphericalAccretion
        __init__(Gyoto::Astrobj::SphericalAccretion self, long address) -> SphericalAccretion



        Copy constructor. 
        """
        this = _std.new_SphericalAccretion(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
SphericalAccretion_swigregister = _std.SphericalAccretion_swigregister
SphericalAccretion_swigregister(SphericalAccretion)
SphericalAccretion.properties = _std.cvar.SphericalAccretion_properties
SphericalAccretion.builtinPluginValue = _std.cvar.SphericalAccretion_builtinPluginValue

class ThinDiskProfile(gyoto.core.ThinDisk):
    """


    A subclass of ThinDisk emitting according to some specified profile
    that should be hardcoded in emission()

    C++ includes: GyotoThinDiskProfile.h 
    """

    __swig_setmethods__ = {}
    for _s in [gyoto.core.ThinDisk]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ThinDiskProfile, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.ThinDisk]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ThinDiskProfile, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(ThinDiskProfile self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.ThinDiskProfile_getProperties(self)


    def plugins(self, *args):
        """
        plugins(ThinDiskProfile self, vector_string plugname)
        plugins(ThinDiskProfile self) -> vector_string
        """
        return _std.ThinDiskProfile_plugins(self, *args)


    def isThreadSafe(self):
        """
        isThreadSafe(ThinDiskProfile self) -> bool



        Whether this class is thread-safe.

        Return True if this object is thread-safe, i.e. if an instance and its
        clone can be used in parallel threads (in the context of
        Scenery::raytrace()). Known objects which are not thread-safe include
        Lorene metrics and everything from the Python plug-in.

        The default implementation considers that the class itself is thread
        safe and recurses into the declared properties to check whether they
        are safe too. Classes that abide to the Object/Property paradigm and
        are themselves thread-safe have nothing special to do.

        Objects that clone children in their copy constructor that are not
        declared as properties must take these children into account.

        Classes that are never thread-safe must declare it. It acn be easily
        done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
        GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. 
        """
        return _std.ThinDiskProfile_isThreadSafe(self)


    def clone(self):
        """
        clone(ThinDiskProfile self) -> ThinDiskProfile



        Cloner. 
        """
        return _std.ThinDiskProfile_clone(self)

    __swig_destroy__ = _std.delete_ThinDiskProfile
    __del__ = lambda self: None

    def circularMotion(self, *args):
        """
        circularMotion(ThinDiskProfile self) -> bool
        circularMotion(ThinDiskProfile self, bool circ)
        """
        return _std.ThinDiskProfile_circularMotion(self, *args)


    def model_param(self, *args):
        """
        model_param(ThinDiskProfile self, vector_double v)
        model_param(ThinDiskProfile self) -> vector_double
        """
        return _std.ThinDiskProfile_model_param(self, *args)


    def emission(self, nu_em, dsem, c_ph, c_obj=0):
        """
        emission(ThinDiskProfile self, double nu_em, double dsem, vector_double c_ph, double const [8] c_obj=0) -> double
        emission(ThinDiskProfile self, double nu_em, double dsem, vector_double c_ph) -> double



        Obsolete, update your code. 
        """
        return _std.ThinDiskProfile_emission(self, nu_em, dsem, c_ph, c_obj)


    def getVelocity(self, pos, vel):
        """
        getVelocity(ThinDiskProfile self, double const [4] pos, double [4] vel)



        Get fluid 4-velocity at point.

        Fill vel with the 4-vector velocity of the fluid at 4-position pos.
        getVelocity() should work at some distance from the equatorial plane.
        The default implementation calls Metric::Generic::circularVelocity().

        Parameters:
        -----------

        pos:  4-position at which to compute velocity;

        vel:  4-velocity at pos. 
        """
        return _std.ThinDiskProfile_getVelocity(self, pos, vel)


    def processHitQuantities(self, ph, coord_ph_hit, coord_obj_hit, dt, data):
        """processHitQuantities(ThinDiskProfile self, Photon ph, vector_double coord_ph_hit, double const * coord_obj_hit, double dt, AstrobjProperties data)"""
        return _std.ThinDiskProfile_processHitQuantities(self, ph, coord_ph_hit, coord_obj_hit, dt, data)


    def __init__(self, *args):
        """
        __init__(Gyoto::Astrobj::ThinDiskProfile self) -> ThinDiskProfile
        __init__(Gyoto::Astrobj::ThinDiskProfile self, ThinDiskProfile arg2) -> ThinDiskProfile
        __init__(Gyoto::Astrobj::ThinDiskProfile self, Astrobj base) -> ThinDiskProfile
        __init__(Gyoto::Astrobj::ThinDiskProfile self, long address) -> ThinDiskProfile



        Copy constructor. 
        """
        this = _std.new_ThinDiskProfile(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
ThinDiskProfile_swigregister = _std.ThinDiskProfile_swigregister
ThinDiskProfile_swigregister(ThinDiskProfile)
ThinDiskProfile.properties = _std.cvar.ThinDiskProfile_properties
ThinDiskProfile.builtinPluginValue = _std.cvar.ThinDiskProfile_builtinPluginValue

class ComplexMetric(gyoto.core.Metric):
    """


    Combine several metrics.

    Adds linearly the contribution of several metrics. All suv-metrics
    must use a common coordinate system.

    C++ includes: GyotoComplexMetric.h 
    """

    __swig_setmethods__ = {}
    for _s in [gyoto.core.Metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ComplexMetric, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.Metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ComplexMetric, name)
    __repr__ = _swig_repr

    def isThreadSafe(self):
        """
        isThreadSafe(ComplexMetric self) -> bool



        Whether this class is thread-safe.

        Return True if this object is thread-safe, i.e. if an instance and its
        clone can be used in parallel threads (in the context of
        Scenery::raytrace()). Known objects which are not thread-safe include
        Lorene metrics and everything from the Python plug-in.

        The default implementation considers that the class itself is thread
        safe and recurses into the declared properties to check whether they
        are safe too. Classes that abide to the Object/Property paradigm and
        are themselves thread-safe have nothing special to do.

        Objects that clone children in their copy constructor that are not
        declared as properties must take these children into account.

        Classes that are never thread-safe must declare it. It acn be easily
        done using GYOTO_OBJECT_THREAD_SAFETY in the class declaration and
        GYOTO_PROPERTY_THREAD_UNSAFE in the class definition. 
        """
        return _std.ComplexMetric_isThreadSafe(self)


    def clone(self):
        """
        clone(ComplexMetric self) -> ComplexMetric



        "Virtual" copy constructor 
        """
        return _std.ComplexMetric_clone(self)

    __swig_destroy__ = _std.delete_ComplexMetric
    __del__ = lambda self: None

    def append(self, element):
        """
        append(ComplexMetric self, Gyoto::SmartPointer< Gyoto::Metric::Generic > element)



        Add element at the end of the array. 
        """
        return _std.ComplexMetric_append(self, element)


    def remove(self, i):
        """
        remove(ComplexMetric self, size_t i)



        Remove i-th element from the array. 
        """
        return _std.ComplexMetric_remove(self, i)


    def getCardinal(self):
        """
        getCardinal(ComplexMetric self) -> size_t



        Get the number of elements in the array. 
        """
        return _std.ComplexMetric_getCardinal(self)


    def fillElement(self, fmp):
        """
        fillElement(ComplexMetric self, FactoryMessenger fmp)



        Fill the XML element for this Object.

        The base implementation simply calls fillProperty() for each Property
        defined for the Object.

        Derived classes should avoid overriding fillElement(). It may make
        sense occasionally, e.g. to make sure that the metric is output first.

        To customize how a given Property is rendered, it is better to
        override fillProperty().

        If this method is overridden, the implementation should in general
        call fillElement() on the direct base. 
        """
        return _std.ComplexMetric_fillElement(self, fmp)


    def setParameters(self, fmp):
        """
        setParameters(ComplexMetric self, FactoryMessenger fmp)



        Main loop for parsing Properties from XML description.

        This function queries the FactoryMessenger for elements to parse, and
        tries to matche each element to a Property to set it  accordingly. Any
        class that tries to be buildable from XML must supply a subcontractor
        (for base classes such as Metric, Astrobj, Spectrum  and Spectrometer,
        it is done as a template that must be  specialized for each class).
        This subcontractor typically looks somewhat like this: Although this
        is discouraged, it is possible to override the following functions to
        customize how XML entities are parsed:    - setParameters() if low-
        level access to the      FactoryMessenger is required;    -
        setParameter(std::string name, std::string content,
        std::string unit)      to interpret an entity that does not match a
        Property      (e.g. alternative name);    -
        setParameter(Gyoto::Property const &p, std::string const &name,
        std::string const &content, std::string const &unit)      to change
        how a Property is interpreted. 
        """
        return _std.ComplexMetric_setParameters(self, fmp)


    def gmunu(self, *args):
        """
        gmunu(ComplexMetric self, double const [4] x, int mu, int nu) -> double
        gmunu(ComplexMetric self, double const [4] IN_ARRAY1)



        Metric coefficients.

        The default implementation calls Metric:: gmunu(double g[4][4], const
        double * pos) const

        Parameters:
        -----------

        x:  4-position at which to compute the coefficient;

        mu:  1st index of coefficient, 03;

        nu:  2nd index of coefficient, 03;

        Metric coefficient g, at point x 
        """
        return _std.ComplexMetric_gmunu(self, *args)


    def jacobian(self, IN_ARRAY1):
        """
        jacobian(ComplexMetric self, double const [4] IN_ARRAY1)



        Derivatives of the metric covariant coefficients.

        The default implementation evaluates them numerically. The gmunu
        matrix is assumed to be symmetrical but no other assumptions are made
        at the moment. 
        """
        return _std.ComplexMetric_jacobian(self, IN_ARRAY1)


    def isStopCondition(self, coord):
        """
        isStopCondition(ComplexMetric self, double const [8] coord) -> int



        Check whether integration should stop.

        The integrating loop will ask this the Metric through this method
        whether or not it is happy to continue the integration. Typically, the
        Metric should answer 0 when everything is fine, 1 when too close to
        the event horizon, inside the BH...

        Parameters:
        -----------

        coord:  8-coordinate vector to check. 
        """
        return _std.ComplexMetric_isStopCondition(self, coord)


    def __getitem__(self, i):
        """__getitem__(ComplexMetric self, size_t i) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >"""
        return _std.ComplexMetric___getitem__(self, i)


    def __setitem__(self, i, p):
        """__setitem__(ComplexMetric self, int i, Metric p)"""
        return _std.ComplexMetric___setitem__(self, i, p)


    def __init__(self, *args):
        """
        Complex() -> ComplexMetric
        Complex(ComplexMetric arg2) -> ComplexMetric
        Complex(Metric base) -> ComplexMetric
        __init__(Gyoto::Metric::Complex self, long address) -> ComplexMetric



        Copy constructor. 
        """
        this = _std.new_ComplexMetric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
ComplexMetric_swigregister = _std.ComplexMetric_swigregister
ComplexMetric_swigregister(ComplexMetric)

class Shift(gyoto.core.Metric, gyoto.core.Listener):
    """


    The Shift flat-space metric.

    Use <Cartesian> or </Spherical> to select the coordinate system kind.

    C++ includes: GyotoShift.h 
    """

    __swig_setmethods__ = {}
    for _s in [gyoto.core.Metric, gyoto.core.Listener]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Shift, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.Metric, gyoto.core.Listener]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Shift, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(Shift self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.Shift_getProperties(self)


    def plugins(self, *args):
        """
        plugins(Shift self, vector_string plugname)
        plugins(Shift self) -> vector_string
        """
        return _std.Shift_plugins(self, *args)

    __swig_destroy__ = _std.delete_Shift
    __del__ = lambda self: None

    def clone(self):
        """
        clone(Shift self) -> Shift



        Virtual copy constructor. 
        """
        return _std.Shift_clone(self)


    def subMetric(self, *args):
        """
        subMetric(Shift self) -> Gyoto::SmartPointer< Gyoto::Metric::Generic >
        subMetric(Shift self, Gyoto::SmartPointer< Gyoto::Metric::Generic > arg2)
        """
        return _std.Shift_subMetric(self, *args)


    def offset(self, *args):
        """
        offset(Shift self) -> vector_double
        offset(Shift self, vector_double arg2)



        Set #pos_ from vector. 
        """
        return _std.Shift_offset(self, *args)


    def mass(self, arg2):
        """
        mass(Shift self, double const arg2)



        Get mass used in unitLength() 
        """
        return _std.Shift_mass(self, arg2)


    def gmunu(self, *args):
        """
        gmunu(Shift self, double const [4] x, int mu, int nu) -> double
        gmunu(Shift self, double const [4] IN_ARRAY1)



        Metric coefficients.

        The default implementation calls Metric:: gmunu(double g[4][4], const
        double * pos) const

        Parameters:
        -----------

        x:  4-position at which to compute the coefficient;

        mu:  1st index of coefficient, 03;

        nu:  2nd index of coefficient, 03;

        Metric coefficient g, at point x 
        """
        return _std.Shift_gmunu(self, *args)


    def gmunu_up(self, *args):
        """
        gmunu_up(Shift self, double const [4] x, int mu, int nu) -> double
        gmunu_up(Shift self, double const [4] IN_ARRAY1)



        Metric contravariant coefficients.

        The default implementation calls Metric:: gmunu_up(double g[4][4],
        const double * pos) const

        Parameters:
        -----------

        x:  4-position at which to compute the coefficient;

        mu:  1st index of coefficient, 03;

        nu:  2nd index of coefficient, 03;

        Metric coefficient g, at point x 
        """
        return _std.Shift_gmunu_up(self, *args)


    def jacobian(self, IN_ARRAY1):
        """
        jacobian(Shift self, double const [4] IN_ARRAY1)



        Derivatives of the metric covariant coefficients.

        The default implementation evaluates them numerically. The gmunu
        matrix is assumed to be symmetrical but no other assumptions are made
        at the moment. 
        """
        return _std.Shift_jacobian(self, IN_ARRAY1)


    def isStopCondition(self, coord):
        """
        isStopCondition(Shift self, double const [8] coord) -> int



        Check whether integration should stop.

        The integrating loop will ask this the Metric through this method
        whether or not it is happy to continue the integration. Typically, the
        Metric should answer 0 when everything is fine, 1 when too close to
        the event horizon, inside the BH...

        Parameters:
        -----------

        coord:  8-coordinate vector to check. 
        """
        return _std.Shift_isStopCondition(self, coord)


    def fillProperty(self, fmp, p):
        """
        fillProperty(Shift self, FactoryMessenger fmp, Property p)



        Output a single Property to XML.

        The base implementation decides what to do based on the p.type. The
        format matches how setParameters() an setParameter() would interpret
        the XML descition.

        Overriding this method should be avoided, but makes sense in some
        cases (for instance Screen::fillProperty() selects a different unit
        for Distance based on its magnitude, so that stellar sizes are
        expressed in solar radii while smaller sizes can be expressed in
        meters and larger sizes in parsecs).

        Overriding implementation should fall-back on calling the
        implementation in the direct parent class: 
        """
        return _std.Shift_fillProperty(self, fmp, p)


    def setParameters(self, fmp):
        """
        setParameters(Shift self, FactoryMessenger fmp)



        Main loop for parsing Properties from XML description.

        This function queries the FactoryMessenger for elements to parse, and
        tries to matche each element to a Property to set it  accordingly. Any
        class that tries to be buildable from XML must supply a subcontractor
        (for base classes such as Metric, Astrobj, Spectrum  and Spectrometer,
        it is done as a template that must be  specialized for each class).
        This subcontractor typically looks somewhat like this: Although this
        is discouraged, it is possible to override the following functions to
        customize how XML entities are parsed:    - setParameters() if low-
        level access to the      FactoryMessenger is required;    -
        setParameter(std::string name, std::string content,
        std::string unit)      to interpret an entity that does not match a
        Property      (e.g. alternative name);    -
        setParameter(Gyoto::Property const &p, std::string const &name,
        std::string const &content, std::string const &unit)      to change
        how a Property is interpreted. 
        """
        return _std.Shift_setParameters(self, fmp)


    def tell(self, msg):
        """
        tell(Shift self, Teller msg)



        This is how a Teller tells.

        A teller will basically call listener->tell(this).

        Parameters:
        -----------

        msg:  Teller* the Teller who is telling... Useful if the Listener
        listens to several Tellers. 
        """
        return _std.Shift_tell(self, msg)


    def circularVelocity(self, IN_ARRAY1):
        """
        circularVelocity(Shift self, double const [4] IN_ARRAY1)



        Yield circular velocity at a given position.

        Give the velocity of a massive particle in circular orbit at the given
        position projected onto the equatorial plane. Such a velocity may not
        exist everywhere (or anywhere) for a given metric. This method is
        intended to be used by Astrobj classes such as Torus or ThinDisk.

        If keplerian_ is set to true, this method should return the Keplerian
        velcity instead (derived classes should ensure this, see
        KerrBL::circularVelocity() for instance).

        The default implementation throws an error if keplerian_ is set to
        false.

        Parameters:
        -----------

        pos:  input: position,

        vel:  output: velocity,

        dir:  1 for corotating, -1 for counterrotating. 
        """
        return _std.Shift_circularVelocity(self, IN_ARRAY1)


    def zamoVelocity(self, IN_ARRAY1):
        """
        zamoVelocity(Shift self, double const [4] IN_ARRAY1)



        Yield ZAMO velocity at a given position.

        Give the velocity of a zero angular momentul observer (whatever is
        closest to "at rest"). The default implementation simply projects
        (1, 0, 0, 0) othogonally along ephi and normalizes it, thus ensuring
        that vel is orthogonal to ephi.

        Parameters:
        -----------

        pos:  input: position,

        vel:  output: velocity, 
        """
        return _std.Shift_zamoVelocity(self, IN_ARRAY1)


    def christoffel(self, *args):
        """
        christoffel(Shift self, double const [4] coord, int const alpha, int const mu, int const nu) -> double
        christoffel(Shift self, double [4][4][4] dst, double const [4] coord) -> int
        christoffel(Shift self, double const [4] IN_ARRAY1)



        Chistoffel symbol.

        Value of Christoffel symbol at point (x1, x2, x3).

        1 on error, 0 otherwise 
        """
        return _std.Shift_christoffel(self, *args)


    def __init__(self, *args):
        """
        __init__(Gyoto::Metric::Shift self) -> Shift
        __init__(Gyoto::Metric::Shift self, Metric base) -> Shift
        __init__(Gyoto::Metric::Shift self, long address) -> Shift
        """
        this = _std.new_Shift(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
Shift_swigregister = _std.Shift_swigregister
Shift_swigregister(Shift)
Shift.properties = _std.cvar.Shift_properties
Shift.builtinPluginValue = _std.cvar.Shift_builtinPluginValue

GYOTO_KERRBL_DEFAULT_DIFFTOL = _std.GYOTO_KERRBL_DEFAULT_DIFFTOL
class KerrBL(gyoto.core.Metric):
    """


    Metric around a Kerr black-hole in Boyer-Lindquist coordinates.

    C++ includes: GyotoKerrBL.h 
    """

    __swig_setmethods__ = {}
    for _s in [gyoto.core.Metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, KerrBL, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.Metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, KerrBL, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(KerrBL self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.KerrBL_getProperties(self)


    def plugins(self, *args):
        """
        plugins(KerrBL self, vector_string plugname)
        plugins(KerrBL self) -> vector_string
        """
        return _std.KerrBL_plugins(self, *args)


    def clone(self):
        """
        clone(KerrBL self) -> KerrBL



        Virtual copy constructor. 
        """
        return _std.KerrBL_clone(self)


    def spin(self, *args):
        """
        spin(KerrBL self, double const spin)
        spin(KerrBL self) -> double



        Returns spin. 
        """
        return _std.KerrBL_spin(self, *args)


    def difftol(self, *args):
        """
        difftol(KerrBL self) -> double
        difftol(KerrBL self, double t)



        Set difftol_. 
        """
        return _std.KerrBL_difftol(self, *args)


    def horizonSecurity(self, *args):
        """
        horizonSecurity(KerrBL self, double drhor)
        horizonSecurity(KerrBL self) -> double
        """
        return _std.KerrBL_horizonSecurity(self, *args)


    def genericIntegrator(self, *args):
        """
        genericIntegrator(KerrBL self, bool arg2)
        genericIntegrator(KerrBL self) -> bool
        """
        return _std.KerrBL_genericIntegrator(self, *args)


    def getRms(self):
        """
        getRms(KerrBL self) -> double



        Returns the marginally stable (ISCO) radius Should be implemented in
        derived classes if useful If called on the base class, returns an
        error 
        """
        return _std.KerrBL_getRms(self)


    def getRmb(self):
        """
        getRmb(KerrBL self) -> double



        Returns the marginally bound radius Should be implemented in derived
        classes if useful If called on the base class, returns an error 
        """
        return _std.KerrBL_getRmb(self)


    def getSpecificAngularMomentum(self, rr):
        """
        getSpecificAngularMomentum(KerrBL self, double rr) -> double



        Returns the specific angular momentum l=-u_phi/u_t Should be
        implemented in derived classes if useful If called on the base class,
        returns an error 
        """
        return _std.KerrBL_getSpecificAngularMomentum(self, rr)


    def getPotential(self, pos, l_cst):
        """
        getPotential(KerrBL self, double const [4] pos, double l_cst) -> double



        Returns potential W=-ln(|u_t|) for a cst specific angular momentum
        l_cst Should be implemented in derived classes if useful If called on
        the base class, returns an error 
        """
        return _std.KerrBL_getPotential(self, pos, l_cst)


    def gmunu(self, *args):
        """
        gmunu(KerrBL self, double const [4] IN_ARRAY1)
        gmunu(KerrBL self, double const [4] x, int mu, int nu) -> double



        Metric coefficients.

        The default implementation calls Metric:: gmunu(double g[4][4], const
        double * pos) const

        Parameters:
        -----------

        x:  4-position at which to compute the coefficient;

        mu:  1st index of coefficient, 03;

        nu:  2nd index of coefficient, 03;

        Metric coefficient g, at point x 
        """
        return _std.KerrBL_gmunu(self, *args)


    def gmunu_up(self, *args):
        """
        gmunu_up(KerrBL self, double const [4] IN_ARRAY1)
        gmunu_up(KerrBL self, double const [4] x, int mu, int nu) -> double



        Metric contravariant coefficients.

        The default implementation calls Metric:: gmunu_up(double g[4][4],
        const double * pos) const

        Parameters:
        -----------

        x:  4-position at which to compute the coefficient;

        mu:  1st index of coefficient, 03;

        nu:  2nd index of coefficient, 03;

        Metric coefficient g, at point x 
        """
        return _std.KerrBL_gmunu_up(self, *args)


    def ScalarProd(self, pos, u1, u2):
        """
        ScalarProd(KerrBL self, double const [4] pos, double const [4] u1, double const [4] u2) -> double



        Scalar product.

        Compute the scalarproduct of the two quadrivectors u1 and u2 in this
        Metric, at point pos expressed in coordinate system sys.

        Parameters:
        -----------

        pos:  4-position;

        u1:  1st quadrivector;

        u2:  2nd quadrivector;

        u1*u2 
        """
        return _std.KerrBL_ScalarProd(self, pos, u1, u2)


    def nullifyCoord(self, *args):
        """
        nullifyCoord(KerrBL self, double [8] coord, double & tdot2)
        nullifyCoord(KerrBL self, double [8] coord)



        Set tdot (coord[4]) such that coord is light-like. Everything is in
        geometrical units.

        Set coord[4] so that the 4-velocity coord[4:7] is lightlike, i.e. of
        norm 0. There may be up to two solutions. coord[4] is set to the
        hightest. The lowest can be retrieved using nullifyCoord(double
        coord[8], double& tdot2) const. Everything is expressed in geometrical
        units.

        Parameters:
        -----------

        coord:  8-position, coord[4] will be set according to the other
        elements; 
        """
        return _std.KerrBL_nullifyCoord(self, *args)


    def MakeCoord(self, coordin, cst, coordout):
        """
        MakeCoord(KerrBL self, double const [8] coordin, double const [5] cst, double [8] coordout)



        Inverse function of MakeMomentumAndCst.

        Computes pr, ptheta, E and L from rdot, thetadot, phidot, tdot 
        """
        return _std.KerrBL_MakeCoord(self, coordin, cst, coordout)


    def MakeMomentum(self, coordin, cst, coordout):
        """
        MakeMomentum(KerrBL self, double const [8] coordin, double const [5] cst, double [8] coordout)



        Transforms from Boyer-Lindquist coordinates
        [t,r,th,phi,tdot,rdot,thdot,phidot] to [t,r,th,phi,pt,pr,pth,pphi]
        where pt,pr... are generalized momenta. 
        """
        return _std.KerrBL_MakeMomentum(self, coordin, cst, coordout)


    def myrk4(self, coor, cst, h, res):
        """
        myrk4(KerrBL self, double const [8] coor, double const [5] cst, double h, double [8] res) -> int



        Obsolete, update your code. 
        """
        return _std.KerrBL_myrk4(self, coor, cst, h, res)


    def myrk4_adaptive(self, *args):
        """
        myrk4_adaptive(KerrBL self, Worldline line, vector_double coor, double lastnorm, double normref, vector_double coor1, double h0, double & h1, double h1max) -> int
        myrk4_adaptive(KerrBL self, Worldline line, vector_double coor, double lastnorm, double normref, vector_double coor1, double h0, double & h1) -> int



        Obsolete, update your code. 
        """
        return _std.KerrBL_myrk4_adaptive(self, *args)


    def diff(self, x, dxdt, mass):
        """diff(KerrBL self, vector_double x, vector_double dxdt, double mass) -> int"""
        return _std.KerrBL_diff(self, x, dxdt, mass)


    def setParticleProperties(self, line, coord):
        """
        setParticleProperties(KerrBL self, Worldline line, double const * coord)



        Set Metric-specific constants of motion. Used e.g. in KerrBL. 
        """
        return _std.KerrBL_setParticleProperties(self, line, coord)


    def isStopCondition(self, coord):
        """
        isStopCondition(KerrBL self, double const [8] coord) -> int



        Check whether integration should stop.

        The integrating loop will ask this the Metric through this method
        whether or not it is happy to continue the integration. Typically, the
        Metric should answer 0 when everything is fine, 1 when too close to
        the event horizon, inside the BH...

        Parameters:
        -----------

        coord:  8-coordinate vector to check. 
        """
        return _std.KerrBL_isStopCondition(self, coord)


    def observerTetrad(self, pos, fourvel, screen1, screen2, screen3):
        """
        observerTetrad(KerrBL self, double const [4] pos, double [4] fourvel, double [4] screen1, double [4] screen2, double [4] screen3)



        Computes the orthonormal local tetrad of the observer.

        Parameters:
        -----------

        obskind:  input: kind of observer (eg:
        "ZAMO","KeplerianObserver"...)

        pos:  input: position,

        fourvel:  output: observer 4-velocity (norm -1)

        screen1:  output: first vector in the screen plane

        screen2:  output: second vector in the screen plane

        screen3:  output: vector normal to the screen 
        """
        return _std.KerrBL_observerTetrad(self, pos, fourvel, screen1, screen2, screen3)


    def circularVelocity(self, *args):
        """
        circularVelocity(KerrBL self, double const [4] pos, double [4] vel, double dir=1.)
        circularVelocity(KerrBL self, double const [4] pos, double [4] vel)
        circularVelocity(KerrBL self, double const [4] IN_ARRAY1)



        Yield circular velocity at a given position.

        Give the velocity of a massive particle in circular orbit at the given
        position projected onto the equatorial plane. Such a velocity may not
        exist everywhere (or anywhere) for a given metric. This method is
        intended to be used by Astrobj classes such as Torus or ThinDisk.

        If keplerian_ is set to true, this method should return the Keplerian
        velcity instead (derived classes should ensure this, see
        KerrBL::circularVelocity() for instance).

        The default implementation throws an error if keplerian_ is set to
        false.

        Parameters:
        -----------

        pos:  input: position,

        vel:  output: velocity,

        dir:  1 for corotating, -1 for counterrotating. 
        """
        return _std.KerrBL_circularVelocity(self, *args)


    def zamoVelocity(self, *args):
        """
        zamoVelocity(KerrBL self, double const [4] pos, double [4] vel)
        zamoVelocity(KerrBL self, double const [4] IN_ARRAY1)



        Yield ZAMO velocity at a given position.

        Give the velocity of a zero angular momentul observer (whatever is
        closest to "at rest"). The default implementation simply projects
        (1, 0, 0, 0) othogonally along ephi and normalizes it, thus ensuring
        that vel is orthogonal to ephi.

        Parameters:
        -----------

        pos:  input: position,

        vel:  output: velocity, 
        """
        return _std.KerrBL_zamoVelocity(self, *args)


    def christoffel(self, *args):
        """
        christoffel(KerrBL self, double const [4] coord, int const alpha, int const mu, int const nu) -> double
        christoffel(KerrBL self, double [4][4][4] dst, double const [4] pos) -> int
        christoffel(KerrBL self, double const [4] IN_ARRAY1)



        Chistoffel symbol.

        Value of Christoffel symbol at point (x1, x2, x3). 
        """
        return _std.KerrBL_christoffel(self, *args)


    def __init__(self, *args):
        """
        __init__(Gyoto::Metric::KerrBL self) -> KerrBL
        __init__(Gyoto::Metric::KerrBL self, Metric base) -> KerrBL
        __init__(Gyoto::Metric::KerrBL self, long address) -> KerrBL



        Default constructor. 
        """
        this = _std.new_KerrBL(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _std.delete_KerrBL
    __del__ = lambda self: None
KerrBL_swigregister = _std.KerrBL_swigregister
KerrBL_swigregister(KerrBL)
KerrBL.properties = _std.cvar.KerrBL_properties
KerrBL.builtinPluginValue = _std.cvar.KerrBL_builtinPluginValue

class KerrKS(gyoto.core.Metric):
    """


    Metric around a Kerr black-hole in Kerr-Schild coordinates Warning:
    this metric is seldom used and may be buggy.

    By default, uses the generic integrator ( Metric::Generic::myrk4()).
    Use to use the specific integretor which is, as of writting, buggy.

    C++ includes: GyotoKerrKS.h 
    """

    __swig_setmethods__ = {}
    for _s in [gyoto.core.Metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, KerrKS, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.Metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, KerrKS, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(KerrKS self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.KerrKS_getProperties(self)


    def plugins(self, *args):
        """
        plugins(KerrKS self, vector_string plugname)
        plugins(KerrKS self) -> vector_string
        """
        return _std.KerrKS_plugins(self, *args)


    def clone(self):
        """
        clone(KerrKS self) -> KerrKS



        Copy constructor. 
        """
        return _std.KerrKS_clone(self)


    def spin(self, *args):
        """
        spin(KerrKS self, double const spin)
        spin(KerrKS self) -> double



        Returns spin. 
        """
        return _std.KerrKS_spin(self, *args)


    def horizonSecurity(self, *args):
        """
        horizonSecurity(KerrKS self, double drhor)
        horizonSecurity(KerrKS self) -> double
        """
        return _std.KerrKS_horizonSecurity(self, *args)


    def gmunu(self, *args):
        """
        gmunu(KerrKS self, double const [4] x, int alpha, int beta) -> double
        gmunu(KerrKS self, double const [4] IN_ARRAY1)



        Metric coefficients.

        The default implementation calls double gmunu(const double * x, int
        mu, int nu) const.

        Parameters:
        -----------

        ARGOUT_ARRAY2:  (g) 4x4 array to store the coeefficients

        IN_ARRAY1:  (x) 4-position at which to compute the coefficients;

        Metric coefficient g, at point x 
        """
        return _std.KerrKS_gmunu(self, *args)


    def gmunu_up(self, *args):
        """
        gmunu_up(KerrKS self, double const [4] x, int mu, int nu) -> double
        gmunu_up(KerrKS self, double const [4] IN_ARRAY1)



        Metric contravariant coefficients.

        The default implementation calls Metric:: gmunu_up(double g[4][4],
        const double * pos) const

        Parameters:
        -----------

        x:  4-position at which to compute the coefficient;

        mu:  1st index of coefficient, 03;

        nu:  2nd index of coefficient, 03;

        Metric coefficient g, at point x 
        """
        return _std.KerrKS_gmunu_up(self, *args)


    def jacobian(self, x):
        """
        jacobian(KerrKS self, double const [4] x)



        The derivatives of gmunu.

        Used in the test suite 
        """
        return _std.KerrKS_jacobian(self, x)


    def gmunu_up_and_jacobian(self, IN_ARRAY1):
        """
        gmunu_up_and_jacobian(KerrKS self, double const [4] IN_ARRAY1)



        gmunu_up() and jacobian() in one go 
        """
        return _std.KerrKS_gmunu_up_and_jacobian(self, IN_ARRAY1)


    def isStopCondition(self, coord):
        """
        isStopCondition(KerrKS self, double const [8] coord) -> int



        Check whether integration should stop.

        The integrating loop will ask this the Metric through this method
        whether or not it is happy to continue the integration. Typically, the
        Metric should answer 0 when everything is fine, 1 when too close to
        the event horizon, inside the BH...

        Parameters:
        -----------

        coord:  8-coordinate vector to check. 
        """
        return _std.KerrKS_isStopCondition(self, coord)


    def setParameter(self, name, content, unit):
        """
        setParameter(KerrKS self, std::string name, std::string content, std::string unit) -> int



        Set parameter by Property (and name)

        This function is used when parsing an XML description, if Property (
        p) of this name is found (i.e. either p.name or p.name_false is equal
        to name). Implementation should fall-back on calling the direct's
        parent implementation:

        Parameters:
        -----------

        p:   Property that matches name ( p.name == name or p.name_false ==
        name)

        name:  XML name of the parameter (XML entity)

        content:  string representation of the value

        unit:  string representation of the unit 
        """
        return _std.KerrKS_setParameter(self, name, content, unit)


    def circularVelocity(self, *args):
        """
        circularVelocity(KerrKS self, double const [4] pos, double [4] vel, double dir=1.)
        circularVelocity(KerrKS self, double const [4] pos, double [4] vel)
        circularVelocity(KerrKS self, double const [4] IN_ARRAY1)



        Yield circular velocity at a given position.

        Give the velocity of a massive particle in circular orbit at the given
        position projected onto the equatorial plane. Such a velocity may not
        exist everywhere (or anywhere) for a given metric. This method is
        intended to be used by Astrobj classes such as Torus or ThinDisk.

        If keplerian_ is set to true, this method should return the Keplerian
        velcity instead (derived classes should ensure this, see
        KerrBL::circularVelocity() for instance).

        The default implementation throws an error if keplerian_ is set to
        false.

        Parameters:
        -----------

        pos:  input: position,

        vel:  output: velocity,

        dir:  1 for corotating, -1 for counterrotating. 
        """
        return _std.KerrKS_circularVelocity(self, *args)


    def zamoVelocity(self, IN_ARRAY1):
        """
        zamoVelocity(KerrKS self, double const [4] IN_ARRAY1)



        Yield ZAMO velocity at a given position.

        Give the velocity of a zero angular momentul observer (whatever is
        closest to "at rest"). The default implementation simply projects
        (1, 0, 0, 0) othogonally along ephi and normalizes it, thus ensuring
        that vel is orthogonal to ephi.

        Parameters:
        -----------

        pos:  input: position,

        vel:  output: velocity, 
        """
        return _std.KerrKS_zamoVelocity(self, IN_ARRAY1)


    def christoffel(self, *args):
        """
        christoffel(KerrKS self, double const [4] coord, int const alpha, int const mu, int const nu) -> double
        christoffel(KerrKS self, double [4][4][4] dst, double const [4] coord) -> int
        christoffel(KerrKS self, double const [4] IN_ARRAY1)



        Chistoffel symbol.

        Value of Christoffel symbol at point (x1, x2, x3).

        1 on error, 0 otherwise 
        """
        return _std.KerrKS_christoffel(self, *args)


    def __init__(self, *args):
        """
        __init__(Gyoto::Metric::KerrKS self) -> KerrKS
        __init__(Gyoto::Metric::KerrKS self, Metric base) -> KerrKS
        __init__(Gyoto::Metric::KerrKS self, long address) -> KerrKS



        Default constructor. 
        """
        this = _std.new_KerrKS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _std.delete_KerrKS
    __del__ = lambda self: None
KerrKS_swigregister = _std.KerrKS_swigregister
KerrKS_swigregister(KerrKS)
KerrKS.properties = _std.cvar.KerrKS_properties
KerrKS.builtinPluginValue = _std.cvar.KerrKS_builtinPluginValue

class Minkowski(gyoto.core.Metric):
    """


    The Minkowski flat-space metric.

    Use <Cartesian> or </Spherical> to select the coordinate system kind.

    C++ includes: GyotoMinkowski.h 
    """

    __swig_setmethods__ = {}
    for _s in [gyoto.core.Metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Minkowski, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.Metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Minkowski, name)
    __repr__ = _swig_repr

    def spherical(self, *args):
        """
        spherical(Minkowski self, bool arg2)
        spherical(Minkowski self) -> bool
        """
        return _std.Minkowski_spherical(self, *args)


    def getProperties(self):
        """
        getProperties(Minkowski self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.Minkowski_getProperties(self)


    def plugins(self, *args):
        """
        plugins(Minkowski self, vector_string plugname)
        plugins(Minkowski self) -> vector_string
        """
        return _std.Minkowski_plugins(self, *args)


    def clone(self):
        """
        clone(Minkowski self) -> Minkowski



        Virtual copy constructor. 
        """
        return _std.Minkowski_clone(self)


    def gmunu(self, *args):
        """
        gmunu(Minkowski self, double const [4] IN_ARRAY1)
        gmunu(Minkowski self, double const [4] x, int mu, int nu) -> double



        Metric coefficients.

        The default implementation calls Metric:: gmunu(double g[4][4], const
        double * pos) const

        Parameters:
        -----------

        x:  4-position at which to compute the coefficient;

        mu:  1st index of coefficient, 03;

        nu:  2nd index of coefficient, 03;

        Metric coefficient g, at point x 
        """
        return _std.Minkowski_gmunu(self, *args)


    def observerTetrad(self, obskind, pos, fourvel, screen1, screen2, screen3):
        """
        observerTetrad(Minkowski self, unsigned int obskind, double const [4] pos, double [4] fourvel, double [4] screen1, double [4] screen2, double [4] screen3)



        Computes the orthonormal local tetrad of the observer.

        Parameters:
        -----------

        pos:  position,

        fourvel:  observer 4-velocity (norm -1)

        screen1:  first vector in the screen plane

        screen2:  second vector in the screen plane

        screen3:  vector normal to the screen 
        """
        return _std.Minkowski_observerTetrad(self, obskind, pos, fourvel, screen1, screen2, screen3)


    def diff(self, x, dxdt, mass):
        """diff(Minkowski self, vector_double x, vector_double dxdt, double mass) -> int"""
        return _std.Minkowski_diff(self, x, dxdt, mass)


    def circularVelocity(self, IN_ARRAY1):
        """
        circularVelocity(Minkowski self, double const [4] IN_ARRAY1)



        Yield circular velocity at a given position.

        Give the velocity of a massive particle in circular orbit at the given
        position projected onto the equatorial plane. Such a velocity may not
        exist everywhere (or anywhere) for a given metric. This method is
        intended to be used by Astrobj classes such as Torus or ThinDisk.

        If keplerian_ is set to true, this method should return the Keplerian
        velcity instead (derived classes should ensure this, see
        KerrBL::circularVelocity() for instance).

        The default implementation throws an error if keplerian_ is set to
        false.

        Parameters:
        -----------

        pos:  input: position,

        vel:  output: velocity,

        dir:  1 for corotating, -1 for counterrotating. 
        """
        return _std.Minkowski_circularVelocity(self, IN_ARRAY1)


    def zamoVelocity(self, IN_ARRAY1):
        """
        zamoVelocity(Minkowski self, double const [4] IN_ARRAY1)



        Yield ZAMO velocity at a given position.

        Give the velocity of a zero angular momentul observer (whatever is
        closest to "at rest"). The default implementation simply projects
        (1, 0, 0, 0) othogonally along ephi and normalizes it, thus ensuring
        that vel is orthogonal to ephi.

        Parameters:
        -----------

        pos:  input: position,

        vel:  output: velocity, 
        """
        return _std.Minkowski_zamoVelocity(self, IN_ARRAY1)


    def christoffel(self, *args):
        """
        christoffel(Minkowski self, double [4][4][4] dst, double const [4] x) -> int
        christoffel(Minkowski self, double const [4] coord, int const alpha, int const mu, int const nu) -> double
        christoffel(Minkowski self, double const [4] IN_ARRAY1)



        Chistoffel symbol.

        Value of Christoffel symbol at point (x1, x2, x3). 
        """
        return _std.Minkowski_christoffel(self, *args)


    def __init__(self, *args):
        """
        __init__(Gyoto::Metric::Minkowski self) -> Minkowski
        __init__(Gyoto::Metric::Minkowski self, Metric base) -> Minkowski
        __init__(Gyoto::Metric::Minkowski self, long address) -> Minkowski
        """
        this = _std.new_Minkowski(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _std.delete_Minkowski
    __del__ = lambda self: None
Minkowski_swigregister = _std.Minkowski_swigregister
Minkowski_swigregister(Minkowski)
Minkowski.properties = _std.cvar.Minkowski_properties
Minkowski.builtinPluginValue = _std.cvar.Minkowski_builtinPluginValue

class ChernSimons(KerrBL):
    """Proxy of C++ Gyoto::Metric::ChernSimons class."""

    __swig_setmethods__ = {}
    for _s in [KerrBL]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ChernSimons, name, value)
    __swig_getmethods__ = {}
    for _s in [KerrBL]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ChernSimons, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(ChernSimons self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.ChernSimons_getProperties(self)


    def plugins(self, *args):
        """
        plugins(ChernSimons self, vector_string plugname)
        plugins(ChernSimons self) -> vector_string
        """
        return _std.ChernSimons_plugins(self, *args)

    __swig_destroy__ = _std.delete_ChernSimons
    __del__ = lambda self: None

    def clone(self):
        """
        clone(ChernSimons self) -> ChernSimons



        Virtual copy constructor. 
        """
        return _std.ChernSimons_clone(self)


    def dzetaCS(self, *args):
        """
        dzetaCS(ChernSimons self, double d)
        dzetaCS(ChernSimons self) -> double
        """
        return _std.ChernSimons_dzetaCS(self, *args)


    def gmunu(self, *args):
        """
        gmunu(ChernSimons self, double const [4] IN_ARRAY1)
        gmunu(ChernSimons self, double const [4] x, int mu, int nu) -> double



        Metric coefficients.

        The default implementation calls Metric:: gmunu(double g[4][4], const
        double * pos) const

        Parameters:
        -----------

        x:  4-position at which to compute the coefficient;

        mu:  1st index of coefficient, 03;

        nu:  2nd index of coefficient, 03;

        Metric coefficient g, at point x 
        """
        return _std.ChernSimons_gmunu(self, *args)


    def gmunu_up(self, *args):
        """
        gmunu_up(ChernSimons self, double const [4] IN_ARRAY1)
        gmunu_up(ChernSimons self, double const [4] x, int mu, int nu) -> double



        Metric contravariant coefficients.

        The default implementation calls Metric:: gmunu_up(double g[4][4],
        const double * pos) const

        Parameters:
        -----------

        x:  4-position at which to compute the coefficient;

        mu:  1st index of coefficient, 03;

        nu:  2nd index of coefficient, 03;

        Metric coefficient g, at point x 
        """
        return _std.ChernSimons_gmunu_up(self, *args)


    def diff(self, y, cst, res):
        """diff(ChernSimons self, double const [8] y, double const [5] cst, double [8] res) -> int"""
        return _std.ChernSimons_diff(self, y, cst, res)


    def circularVelocity(self, *args):
        """
        circularVelocity(ChernSimons self, double const [4] pos, double [4] vel, double dir=1.)
        circularVelocity(ChernSimons self, double const [4] pos, double [4] vel)
        circularVelocity(ChernSimons self, double const [4] IN_ARRAY1)



        Yield circular velocity at a given position.

        Give the velocity of a massive particle in circular orbit at the given
        position projected onto the equatorial plane. Such a velocity may not
        exist everywhere (or anywhere) for a given metric. This method is
        intended to be used by Astrobj classes such as Torus or ThinDisk.

        If keplerian_ is set to true, this method should return the Keplerian
        velcity instead (derived classes should ensure this, see
        KerrBL::circularVelocity() for instance).

        The default implementation throws an error if keplerian_ is set to
        false.

        Parameters:
        -----------

        pos:  input: position,

        vel:  output: velocity,

        dir:  1 for corotating, -1 for counterrotating. 
        """
        return _std.ChernSimons_circularVelocity(self, *args)


    def zamoVelocity(self, IN_ARRAY1):
        """
        zamoVelocity(ChernSimons self, double const [4] IN_ARRAY1)



        Yield ZAMO velocity at a given position.

        Give the velocity of a zero angular momentul observer (whatever is
        closest to "at rest"). The default implementation simply projects
        (1, 0, 0, 0) othogonally along ephi and normalizes it, thus ensuring
        that vel is orthogonal to ephi.

        Parameters:
        -----------

        pos:  input: position,

        vel:  output: velocity, 
        """
        return _std.ChernSimons_zamoVelocity(self, IN_ARRAY1)


    def christoffel(self, *args):
        """
        christoffel(ChernSimons self, double const [4] coord, int const alpha, int const mu, int const nu) -> double
        christoffel(ChernSimons self, double [4][4][4] dst, double const [4] x) -> int
        christoffel(ChernSimons self, double const [4] IN_ARRAY1)



        Chistoffel symbol.

        Value of Christoffel symbol at point (x1, x2, x3). 
        """
        return _std.ChernSimons_christoffel(self, *args)


    def __init__(self, *args):
        """
        __init__(Gyoto::Metric::ChernSimons self) -> ChernSimons
        __init__(Gyoto::Metric::ChernSimons self, ChernSimons o) -> ChernSimons
        __init__(Gyoto::Metric::ChernSimons self, Metric base) -> ChernSimons
        __init__(Gyoto::Metric::ChernSimons self, long address) -> ChernSimons
        """
        this = _std.new_ChernSimons(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
ChernSimons_swigregister = _std.ChernSimons_swigregister
ChernSimons_swigregister(ChernSimons)
ChernSimons.properties = _std.cvar.ChernSimons_properties
ChernSimons.builtinPluginValue = _std.cvar.ChernSimons_builtinPluginValue

class RezzollaZhidenko(gyoto.core.Metric):
    """Proxy of C++ Gyoto::Metric::RezzollaZhidenko class."""

    __swig_setmethods__ = {}
    for _s in [gyoto.core.Metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RezzollaZhidenko, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.Metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RezzollaZhidenko, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(RezzollaZhidenko self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.RezzollaZhidenko_getProperties(self)


    def plugins(self, *args):
        """
        plugins(RezzollaZhidenko self, vector_string plugname)
        plugins(RezzollaZhidenko self) -> vector_string
        """
        return _std.RezzollaZhidenko_plugins(self, *args)

    __swig_destroy__ = _std.delete_RezzollaZhidenko
    __del__ = lambda self: None

    def clone(self):
        """
        clone(RezzollaZhidenko self) -> RezzollaZhidenko



        Virtual copy constructor. 
        """
        return _std.RezzollaZhidenko_clone(self)


    def epsilon(self, *args):
        """
        epsilon(RezzollaZhidenko self, double arg2)
        epsilon(RezzollaZhidenko self) -> double
        """
        return _std.RezzollaZhidenko_epsilon(self, *args)


    def rms(self, *args):
        """
        rms(RezzollaZhidenko self, double arg2)
        rms(RezzollaZhidenko self) -> double
        """
        return _std.RezzollaZhidenko_rms(self, *args)


    def rmb(self, *args):
        """
        rmb(RezzollaZhidenko self, double arg2)
        rmb(RezzollaZhidenko self) -> double
        """
        return _std.RezzollaZhidenko_rmb(self, *args)


    def aparam(self, *args):
        """
        aparam(RezzollaZhidenko self, vector_double v)
        aparam(RezzollaZhidenko self) -> vector_double
        """
        return _std.RezzollaZhidenko_aparam(self, *args)


    def bparam(self, *args):
        """
        bparam(RezzollaZhidenko self, vector_double v)
        bparam(RezzollaZhidenko self) -> vector_double
        """
        return _std.RezzollaZhidenko_bparam(self, *args)


    def gmunu(self, *args):
        """
        gmunu(RezzollaZhidenko self, double const [4] IN_ARRAY1)
        gmunu(RezzollaZhidenko self, double const [4] x, int mu, int nu) -> double



        Metric coefficients.

        The default implementation calls double gmunu(const double * x, int
        mu, int nu) const.

        Parameters:
        -----------

        ARGOUT_ARRAY2:  (g) 4x4 array to store the coeefficients

        IN_ARRAY1:  (x) 4-position at which to compute the coefficients;

        Metric coefficient g, at point x 
        """
        return _std.RezzollaZhidenko_gmunu(self, *args)


    def N2(self, rr):
        """N2(RezzollaZhidenko self, double const rr) -> double"""
        return _std.RezzollaZhidenko_N2(self, rr)


    def B2(self, rr):
        """B2(RezzollaZhidenko self, double const rr) -> double"""
        return _std.RezzollaZhidenko_B2(self, rr)


    def Nprime(self, rr):
        """Nprime(RezzollaZhidenko self, double const rr) -> double"""
        return _std.RezzollaZhidenko_Nprime(self, rr)


    def Bprime(self, rr):
        """Bprime(RezzollaZhidenko self, double const rr) -> double"""
        return _std.RezzollaZhidenko_Bprime(self, rr)


    def isStopCondition(self, coord):
        """
        isStopCondition(RezzollaZhidenko self, double const [8] coord) -> int



        Check whether integration should stop.

        The integrating loop will ask this the Metric through this method
        whether or not it is happy to continue the integration. Typically, the
        Metric should answer 0 when everything is fine, 1 when too close to
        the event horizon, inside the BH...

        Parameters:
        -----------

        coord:  8-coordinate vector to check. 
        """
        return _std.RezzollaZhidenko_isStopCondition(self, coord)


    def getRmb(self):
        """
        getRmb(RezzollaZhidenko self) -> double



        Returns the marginally bound radius Should be implemented in derived
        classes if useful If called on the base class, returns an error 
        """
        return _std.RezzollaZhidenko_getRmb(self)


    def getRms(self):
        """
        getRms(RezzollaZhidenko self) -> double



        Returns the marginally stable (ISCO) radius Should be implemented in
        derived classes if useful If called on the base class, returns an
        error 
        """
        return _std.RezzollaZhidenko_getRms(self)


    def getPotential(self, pos, l_cst):
        """
        getPotential(RezzollaZhidenko self, double const [4] pos, double l_cst) -> double



        Returns potential W=-ln(|u_t|) for a cst specific angular momentum
        l_cst Should be implemented in derived classes if useful If called on
        the base class, returns an error 
        """
        return _std.RezzollaZhidenko_getPotential(self, pos, l_cst)


    def getSpecificAngularMomentum(self, rr):
        """
        getSpecificAngularMomentum(RezzollaZhidenko self, double rr) -> double



        Returns the specific angular momentum l=-u_phi/u_t Should be
        implemented in derived classes if useful If called on the base class,
        returns an error 
        """
        return _std.RezzollaZhidenko_getSpecificAngularMomentum(self, rr)


    def circularVelocity(self, *args):
        """
        circularVelocity(RezzollaZhidenko self, double const [4] pos, double [4] vel, double dir=1.)
        circularVelocity(RezzollaZhidenko self, double const [4] pos, double [4] vel)
        circularVelocity(RezzollaZhidenko self, double const [4] IN_ARRAY1)



        Yield circular velocity at a given position.

        Give the velocity of a massive particle in circular orbit at the given
        position projected onto the equatorial plane. Such a velocity may not
        exist everywhere (or anywhere) for a given metric. This method is
        intended to be used by Astrobj classes such as Torus or ThinDisk.

        If keplerian_ is set to true, this method should return the Keplerian
        velcity instead (derived classes should ensure this, see
        KerrBL::circularVelocity() for instance).

        The default implementation throws an error if keplerian_ is set to
        false.

        Parameters:
        -----------

        pos:  input: position,

        vel:  output: velocity,

        dir:  1 for corotating, -1 for counterrotating. 
        """
        return _std.RezzollaZhidenko_circularVelocity(self, *args)


    def zamoVelocity(self, IN_ARRAY1):
        """
        zamoVelocity(RezzollaZhidenko self, double const [4] IN_ARRAY1)



        Yield ZAMO velocity at a given position.

        Give the velocity of a zero angular momentul observer (whatever is
        closest to "at rest"). The default implementation simply projects
        (1, 0, 0, 0) othogonally along ephi and normalizes it, thus ensuring
        that vel is orthogonal to ephi.

        Parameters:
        -----------

        pos:  input: position,

        vel:  output: velocity, 
        """
        return _std.RezzollaZhidenko_zamoVelocity(self, IN_ARRAY1)


    def christoffel(self, *args):
        """
        christoffel(RezzollaZhidenko self, double const [4] coord, int const alpha, int const mu, int const nu) -> double
        christoffel(RezzollaZhidenko self, double [4][4][4] dst, double const [4] pos) -> int
        christoffel(RezzollaZhidenko self, double const [4] IN_ARRAY1)



        Chistoffel symbol.

        Value of Christoffel symbol at point (x1, x2, x3). 
        """
        return _std.RezzollaZhidenko_christoffel(self, *args)


    def __init__(self, *args):
        """
        __init__(Gyoto::Metric::RezzollaZhidenko self) -> RezzollaZhidenko
        __init__(Gyoto::Metric::RezzollaZhidenko self, RezzollaZhidenko orig) -> RezzollaZhidenko
        __init__(Gyoto::Metric::RezzollaZhidenko self, Metric base) -> RezzollaZhidenko
        __init__(Gyoto::Metric::RezzollaZhidenko self, long address) -> RezzollaZhidenko
        """
        this = _std.new_RezzollaZhidenko(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
RezzollaZhidenko_swigregister = _std.RezzollaZhidenko_swigregister
RezzollaZhidenko_swigregister(RezzollaZhidenko)
RezzollaZhidenko.properties = _std.cvar.RezzollaZhidenko_properties
RezzollaZhidenko.builtinPluginValue = _std.cvar.RezzollaZhidenko_builtinPluginValue

class Hayward(gyoto.core.Metric):
    """


    Metric of a regular rotating black hole or naked worm-hole.

    This is a regular rotating extension of Hayward's metric.

    The metric reads:
    ds^2=-(1-2*M(r)*r/Sigma)*dt^2-(4*a*M(r)*sin^2(theta)/Sigma)*dt*dphi+(Sigma/Delta)*dr^2+(Sigma)*dtheta^2+sin^2(theta)*[r^2+a^2+2*a^2*r*M(r)*sin^2(theta)/Sigma]*dphi^2,
    where: Sigma=r^2+a^2*cos^2(theta) Delta=r^2-2*M(r)*r+a^2
    M(r)=M*abs(r)^3/(abs(r)^3+2*m*b^2), m being the mass of the black hole
    seen at infinity and b a magnetic charge parameter.

    See Lamy et al. (2018), Classical and Quantum Gravity,
    submitted,https://arxiv.org/abs/1802.01635

    See Hayward (2006) for the original nonrotating
    metric,https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.96.031103

    See Bambi & Modesto (2013) for a rotating (but singular)
    extension.https://www.sciencedirect.com/science/article/pii/S0370269313002505?via%3Dihub

    C++ includes: GyotoHayward.h 
    """

    __swig_setmethods__ = {}
    for _s in [gyoto.core.Metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Hayward, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.Metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Hayward, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(Hayward self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.Hayward_getProperties(self)


    def plugins(self, *args):
        """
        plugins(Hayward self, vector_string plugname)
        plugins(Hayward self) -> vector_string
        """
        return _std.Hayward_plugins(self, *args)


    def clone(self):
        """
        clone(Hayward self) -> Hayward



        Virtual copy constructor. 
        """
        return _std.Hayward_clone(self)


    def spin(self, *args):
        """
        spin(Hayward self, double const spin)
        spin(Hayward self) -> double



        Returns spin. 
        """
        return _std.Hayward_spin(self, *args)


    def charge(self, *args):
        """
        charge(Hayward self, double const charge)
        charge(Hayward self) -> double



        Returns charge. 
        """
        return _std.Hayward_charge(self, *args)


    def getSpecificAngularMomentum(self, rr):
        """
        getSpecificAngularMomentum(Hayward self, double rr) -> double



        Returns the specific angular momentum l=-u_phi/u_t Should be
        implemented in derived classes if useful If called on the base class,
        returns an error 
        """
        return _std.Hayward_getSpecificAngularMomentum(self, rr)


    def getPotential(self, pos, l_cst):
        """
        getPotential(Hayward self, double const [4] pos, double l_cst) -> double



        Returns potential W=-ln(|u_t|) for a cst specific angular momentum
        l_cst Should be implemented in derived classes if useful If called on
        the base class, returns an error 
        """
        return _std.Hayward_getPotential(self, pos, l_cst)


    def gmunu(self, *args):
        """
        gmunu(Hayward self, double const [4] IN_ARRAY1)
        gmunu(Hayward self, double const [4] x, int mu, int nu) -> double



        Metric coefficients.

        The default implementation calls Metric:: gmunu(double g[4][4], const
        double * pos) const

        Parameters:
        -----------

        x:  4-position at which to compute the coefficient;

        mu:  1st index of coefficient, 03;

        nu:  2nd index of coefficient, 03;

        Metric coefficient g, at point x 
        """
        return _std.Hayward_gmunu(self, *args)


    def gmunu_up(self, *args):
        """
        gmunu_up(Hayward self, double const [4] IN_ARRAY1)
        gmunu_up(Hayward self, double const [4] x, int mu, int nu) -> double



        Metric contravariant coefficients.

        The default implementation calls Metric:: gmunu_up(double g[4][4],
        const double * pos) const

        Parameters:
        -----------

        x:  4-position at which to compute the coefficient;

        mu:  1st index of coefficient, 03;

        nu:  2nd index of coefficient, 03;

        Metric coefficient g, at point x 
        """
        return _std.Hayward_gmunu_up(self, *args)


    def ScalarProd(self, pos, u1, u2):
        """
        ScalarProd(Hayward self, double const [4] pos, double const [4] u1, double const [4] u2) -> double



        Scalar product.

        Compute the scalarproduct of the two quadrivectors u1 and u2 in this
        Metric, at point pos expressed in coordinate system sys.

        Parameters:
        -----------

        pos:  4-position;

        u1:  1st quadrivector;

        u2:  2nd quadrivector;

        u1*u2 
        """
        return _std.Hayward_ScalarProd(self, pos, u1, u2)


    def circularVelocity(self, *args):
        """
        circularVelocity(Hayward self, double const [4] coor, double [4] vel, double dir)
        circularVelocity(Hayward self, double const [4] IN_ARRAY1)



        Yield circular velocity at a given position.

        Give the velocity of a massive particle in circular orbit at the given
        position projected onto the equatorial plane. Such a velocity may not
        exist everywhere (or anywhere) for a given metric. This method is
        intended to be used by Astrobj classes such as Torus or ThinDisk.

        If keplerian_ is set to true, this method should return the Keplerian
        velcity instead (derived classes should ensure this, see
        KerrBL::circularVelocity() for instance).

        The default implementation throws an error if keplerian_ is set to
        false.

        Parameters:
        -----------

        pos:  input: position,

        vel:  output: velocity,

        dir:  1 for corotating, -1 for counterrotating. 
        """
        return _std.Hayward_circularVelocity(self, *args)


    def zamoVelocity(self, IN_ARRAY1):
        """
        zamoVelocity(Hayward self, double const [4] IN_ARRAY1)



        Yield ZAMO velocity at a given position.

        Give the velocity of a zero angular momentul observer (whatever is
        closest to "at rest"). The default implementation simply projects
        (1, 0, 0, 0) othogonally along ephi and normalizes it, thus ensuring
        that vel is orthogonal to ephi.

        Parameters:
        -----------

        pos:  input: position,

        vel:  output: velocity, 
        """
        return _std.Hayward_zamoVelocity(self, IN_ARRAY1)


    def christoffel(self, *args):
        """
        christoffel(Hayward self, double const [4] coord, int const alpha, int const mu, int const nu) -> double
        christoffel(Hayward self, double [4][4][4] dst, double const [4] pos) -> int
        christoffel(Hayward self, double const [4] IN_ARRAY1)



        Chistoffel symbol.

        Value of Christoffel symbol at point (x1, x2, x3). 
        """
        return _std.Hayward_christoffel(self, *args)


    def __init__(self, *args):
        """
        __init__(Gyoto::Metric::Hayward self) -> Hayward
        __init__(Gyoto::Metric::Hayward self, Metric base) -> Hayward
        __init__(Gyoto::Metric::Hayward self, long address) -> Hayward



        Default constructor. 
        """
        this = _std.new_Hayward(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _std.delete_Hayward
    __del__ = lambda self: None
Hayward_swigregister = _std.Hayward_swigregister
Hayward_swigregister(Hayward)
Hayward.properties = _std.cvar.Hayward_properties
Hayward.builtinPluginValue = _std.cvar.Hayward_builtinPluginValue

class SchwarzschildHarmonic(gyoto.core.Metric):
    """Proxy of C++ Gyoto::Metric::SchwarzschildHarmonic class."""

    __swig_setmethods__ = {}
    for _s in [gyoto.core.Metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SchwarzschildHarmonic, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.Metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SchwarzschildHarmonic, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(SchwarzschildHarmonic self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.SchwarzschildHarmonic_getProperties(self)


    def plugins(self, *args):
        """
        plugins(SchwarzschildHarmonic self, vector_string plugname)
        plugins(SchwarzschildHarmonic self) -> vector_string
        """
        return _std.SchwarzschildHarmonic_plugins(self, *args)

    __swig_destroy__ = _std.delete_SchwarzschildHarmonic
    __del__ = lambda self: None

    def clone(self):
        """
        clone(SchwarzschildHarmonic self) -> SchwarzschildHarmonic



        Virtual copy constructor. 
        """
        return _std.SchwarzschildHarmonic_clone(self)


    def gmunu(self, *args):
        """
        gmunu(SchwarzschildHarmonic self, double const [4] IN_ARRAY1)
        gmunu(SchwarzschildHarmonic self, double const [4] x, int mu, int nu) -> double



        Metric coefficients.

        The default implementation calls double gmunu(const double * x, int
        mu, int nu) const.

        Parameters:
        -----------

        ARGOUT_ARRAY2:  (g) 4x4 array to store the coeefficients

        IN_ARRAY1:  (x) 4-position at which to compute the coefficients;

        Metric coefficient g, at point x 
        """
        return _std.SchwarzschildHarmonic_gmunu(self, *args)


    def isStopCondition(self, coord):
        """
        isStopCondition(SchwarzschildHarmonic self, double const [8] coord) -> int



        Check whether integration should stop.

        The integrating loop will ask this the Metric through this method
        whether or not it is happy to continue the integration. Typically, the
        Metric should answer 0 when everything is fine, 1 when too close to
        the event horizon, inside the BH...

        Parameters:
        -----------

        coord:  8-coordinate vector to check. 
        """
        return _std.SchwarzschildHarmonic_isStopCondition(self, coord)


    def circularVelocity(self, *args):
        """
        circularVelocity(SchwarzschildHarmonic self, double const * coor, double * vel, double dir)
        circularVelocity(SchwarzschildHarmonic self, double const [4] IN_ARRAY1)



        Yield circular velocity at a given position.

        Give the velocity of a massive particle in circular orbit at the given
        position projected onto the equatorial plane. Such a velocity may not
        exist everywhere (or anywhere) for a given metric. This method is
        intended to be used by Astrobj classes such as Torus or ThinDisk.

        If keplerian_ is set to true, this method should return the Keplerian
        velcity instead (derived classes should ensure this, see
        KerrBL::circularVelocity() for instance).

        The default implementation throws an error if keplerian_ is set to
        false.

        Parameters:
        -----------

        pos:  input: position,

        vel:  output: velocity,

        dir:  1 for corotating, -1 for counterrotating. 
        """
        return _std.SchwarzschildHarmonic_circularVelocity(self, *args)


    def zamoVelocity(self, IN_ARRAY1):
        """
        zamoVelocity(SchwarzschildHarmonic self, double const [4] IN_ARRAY1)



        Yield ZAMO velocity at a given position.

        Give the velocity of a zero angular momentul observer (whatever is
        closest to "at rest"). The default implementation simply projects
        (1, 0, 0, 0) othogonally along ephi and normalizes it, thus ensuring
        that vel is orthogonal to ephi.

        Parameters:
        -----------

        pos:  input: position,

        vel:  output: velocity, 
        """
        return _std.SchwarzschildHarmonic_zamoVelocity(self, IN_ARRAY1)


    def christoffel(self, *args):
        """
        christoffel(SchwarzschildHarmonic self, double const [4] coord, int const alpha, int const mu, int const nu) -> double
        christoffel(SchwarzschildHarmonic self, double [4][4][4] dst, double const [4] pos) -> int
        christoffel(SchwarzschildHarmonic self, double const [4] IN_ARRAY1)



        Chistoffel symbol.

        Value of Christoffel symbol at point (x1, x2, x3). 
        """
        return _std.SchwarzschildHarmonic_christoffel(self, *args)


    def __init__(self, *args):
        """
        __init__(Gyoto::Metric::SchwarzschildHarmonic self) -> SchwarzschildHarmonic
        __init__(Gyoto::Metric::SchwarzschildHarmonic self, SchwarzschildHarmonic orig) -> SchwarzschildHarmonic
        __init__(Gyoto::Metric::SchwarzschildHarmonic self, Metric base) -> SchwarzschildHarmonic
        __init__(Gyoto::Metric::SchwarzschildHarmonic self, long address) -> SchwarzschildHarmonic
        """
        this = _std.new_SchwarzschildHarmonic(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
SchwarzschildHarmonic_swigregister = _std.SchwarzschildHarmonic_swigregister
SchwarzschildHarmonic_swigregister(SchwarzschildHarmonic)
SchwarzschildHarmonic.properties = _std.cvar.SchwarzschildHarmonic_properties
SchwarzschildHarmonic.builtinPluginValue = _std.cvar.SchwarzschildHarmonic_builtinPluginValue

class PowerLaw(gyoto.core.Spectrum):
    """


    I_nu=constant_*nu^exponent_.

    Light emitted by e.g. a Star.

    XML stanza:

    C++ includes: GyotoPowerLawSpectrum.h 
    """

    __swig_setmethods__ = {}
    for _s in [gyoto.core.Spectrum]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PowerLaw, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.Spectrum]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PowerLaw, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(PowerLaw self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.PowerLaw_getProperties(self)


    def plugins(self, *args):
        """
        plugins(PowerLaw self, vector_string plugname)
        plugins(PowerLaw self) -> vector_string
        """
        return _std.PowerLaw_plugins(self, *args)


    def clone(self):
        """
        clone(PowerLaw self) -> PowerLaw



        Cloner. 
        """
        return _std.PowerLaw_clone(self)


    def constant(self, *args):
        """
        constant(PowerLaw self) -> double
        constant(PowerLaw self, double arg2)



        Set constant_. 
        """
        return _std.PowerLaw_constant(self, *args)


    def exponent(self, *args):
        """
        exponent(PowerLaw self) -> double
        exponent(PowerLaw self, double arg2)



        Set exponent_. 
        """
        return _std.PowerLaw_exponent(self, *args)


    def cutoff(self, *args):
        """
        cutoff(PowerLaw self, std::string const & unit) -> vector_double
        cutoff(PowerLaw self, vector_double v, std::string const & unit)
        cutoff(PowerLaw self) -> vector_double
        cutoff(PowerLaw self, vector_double v)



        Set cutoffs, in Hz. 
        """
        return _std.PowerLaw_cutoff(self, *args)


    def __call__(self, *args):
        """
        __call__(PowerLaw self, double nu, double opacity, double ds) -> double
        __call__(PowerLaw self, double nu) -> double
        """
        return _std.PowerLaw___call__(self, *args)


    def __init__(self, *args):
        """
        __init__(Gyoto::Spectrum::PowerLaw self) -> PowerLaw
        __init__(Gyoto::Spectrum::PowerLaw self, double exponent, double constant=1.) -> PowerLaw
        __init__(Gyoto::Spectrum::PowerLaw self, double exponent) -> PowerLaw
        __init__(Gyoto::Spectrum::PowerLaw self, Spectrum base) -> PowerLaw
        __init__(Gyoto::Spectrum::PowerLaw self, long address) -> PowerLaw



        Constructor setting exponent_ and optionally constant_. 
        """
        this = _std.new_PowerLaw(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _std.delete_PowerLaw
    __del__ = lambda self: None
PowerLaw_swigregister = _std.PowerLaw_swigregister
PowerLaw_swigregister(PowerLaw)
PowerLaw.properties = _std.cvar.PowerLaw_properties
PowerLaw.builtinPluginValue = _std.cvar.PowerLaw_builtinPluginValue

class BlackBody(gyoto.core.Spectrum):
    """


    Black Body.

    Light emitted by e.g. a Star.

    Example XML entity:

    C++ includes: GyotoBlackBodySpectrum.h 
    """

    __swig_setmethods__ = {}
    for _s in [gyoto.core.Spectrum]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BlackBody, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.Spectrum]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BlackBody, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(BlackBody self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.BlackBody_getProperties(self)


    def plugins(self, *args):
        """
        plugins(BlackBody self, vector_string plugname)
        plugins(BlackBody self) -> vector_string
        """
        return _std.BlackBody_plugins(self, *args)


    def clone(self):
        """
        clone(BlackBody self) -> BlackBody



        Cloner. 
        """
        return _std.BlackBody_clone(self)


    def temperature(self, *args):
        """
        temperature(BlackBody self) -> double
        temperature(BlackBody self, double arg2)



        Set constant. 
        """
        return _std.BlackBody_temperature(self, *args)


    def scaling(self, *args):
        """
        scaling(BlackBody self) -> double
        scaling(BlackBody self, double arg2)



        Set exponent. 
        """
        return _std.BlackBody_scaling(self, *args)


    def colorCorrection(self, *args):
        """
        colorCorrection(BlackBody self) -> double
        colorCorrection(BlackBody self, double arg2)



        Set color correction. 
        """
        return _std.BlackBody_colorCorrection(self, *args)


    def __call__(self, *args):
        """
        __call__(BlackBody self, double nu, double opacity, double ds) -> double
        __call__(BlackBody self, double nu) -> double
        """
        return _std.BlackBody___call__(self, *args)


    def __init__(self, *args):
        """
        __init__(Gyoto::Spectrum::BlackBody self) -> BlackBody
        __init__(Gyoto::Spectrum::BlackBody self, double T, double scaling=1.) -> BlackBody
        __init__(Gyoto::Spectrum::BlackBody self, double T) -> BlackBody
        __init__(Gyoto::Spectrum::BlackBody self, Spectrum base) -> BlackBody
        __init__(Gyoto::Spectrum::BlackBody self, long address) -> BlackBody



        Constructor setting T_ and cst_. 
        """
        this = _std.new_BlackBody(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _std.delete_BlackBody
    __del__ = lambda self: None
BlackBody_swigregister = _std.BlackBody_swigregister
BlackBody_swigregister(BlackBody)
BlackBody.properties = _std.cvar.BlackBody_properties
BlackBody.builtinPluginValue = _std.cvar.BlackBody_builtinPluginValue

class ThermalBremsstrahlung(gyoto.core.Spectrum):
    """


    Thermal brems spectrum.

    Example XML entity:

    C++ includes: GyotoThermalBremsstrahlungSpectrum.h 
    """

    __swig_setmethods__ = {}
    for _s in [gyoto.core.Spectrum]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ThermalBremsstrahlung, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.Spectrum]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ThermalBremsstrahlung, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(ThermalBremsstrahlung self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.ThermalBremsstrahlung_getProperties(self)


    def plugins(self, *args):
        """
        plugins(ThermalBremsstrahlung self, vector_string plugname)
        plugins(ThermalBremsstrahlung self) -> vector_string
        """
        return _std.ThermalBremsstrahlung_plugins(self, *args)


    def clone(self):
        """
        clone(ThermalBremsstrahlung self) -> ThermalBremsstrahlung



        Cloner. 
        """
        return _std.ThermalBremsstrahlung_clone(self)


    def __call__(self, *args):
        """
        __call__(ThermalBremsstrahlung self, double nu, double opacity, double ds) -> double
        __call__(ThermalBremsstrahlung self, double nu) -> double
        """
        return _std.ThermalBremsstrahlung___call__(self, *args)


    def temperature(self, *args):
        """
        temperature(ThermalBremsstrahlung self) -> double
        temperature(ThermalBremsstrahlung self, double tt)
        """
        return _std.ThermalBremsstrahlung_temperature(self, *args)


    def numberdensityCGS(self, *args):
        """
        numberdensityCGS(ThermalBremsstrahlung self) -> double
        numberdensityCGS(ThermalBremsstrahlung self, double rho)
        """
        return _std.ThermalBremsstrahlung_numberdensityCGS(self, *args)


    def jnuCGS(self, nu):
        """
        jnuCGS(ThermalBremsstrahlung self, double nu) -> double



        Returns the emission coefficient j_nu in cgs units i.e. erg cm^-3 s^-1
        ster^-1 Hz^-1

        Parameters:
        -----------

        nu:  frequency in Hz 
        """
        return _std.ThermalBremsstrahlung_jnuCGS(self, nu)


    def alphanuCGS(self, nu):
        """
        alphanuCGS(ThermalBremsstrahlung self, double nu) -> double



        Returns the absorption coefficient alpha_nu in cgs units [cm^-1]

        Parameters:
        -----------

        nu:  frequency in Hz 
        """
        return _std.ThermalBremsstrahlung_alphanuCGS(self, nu)


    def radiativeQ(self, jnu, alphanu, nu_ems, nbnu):
        """
        radiativeQ(ThermalBremsstrahlung self, double [] jnu, double [] alphanu, double const [] nu_ems, size_t nbnu)



        Returns the emission and absorption coef jnu and alphanu in SI 
        """
        return _std.ThermalBremsstrahlung_radiativeQ(self, jnu, alphanu, nu_ems, nbnu)


    def __init__(self, *args):
        """
        __init__(Gyoto::Spectrum::ThermalBremsstrahlung self) -> ThermalBremsstrahlung
        __init__(Gyoto::Spectrum::ThermalBremsstrahlung self, ThermalBremsstrahlung arg2) -> ThermalBremsstrahlung
        __init__(Gyoto::Spectrum::ThermalBremsstrahlung self, Spectrum base) -> ThermalBremsstrahlung
        __init__(Gyoto::Spectrum::ThermalBremsstrahlung self, long address) -> ThermalBremsstrahlung
        """
        this = _std.new_ThermalBremsstrahlung(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _std.delete_ThermalBremsstrahlung
    __del__ = lambda self: None
ThermalBremsstrahlung_swigregister = _std.ThermalBremsstrahlung_swigregister
ThermalBremsstrahlung_swigregister(ThermalBremsstrahlung)
ThermalBremsstrahlung.properties = _std.cvar.ThermalBremsstrahlung_properties
ThermalBremsstrahlung.builtinPluginValue = _std.cvar.ThermalBremsstrahlung_builtinPluginValue

class ThermalSynchrotron(gyoto.core.Spectrum):
    """


    Thermal synchrotron spectrum.

    Example XML entity:

    C++ includes: GyotoThermalSynchrotronSpectrum.h 
    """

    __swig_setmethods__ = {}
    for _s in [gyoto.core.Spectrum]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ThermalSynchrotron, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.Spectrum]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ThermalSynchrotron, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(ThermalSynchrotron self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.ThermalSynchrotron_getProperties(self)


    def plugins(self, *args):
        """
        plugins(ThermalSynchrotron self, vector_string plugname)
        plugins(ThermalSynchrotron self) -> vector_string
        """
        return _std.ThermalSynchrotron_plugins(self, *args)


    def clone(self):
        """
        clone(ThermalSynchrotron self) -> ThermalSynchrotron



        Cloner. 
        """
        return _std.ThermalSynchrotron_clone(self)


    def __call__(self, *args):
        """
        __call__(ThermalSynchrotron self, double nu, double opacity, double ds) -> double
        __call__(ThermalSynchrotron self, double nu) -> double
        """
        return _std.ThermalSynchrotron___call__(self, *args)


    def temperature(self, *args):
        """
        temperature(ThermalSynchrotron self) -> double
        temperature(ThermalSynchrotron self, double tt)
        """
        return _std.ThermalSynchrotron_temperature(self, *args)


    def numberdensityCGS(self, *args):
        """
        numberdensityCGS(ThermalSynchrotron self) -> double
        numberdensityCGS(ThermalSynchrotron self, double rho)
        """
        return _std.ThermalSynchrotron_numberdensityCGS(self, *args)


    def angle_B_pem(self, *args):
        """
        angle_B_pem(ThermalSynchrotron self) -> double
        angle_B_pem(ThermalSynchrotron self, double rho)
        """
        return _std.ThermalSynchrotron_angle_B_pem(self, *args)


    def cyclotron_freq(self, *args):
        """
        cyclotron_freq(ThermalSynchrotron self) -> double
        cyclotron_freq(ThermalSynchrotron self, double rho)
        """
        return _std.ThermalSynchrotron_cyclotron_freq(self, *args)


    def angle_averaged(self, *args):
        """
        angle_averaged(ThermalSynchrotron self) -> bool
        angle_averaged(ThermalSynchrotron self, bool ang)
        """
        return _std.ThermalSynchrotron_angle_averaged(self, *args)


    def besselK2(self, *args):
        """
        besselK2(ThermalSynchrotron self) -> double
        besselK2(ThermalSynchrotron self, double bessel)
        """
        return _std.ThermalSynchrotron_besselK2(self, *args)


    def jnuCGS(self, nu):
        """
        jnuCGS(ThermalSynchrotron self, double nu) -> double



        Returns the emission coefficient j_nu in cgs units i.e. erg cm^-3 s^-1
        ster^-1 Hz^-1

        Parameters:
        -----------

        nu:  frequency in Hz 
        """
        return _std.ThermalSynchrotron_jnuCGS(self, nu)


    def jQnuCGS(self, nu):
        """
        jQnuCGS(ThermalSynchrotron self, double nu) -> double



        Returns the Stokes Q emission coefficient j_nu in cgs units i.e. erg
        cm^-3 s^-1 ster^-1 Hz^-1

        Parameters:
        -----------

        nu:  frequency in Hz 
        """
        return _std.ThermalSynchrotron_jQnuCGS(self, nu)


    def jUnuCGS(self, nu):
        """
        jUnuCGS(ThermalSynchrotron self, double nu) -> double



        Returns the Stokes U emission coefficient j_nu in cgs units i.e. erg
        cm^-3 s^-1 ster^-1 Hz^-1

        Parameters:
        -----------

        nu:  frequency in Hz 
        """
        return _std.ThermalSynchrotron_jUnuCGS(self, nu)


    def jVnuCGS(self, nu):
        """
        jVnuCGS(ThermalSynchrotron self, double nu) -> double



        Returns the Stokes V emission coefficient j_nu in cgs units i.e. erg
        cm^-3 s^-1 ster^-1 Hz^-1

        Parameters:
        -----------

        nu:  frequency in Hz 
        """
        return _std.ThermalSynchrotron_jVnuCGS(self, nu)


    def alphanuCGS(self, nu):
        """
        alphanuCGS(ThermalSynchrotron self, double nu) -> double



        Returns the absorption coefficient alpha_nu in cgs units [cm^-1]

        Parameters:
        -----------

        nu:  frequency in Hz 
        """
        return _std.ThermalSynchrotron_alphanuCGS(self, nu)


    def alphaQnuCGS(self, nu):
        """
        alphaQnuCGS(ThermalSynchrotron self, double nu) -> double



        Returns the Stokes Q absorption coefficient alpha_nu in cgs units
        [cm^-1]

        Parameters:
        -----------

        nu:  frequency in Hz 
        """
        return _std.ThermalSynchrotron_alphaQnuCGS(self, nu)


    def alphaUnuCGS(self, nu):
        """
        alphaUnuCGS(ThermalSynchrotron self, double nu) -> double



        Returns the Stokes U absorption coefficient alpha_nu in cgs units
        [cm^-1]

        Parameters:
        -----------

        nu:  frequency in Hz 
        """
        return _std.ThermalSynchrotron_alphaUnuCGS(self, nu)


    def alphaVnuCGS(self, nu):
        """
        alphaVnuCGS(ThermalSynchrotron self, double nu) -> double



        Returns the Stokes V absorption coefficient alpha_nu in cgs units
        [cm^-1]

        Parameters:
        -----------

        nu:  frequency in Hz 
        """
        return _std.ThermalSynchrotron_alphaVnuCGS(self, nu)


    def rQnuCGS(self, nu):
        """
        rQnuCGS(ThermalSynchrotron self, double nu) -> double



        Returns the Stokes Q Faraday rotation coefficient in cgs units [cm^-1]

        Parameters:
        -----------

        nu:  frequency in Hz 
        """
        return _std.ThermalSynchrotron_rQnuCGS(self, nu)


    def rUnuCGS(self, nu):
        """
        rUnuCGS(ThermalSynchrotron self, double nu) -> double



        Returns the Stokes U Faraday rotation coefficient in cgs units [cm^-1]

        Parameters:
        -----------

        nu:  frequency in Hz 
        """
        return _std.ThermalSynchrotron_rUnuCGS(self, nu)


    def rVnuCGS(self, nu):
        """
        rVnuCGS(ThermalSynchrotron self, double nu) -> double



        Returns the Stokes V Faraday rotation coefficient in cgs units [cm^-1]

        Parameters:
        -----------

        nu:  frequency in Hz 
        """
        return _std.ThermalSynchrotron_rVnuCGS(self, nu)


    def radiativeQ(self, *args):
        """
        radiativeQ(ThermalSynchrotron self, double [] jnu, double [] anu, double const [] nu_ems, size_t nbnu)
        radiativeQ(ThermalSynchrotron self, double [] jInu, double [] jQnu, double [] jUnu, double [] jVnu, double [] aInu, double [] aQnu, double [] aUnu, double [] aVnu, double [] rQnu, double [] rUnu, double [] rVnu, double const [] nu_ems, size_t nbnu)



        Returns the emission, absorption and Fraday rotation coef in SI for
        the 4 Stokes parameters 
        """
        return _std.ThermalSynchrotron_radiativeQ(self, *args)


    def __init__(self, *args):
        """
        __init__(Gyoto::Spectrum::ThermalSynchrotron self) -> ThermalSynchrotron
        __init__(Gyoto::Spectrum::ThermalSynchrotron self, ThermalSynchrotron arg2) -> ThermalSynchrotron
        __init__(Gyoto::Spectrum::ThermalSynchrotron self, Spectrum base) -> ThermalSynchrotron
        __init__(Gyoto::Spectrum::ThermalSynchrotron self, long address) -> ThermalSynchrotron
        """
        this = _std.new_ThermalSynchrotron(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _std.delete_ThermalSynchrotron
    __del__ = lambda self: None
ThermalSynchrotron_swigregister = _std.ThermalSynchrotron_swigregister
ThermalSynchrotron_swigregister(ThermalSynchrotron)
ThermalSynchrotron.properties = _std.cvar.ThermalSynchrotron_properties
ThermalSynchrotron.builtinPluginValue = _std.cvar.ThermalSynchrotron_builtinPluginValue

class PowerLawSynchrotron(gyoto.core.Spectrum):
    """


    Powerlaw synchrotron spectrum.

    Example XML entity:

    C++ includes: GyotoPowerLawSynchrotronSpectrum.h 
    """

    __swig_setmethods__ = {}
    for _s in [gyoto.core.Spectrum]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PowerLawSynchrotron, name, value)
    __swig_getmethods__ = {}
    for _s in [gyoto.core.Spectrum]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PowerLawSynchrotron, name)
    __repr__ = _swig_repr

    def getProperties(self):
        """
        getProperties(PowerLawSynchrotron self) -> Property



        Get list of properties.

        This method is declared automatically by the GYOTO_OBJECT macro and
        defined automatically by the GYOTO_PROPERTY_END macro. 
        """
        return _std.PowerLawSynchrotron_getProperties(self)


    def plugins(self, *args):
        """
        plugins(PowerLawSynchrotron self, vector_string plugname)
        plugins(PowerLawSynchrotron self) -> vector_string
        """
        return _std.PowerLawSynchrotron_plugins(self, *args)


    def clone(self):
        """
        clone(PowerLawSynchrotron self) -> PowerLawSynchrotron



        Cloner. 
        """
        return _std.PowerLawSynchrotron_clone(self)


    def __call__(self, *args):
        """
        __call__(PowerLawSynchrotron self, double nu, double opacity, double ds) -> double
        __call__(PowerLawSynchrotron self, double nu) -> double
        """
        return _std.PowerLawSynchrotron___call__(self, *args)


    def numberdensityCGS(self, *args):
        """
        numberdensityCGS(PowerLawSynchrotron self) -> double
        numberdensityCGS(PowerLawSynchrotron self, double rho)
        """
        return _std.PowerLawSynchrotron_numberdensityCGS(self, *args)


    def angle_B_pem(self, *args):
        """
        angle_B_pem(PowerLawSynchrotron self) -> double
        angle_B_pem(PowerLawSynchrotron self, double rho)
        """
        return _std.PowerLawSynchrotron_angle_B_pem(self, *args)


    def cyclotron_freq(self, *args):
        """
        cyclotron_freq(PowerLawSynchrotron self) -> double
        cyclotron_freq(PowerLawSynchrotron self, double rho)
        """
        return _std.PowerLawSynchrotron_cyclotron_freq(self, *args)


    def PLindex(self, *args):
        """
        PLindex(PowerLawSynchrotron self) -> double
        PLindex(PowerLawSynchrotron self, double ind)
        """
        return _std.PowerLawSynchrotron_PLindex(self, *args)


    def angle_averaged(self, *args):
        """
        angle_averaged(PowerLawSynchrotron self) -> bool
        angle_averaged(PowerLawSynchrotron self, bool ang)
        """
        return _std.PowerLawSynchrotron_angle_averaged(self, *args)


    def gamma_min(self, *args):
        """
        gamma_min(PowerLawSynchrotron self) -> double
        gamma_min(PowerLawSynchrotron self, double gmin)
        """
        return _std.PowerLawSynchrotron_gamma_min(self, *args)


    def gamma_max(self, *args):
        """
        gamma_max(PowerLawSynchrotron self) -> double
        gamma_max(PowerLawSynchrotron self, double gmax)
        """
        return _std.PowerLawSynchrotron_gamma_max(self, *args)


    def jnuCGS(self, nu):
        """
        jnuCGS(PowerLawSynchrotron self, double nu) -> double



        Returns the emission coefficient j_nu in cgs units i.e. erg cm^-3 s^-1
        ster^-1 Hz^-1

        Parameters:
        -----------

        nu:  frequency in Hz 
        """
        return _std.PowerLawSynchrotron_jnuCGS(self, nu)


    def jQnuCGS(self, nu):
        """
        jQnuCGS(PowerLawSynchrotron self, double nu) -> double



        Returns the Stokes Q emission coefficient j_nu in cgs units i.e. erg
        cm^-3 s^-1 ster^-1 Hz^-1

        Parameters:
        -----------

        nu:  frequency in Hz 
        """
        return _std.PowerLawSynchrotron_jQnuCGS(self, nu)


    def jUnuCGS(self, nu):
        """
        jUnuCGS(PowerLawSynchrotron self, double nu) -> double



        Returns the Stokes U emission coefficient j_nu in cgs units i.e. erg
        cm^-3 s^-1 ster^-1 Hz^-1

        Parameters:
        -----------

        nu:  frequency in Hz 
        """
        return _std.PowerLawSynchrotron_jUnuCGS(self, nu)


    def jVnuCGS(self, nu):
        """
        jVnuCGS(PowerLawSynchrotron self, double nu) -> double



        Returns the Stokes V emission coefficient j_nu in cgs units i.e. erg
        cm^-3 s^-1 ster^-1 Hz^-1

        Parameters:
        -----------

        nu:  frequency in Hz 
        """
        return _std.PowerLawSynchrotron_jVnuCGS(self, nu)


    def alphanuCGS(self, nu):
        """
        alphanuCGS(PowerLawSynchrotron self, double nu) -> double



        Returns the absorption coefficient alpha_nu in cgs units [cm^-1]

        Parameters:
        -----------

        nu:  frequency in Hz 
        """
        return _std.PowerLawSynchrotron_alphanuCGS(self, nu)


    def alphaQnuCGS(self, nu):
        """
        alphaQnuCGS(PowerLawSynchrotron self, double nu) -> double



        Returns the Stokes Q absorption coefficient alpha_nu in cgs units
        [cm^-1]

        Parameters:
        -----------

        nu:  frequency in Hz 
        """
        return _std.PowerLawSynchrotron_alphaQnuCGS(self, nu)


    def alphaUnuCGS(self, nu):
        """
        alphaUnuCGS(PowerLawSynchrotron self, double nu) -> double



        Returns the Stokes U absorption coefficient alpha_nu in cgs units
        [cm^-1]

        Parameters:
        -----------

        nu:  frequency in Hz 
        """
        return _std.PowerLawSynchrotron_alphaUnuCGS(self, nu)


    def alphaVnuCGS(self, nu):
        """
        alphaVnuCGS(PowerLawSynchrotron self, double nu) -> double



        Returns the Stokes V absorption coefficient alpha_nu in cgs units
        [cm^-1]

        Parameters:
        -----------

        nu:  frequency in Hz 
        """
        return _std.PowerLawSynchrotron_alphaVnuCGS(self, nu)


    def rQnuCGS(self, nu):
        """
        rQnuCGS(PowerLawSynchrotron self, double nu) -> double



        Returns the Stokes Q Faraday rotation coefficient in cgs units [cm^-1]

        Parameters:
        -----------

        nu:  frequency in Hz 
        """
        return _std.PowerLawSynchrotron_rQnuCGS(self, nu)


    def rUnuCGS(self, nu):
        """
        rUnuCGS(PowerLawSynchrotron self, double nu) -> double



        Returns the Stokes U Faraday rotation coefficient in cgs units [cm^-1]

        Parameters:
        -----------

        nu:  frequency in Hz 
        """
        return _std.PowerLawSynchrotron_rUnuCGS(self, nu)


    def rVnuCGS(self, nu):
        """
        rVnuCGS(PowerLawSynchrotron self, double nu) -> double



        Returns the Stokes V Faraday rotation coefficient in cgs units [cm^-1]

        Parameters:
        -----------

        nu:  frequency in Hz 
        """
        return _std.PowerLawSynchrotron_rVnuCGS(self, nu)


    def radiativeQ(self, *args):
        """
        radiativeQ(PowerLawSynchrotron self, double [] jnu, double [] anu, double const [] nu_ems, size_t nbnu)
        radiativeQ(PowerLawSynchrotron self, double [] jInu, double [] jQnu, double [] jUnu, double [] jVnu, double [] aInu, double [] aQnu, double [] aUnu, double [] aVnu, double [] rQnu, double [] rUnu, double [] rVnu, double const [] nu_ems, size_t nbnu)



        Returns the emission, absorption and Fraday rotation coef in SI for
        the 4 Stokes parameters 
        """
        return _std.PowerLawSynchrotron_radiativeQ(self, *args)


    def __init__(self, *args):
        """
        __init__(Gyoto::Spectrum::PowerLawSynchrotron self) -> PowerLawSynchrotron
        __init__(Gyoto::Spectrum::PowerLawSynchrotron self, PowerLawSynchrotron arg2) -> PowerLawSynchrotron
        __init__(Gyoto::Spectrum::PowerLawSynchrotron self, Spectrum base) -> PowerLawSynchrotron
        __init__(Gyoto::Spectrum::PowerLawSynchrotron self, long address) -> PowerLawSynchrotron
        """
        this = _std.new_PowerLawSynchrotron(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _std.delete_PowerLawSynchrotron
    __del__ = lambda self: None
PowerLawSynchrotron_swigregister = _std.PowerLawSynchrotron_swigregister
PowerLawSynchrotron_swigregister(PowerLawSynchrotron)
PowerLawSynchrotron.properties = _std.cvar.PowerLawSynchrotron_properties
PowerLawSynchrotron.builtinPluginValue = _std.cvar.PowerLawSynchrotron_builtinPluginValue

# This file is compatible with both classic and new-style classes.


